<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>絵文字大戦</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚔️</text></svg>">
<style>
    /* ========== 共通 & ガチャ画面スタイル ========== */
    :root { --ur: #ff0000; --lr: #ff00ff; --ssr: #ffd700; --sr: #00ffff; --r: #cd7f32; }
    body { font-family: 'Helvetica Neue', Arial, sans-serif; background-color: #050505; color: #fff; margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-x: hidden; padding: 20px; transition: background-color 1s ease; }
    
    /* スタート・ユーザー登録画面 */
    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9000; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
    #startScreen h1 { font-size: 36px; color: var(--lr); text-shadow: 0 0 20px var(--ur); margin-bottom: 20px; }
    .user-form { background: #1a1a1a; padding: 20px; border-radius: 15px; border: 1px solid #444; width: 300px; margin-bottom: 20px; }
    .user-input { width: 90%; padding: 10px; margin: 10px 0; border-radius: 5px; border: none; }
    
    /* ガチャコンテナ */
    .game-container { width: 100%; max-width: 500px; background: #1a2533; border-radius: 20px; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.9); border: 1px solid #333; margin-bottom: 20px; position: relative; z-index: 10; }
    .banner { width: 100%; height: 100px; background: linear-gradient(45deg, #000, #4b0082, #000); border-radius: 15px; display: flex; flex-direction: column; justify-content: center; align-items: center; margin-bottom: 20px; border: 2px solid var(--lr); position: relative; overflow: hidden;}
    .banner.fever-mode { border: 3px solid #ffd700; box-shadow: 0 0 20px #ffd700; animation: fever-shake 0.1s infinite; }
    @keyframes fever-shake { 0% { transform: translate(0,0); } 50% { transform: translate(2px, 2px); } 100% { transform: translate(-2px, -2px); } }

    /* 設定ボタン */
    #settingsBtn { position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #888; z-index: 100; }
    
    /* ステータスバー */
    .status-bar { background: rgba(0,0,0,0.7); padding: 12px; border-radius: 15px; margin-bottom: 15px; font-weight: bold; color: #00ffcc; border: 2px solid #00ffcc; text-align: center; position: relative; }
    .user-tag { position: absolute; top: -10px; left: 10px; background: #00ffcc; color: #000; font-size: 10px; padding: 2px 8px; border-radius: 10px; }
    .pity-counter { font-size: 12px; color: #ffd700; }

    /* ガチャ演出関連 */
    .result-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; min-height: 180px; margin-bottom: 20px; }
    .card { width: 100%; aspect-ratio: 2/3; position: relative; transform-style: preserve-3d; transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); cursor: pointer; }
    .card.is-open { transform: rotateY(180deg); }
    .card-front, .card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    .card-back { background: radial-gradient(circle, #444, #111); border: 2px solid #666; }
    .card-front { transform: rotateY(180deg); background: #fff; color: #333; overflow: hidden; }
    .card-ur { border: 3px solid var(--ur); box-shadow: 0 0 12px var(--ur); }
    .card-lr { border: 3px solid var(--lr); box-shadow: 0 0 8px var(--lr); }
    .card-ssr { border: 2px solid var(--ssr); }
    .card-sr { border: 2px solid var(--sr); }
    .card-r { border: 1px solid var(--r); }
    
    @keyframes upgrade-flash { 0% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.2); filter: brightness(3); box-shadow: 0 0 50px #fff; } 100% { transform: scale(1); filter: brightness(1); } }
    .upgrading { animation: upgrade-flash 1s ease-out; z-index: 100; }

    /* モーダル */
    #detailModal, #settingsModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); z-index: 5000; justify-content: center; align-items: center; }
    .modal-content { background: #1a1a1a; padding: 30px; border-radius: 25px; text-align: center; border: 4px solid #fff; width: 85%; max-width: 350px; color: white; position: relative; transition: 0.3s; }
    
    /* ========== 凸演出の変化（強化版） ========== */
    .lb-aura-1 { box-shadow: 0 0 15px var(--lb-color); }
    .lb-aura-3 { border-width: 4px !important; box-shadow: 0 0 25px var(--lb-color), 0 0 8px var(--lb-color) inset; }
    .lb-aura-5 { border-width: 5px !important; box-shadow: 0 0 35px var(--lb-color), 0 0 14px var(--lb-color) inset; animation: aura-pulse 1.5s infinite alternate; }
    .lb-aura-7 { border-width: 6px !important; box-shadow: 0 0 50px var(--lb-color), 0 0 20px var(--lb-color) inset; animation: aura-pulse 1s infinite alternate; }
    
    /* 10凸（完凸）特別演出 */
    .evolve-10 { 
        animation: awake-pulse 0.8s infinite alternate !important; 
        border: 6px solid #fff !important; 
        background: linear-gradient(135deg, #1a1a1a, #4b0082, #1a1a1a) !important;
        border-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet) 1 !important;
    }
    
    @keyframes aura-pulse { from { transform: scale(1); } to { transform: scale(1.02); } }
    @keyframes awake-pulse { 
        from { box-shadow: 0 0 20px #fff, 0 0 40px #ff00ea; transform: scale(1); } 
        to { box-shadow: 0 0 40px #fff, 0 0 70px #00ffcc; transform: scale(1.05); } 
    }

    /* ===== モーダル内 凸アイコンエフェクト ===== */
    #modalIconWrap { position: relative; display: inline-block; }
    #modalIconCanvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); pointer-events: none; }
    /* キャラ絵文字をリングの上に表示 */
    #modalIconEmoji { position: relative; z-index: 3; display: inline-block; }

    /* LBリング（凸数に応じて表示） */
    .lb-ring {
        position: absolute; top: 50%; left: 50%;
        border-radius: 50%; transform: translate(-50%, -50%);
        pointer-events: none;
    }
    .lb-ring-1  { width: 140px; height: 140px; border: 2px solid var(--lb-color); opacity: 0.5; }
    .lb-ring-3  { width: 140px; height: 140px; border: 2px solid var(--lb-color); animation: lb-ring-spin 4s linear infinite; opacity: 0.7; }
    .lb-ring-3b { width: 160px; height: 160px; border: 1px dashed var(--lb-color); animation: lb-ring-spin-rev 6s linear infinite; opacity: 0.4; }
    .lb-ring-5  { width: 140px; height: 140px; border: 3px solid var(--lb-color); animation: lb-ring-spin 3s linear infinite; box-shadow: 0 0 10px var(--lb-color); }
    .lb-ring-5b { width: 168px; height: 168px; border: 1px solid var(--lb-color); animation: lb-ring-spin-rev 5s linear infinite; opacity: 0.6; }
    .lb-ring-5c { width: 120px; height: 120px; border: 1px dashed var(--lb-color); animation: lb-ring-spin 7s linear infinite; opacity: 0.4; }
    .lb-ring-7  { width: 140px; height: 140px; border: 3px solid var(--lb-color); animation: lb-ring-spin 2s linear infinite; box-shadow: 0 0 18px var(--lb-color), 0 0 8px var(--lb-color) inset; }
    .lb-ring-7b { width: 170px; height: 170px; border: 2px solid var(--lb-color); animation: lb-ring-spin-rev 3.5s linear infinite; opacity: 0.7; }
    .lb-ring-7c { width: 115px; height: 115px; border: 2px dashed var(--lb-color); animation: lb-ring-spin 5s linear infinite; opacity: 0.5; box-shadow: 0 0 8px var(--lb-color); }
    @keyframes lb-ring-spin     { to { transform: translate(-50%,-50%) rotate(360deg);  } }
    @keyframes lb-ring-spin-rev { to { transform: translate(-50%,-50%) rotate(-360deg); } }

    /* MAX凸リング（虹色） */
    .lb-ring-max  { width: 150px; height: 150px; border: 4px solid transparent;
        background: linear-gradient(#1a1a1a,#1a1a1a) padding-box, conic-gradient(red,orange,yellow,green,cyan,blue,violet,red) border-box;
        animation: lb-ring-spin 1.5s linear infinite; box-shadow: 0 0 28px rgba(255,255,255,0.6); }
    .lb-ring-max2 { width: 178px; height: 178px; border: 2px solid transparent;
        background: linear-gradient(#1a1a1a,#1a1a1a) padding-box, conic-gradient(violet,red,orange,yellow,green,cyan,blue,violet) border-box;
        animation: lb-ring-spin-rev 2.5s linear infinite; opacity: 0.7; }
    .lb-ring-max3 { width: 120px; height: 120px; border: 3px solid transparent;
        background: linear-gradient(#1a1a1a,#1a1a1a) padding-box, conic-gradient(blue,violet,red,orange,yellow,green,cyan,blue) border-box;
        animation: lb-ring-spin 3.5s linear infinite; opacity: 0.5; }

    /* 凸星スパーク */
    .lb-star { position: absolute; border-radius: 50%; background: var(--lb-color); animation: lb-star-twinkle 1.5s ease-in-out infinite alternate; }
    @keyframes lb-star-twinkle { from { opacity: 0.3; transform: scale(0.7) translate(-50%,-50%); } to { opacity: 1; transform: scale(1.4) translate(-50%,-50%); box-shadow: 0 0 6px var(--lb-color); } }

    /* ===== 英傑の号令演出オーバーレイ ===== */
    #orderOverlay { display: none; position: fixed; inset: 0; z-index: 7600; pointer-events: none; overflow: hidden; }
    #orderOverlay.active { display: block; }
    #orderOverlayBg { position: absolute; inset: 0; background: radial-gradient(ellipse at center, rgba(180,0,255,0.55) 0%, transparent 70%); animation: skill-bg-flash 1.0s ease-out forwards; }
    #orderOverlayText {
        position: absolute; top: 32%; left: 50%; transform: translateX(-50%);
        text-align: center; white-space: nowrap;
        animation: order-text-appear 0.7s cubic-bezier(0.15, 1.5, 0.3, 1) forwards;
        background: rgba(0,0,0,0.82);
        border: 2px solid #cc88ff;
        border-radius: 18px;
        padding: 18px 36px 20px 36px;
        box-shadow: 0 0 40px rgba(0,0,0,0.8), 0 0 30px rgba(180,0,255,0.4), inset 0 0 20px rgba(180,0,255,0.05);
        backdrop-filter: blur(4px);
        min-width: 260px;
    }
    @keyframes order-text-appear {
        from { transform: translateX(-50%) scale(0.1) rotate(-15deg); opacity: 0; }
        to   { transform: translateX(-50%) scale(1) rotate(0deg);     opacity: 1; }
    }
    #orderOverlayIcon { font-size: 56px; display: block; margin-bottom: 8px; filter: drop-shadow(0 0 16px #cc88ff); animation: order-icon-pulse 0.5s ease-in-out infinite alternate; }
    @keyframes order-icon-pulse { from { transform: scale(1); } to { transform: scale(1.1); filter: drop-shadow(0 0 28px #ff88ff); } }
    #orderOverlayTitle { font-size: 26px; font-weight: 900; letter-spacing: 3px; color: #cc88ff; text-shadow: 0 0 20px #cc88ff, 0 0 40px #8800ff; display: block; margin-bottom: 6px; }
    #orderOverlaySubtitle { font-size: 13px; letter-spacing: 3px; color: rgba(220,180,255,0.85); display: block; }
    #orderOverlayLines { position: absolute; inset: 0; pointer-events: none; }

    /* ===== ボススキル演出オーバーレイ ===== */
    #bossSkillOverlay { display: none; position: fixed; inset: 0; z-index: 7550; pointer-events: none; overflow: hidden; }
    #bossSkillOverlay.active { display: block; }
    #bossSkillOverlayBg { position: absolute; inset: 0; background: radial-gradient(ellipse at center, rgba(255,0,100,0.6) 0%, transparent 70%); animation: skill-bg-flash 0.8s ease-out forwards; }
    #bossSkillOverlayText {
        position: absolute; top: 32%; left: 50%; transform: translateX(-50%);
        text-align: center; white-space: nowrap;
        animation: skill-text-appear 0.55s cubic-bezier(0.2, 1.5, 0.4, 1) forwards;
        background: rgba(20,0,10,0.88);
        border: 2px solid #ff0080;
        border-radius: 18px;
        padding: 16px 32px 18px 32px;
        box-shadow: 0 0 40px rgba(0,0,0,0.8), 0 0 30px rgba(255,0,100,0.4), inset 0 0 16px rgba(255,0,100,0.08);
        backdrop-filter: blur(4px);
        min-width: 250px;
    }
    #bossSkillOverlayIcon { font-size: 56px; display: block; margin-bottom: 6px; filter: drop-shadow(0 0 14px #ff0080); animation: order-icon-pulse 0.4s ease-in-out infinite alternate; }
    #bossSkillOverlayTitle { font-size: 24px; font-weight: 900; letter-spacing: 3px; color: #ff4488; text-shadow: 0 0 20px #ff0080, 0 0 40px #ff0000; display: block; margin-bottom: 4px; }
    #bossSkillOverlayMsg { font-size: 11px; letter-spacing: 2px; color: rgba(255,180,210,0.85); display: block; }
    #bossSkillOverlayLines { position: absolute; inset: 0; pointer-events: none; }

    /* ===== 勝利・敗北演出オーバーレイ ===== */
    #battleResultOverlay { display: none; position: fixed; inset: 0; z-index: 9100; justify-content: center; align-items: center; flex-direction: column; }
    #battleResultOverlay.active { display: flex; }
    #battleResultOverlay.victory { background: radial-gradient(ellipse at center, rgba(0,30,60,0.97) 0%, rgba(0,0,0,0.98) 100%); }
    #battleResultOverlay.defeat  { background: radial-gradient(ellipse at center, rgba(40,0,0,0.97) 0%, rgba(0,0,0,0.98) 100%); }
    #battleResultContent {
        text-align: center; padding: 40px 36px;
        animation: result-content-in 0.9s cubic-bezier(0.15, 1.4, 0.3, 1) both;
        position: relative; z-index: 2;
    }
    @keyframes result-content-in {
        from { transform: scale(0.2) rotate(-10deg); opacity: 0; filter: blur(8px); }
        to   { transform: scale(1) rotate(0deg); opacity: 1; filter: blur(0); }
    }
    #battleResultIcon { font-size: 100px; display: block; margin-bottom: 16px; animation: result-icon-float 2s ease-in-out infinite alternate; }
    @keyframes result-icon-float { from { transform: translateY(0) scale(1); } to { transform: translateY(-12px) scale(1.06); filter: brightness(1.3); } }
    #battleResultTitle {
        font-size: 52px; font-weight: 900; letter-spacing: 6px; display: block; margin-bottom: 10px;
        animation: result-title-glow 1s ease-in-out infinite alternate;
    }
    #battleResultOverlay.victory #battleResultTitle { color: #ffd700; text-shadow: 0 0 20px #ffd700, 0 0 50px #ffaa00, 0 0 80px #ff6600; }
    #battleResultOverlay.defeat  #battleResultTitle { color: #ff4444; text-shadow: 0 0 20px #ff0000, 0 0 50px #cc0000; }
    @keyframes result-title-glow {
        from { filter: brightness(1); }
        to   { filter: brightness(1.3) drop-shadow(0 0 16px currentColor); }
    }
    #battleResultSub { font-size: 14px; letter-spacing: 3px; color: rgba(255,255,255,0.7); margin-bottom: 28px; display: block; }
    #battleResultOverlay.victory #battleResultSub { color: #ffe066; }
    #battleResultOverlay.defeat  #battleResultSub { color: #ff9999; }
    #battleResultReward { font-size: 20px; font-weight: bold; color: #ffd700; margin-bottom: 24px; display: block; min-height: 28px; }
    #battleResultBtn {
        font-size: 16px; font-weight: bold; padding: 14px 48px; border: none; border-radius: 30px; cursor: pointer; letter-spacing: 2px;
        animation: result-btn-glow 1.2s ease-in-out infinite alternate;
    }
    #battleResultOverlay.victory #battleResultBtn { background: linear-gradient(135deg, #ffd700, #ff8c00); color: #000; box-shadow: 0 0 22px rgba(255,180,0,0.6); }
    #battleResultOverlay.defeat  #battleResultBtn { background: linear-gradient(135deg, #c0392b, #96281b); color: #fff; box-shadow: 0 0 22px rgba(200,0,0,0.5); }
    #battleResultRestartBtn {
        display: none; font-size: 14px; font-weight: bold; padding: 12px 36px; border: none; border-radius: 30px; cursor: pointer; letter-spacing: 2px;
        margin-top: 12px; background: linear-gradient(135deg, #1a5276, #2471a3); color: #fff; box-shadow: 0 0 18px rgba(0,100,200,0.5);
    }
    #battleResultRestartBtn:hover { filter: brightness(1.2); }
    @keyframes result-btn-glow {
        from { box-shadow: 0 0 16px rgba(255,180,0,0.5); }
        to   { box-shadow: 0 0 36px rgba(255,180,0,0.9), 0 0 70px rgba(255,80,0,0.4); }
    }
    /* 勝利パーティクルキャンバス */
    #battleResultCanvas { position: absolute; inset: 0; pointer-events: none; z-index: 1; }
    /* 勝利光線 */
    #battleResultRays { position: absolute; inset: 0; pointer-events: none; z-index: 0; }
    #battleResultRays::before {
        content: ''; position: absolute;
        width: 250vmax; height: 250vmax; top: 50%; left: 50%; transform: translate(-50%,-50%);
        background: conic-gradient(transparent 0deg, rgba(255,215,0,0.05) 8deg, transparent 16deg, transparent 25deg, rgba(255,150,0,0.04) 33deg, transparent 41deg, transparent 90deg, rgba(255,215,0,0.05) 98deg, transparent 106deg, transparent 180deg, rgba(255,150,0,0.04) 188deg, transparent 196deg, transparent 270deg, rgba(255,215,0,0.05) 278deg, transparent 286deg);
        animation: kk-spin 6s linear infinite;
    }

    /* ===== バトルスキル演出 オーバーレイ ===== */
    #skillOverlay { display: none; position: fixed; inset: 0; z-index: 7500; pointer-events: none; overflow: hidden; }
    #skillOverlay.active { display: block; }
    #skillOverlayBg { position: absolute; inset: 0; animation: skill-bg-flash 0.5s ease-out forwards; }
    @keyframes skill-bg-flash { 0% { opacity: 0; } 20% { opacity: 1; } 100% { opacity: 0; } }
    #skillOverlayBg.rarity-ur  { background: radial-gradient(ellipse at center, rgba(255,50,0,0.6)   0%, transparent 70%); }
    #skillOverlayBg.rarity-lr  { background: radial-gradient(ellipse at center, rgba(200,0,255,0.6)  0%, transparent 70%); }
    #skillOverlayBg.rarity-ssr { background: radial-gradient(ellipse at center, rgba(255,215,0,0.5)  0%, transparent 70%); }
    #skillOverlayBg.rarity-sr  { background: radial-gradient(ellipse at center, rgba(0,255,200,0.45) 0%, transparent 70%); }
    #skillOverlayBg.rarity-r   { background: radial-gradient(ellipse at center, rgba(180,120,50,0.4) 0%, transparent 70%); }
    #skillOverlayText {
        position: absolute; top: 36%; left: 50%; transform: translateX(-50%);
        text-align: center; white-space: nowrap;
        animation: skill-text-appear 0.6s cubic-bezier(0.2, 1.5, 0.4, 1) forwards;
        background: rgba(0,0,0,0.78);
        border: 2px solid rgba(255,255,255,0.35);
        border-radius: 18px;
        padding: 14px 30px 16px 30px;
        box-shadow: 0 0 30px rgba(0,0,0,0.7), inset 0 0 20px rgba(255,255,255,0.04);
        backdrop-filter: blur(4px);
        min-width: 240px;
    }
    @keyframes skill-text-appear {
        from { transform: translateX(-50%) scale(0.2) rotate(-10deg); opacity: 0; }
        to   { transform: translateX(-50%) scale(1)   rotate(0deg);   opacity: 1; }
    }
    #skillOverlayCharIcon { font-size: 52px; display: block; margin-bottom: 6px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.6)); }
    .skill-overlay-skill-name { font-size: 28px; font-weight: 900; letter-spacing: 3px; color: #fff; text-shadow: 0 0 24px currentColor, 0 0 48px currentColor; display: block; margin-bottom: 6px; }
    .skill-overlay-char-name  { font-size: 13px; letter-spacing: 4px; color: rgba(255,255,255,0.75); display: block; }
    #skillOverlayLines { position: absolute; inset: 0; pointer-events: none; }
    .skill-line {
        position: absolute; top: 0; left: 50%; width: 2px; height: 100%;
        background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.35), transparent);
        transform-origin: top center;
        animation: skill-line-shoot 0.55s ease-out forwards;
    }
    @keyframes skill-line-shoot {
        from { opacity: 0.9; transform: scaleY(0) rotate(var(--angle)); }
        to   { opacity: 0;   transform: scaleY(1) rotate(var(--angle)); }
    }

    /* スキル発動時のスロット演出 強化版 */
    .skill-flash { animation: skill-slot-glow 0.25s infinite alternate; z-index: 10; transform: scale(1.18); }
    @keyframes skill-slot-glow {
        from { filter: brightness(1.4) saturate(1.5); box-shadow: 0 0 20px #fff; }
        to   { filter: brightness(3)   saturate(2.5); box-shadow: 0 0 50px #fff, 0 0 80px currentColor; }
    }
    @keyframes skill-glow { from { background: #222; } to { background: #ff0; color: #000; } }

    .skill-box { background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; text-align:left; border-left:5px solid #00ffcc; margin-top: 15px;}
    .box-container { width: 100%; max-width: 500px; background: #111; border-radius: 15px; padding: 20px; border: 1px solid #444; }
    .rarity-section { margin-bottom: 20px; }
    .rarity-label { font-size: 12px; font-weight: bold; padding: 2px 10px; border-radius: 4px; display: inline-block; margin-bottom: 8px; }
    .collection-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    .box-item { aspect-ratio: 1/1; background: #222; border-radius: 6px; display: flex; justify-content: center; align-items: center; font-size: 20px; position: relative; border: 2px solid #333; opacity: 0.4; filter: grayscale(1); cursor: pointer;}
    .box-item.owned { opacity: 1; filter: grayscale(0); }
    .count-badge { position: absolute; top: -5px; right: -5px; background: #333; color: #00ffcc; font-size: 9px; padding: 1px 4px; border-radius: 4px; border: 1px solid #00ffcc; font-weight: bold; }
    
    #flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 6000; opacity: 0; }
    @keyframes f-ur { 0% { opacity: 1; background: #fff; } 10% { background: #ff0000; } 15% { background: #fff; } 20% { background: #000; } 100% { opacity: 0; } }
    @keyframes badge-pulse { from { opacity: 0.85; } to { opacity: 1; filter: brightness(1.3); } }
    @keyframes f-lr { 0% { opacity: 1; background: #fff; } 10% { background: #ff00ff; } 15% { background: #fff; } 100% { opacity: 0; } }
    @keyframes f-fever { 0% { opacity: 1; background: #ffd700; } 50% { background: #fff; } 100% { opacity: 0; } }
    .flash-ur { animation: f-ur 2.5s forwards; }
    .flash-lr { animation: f-lr 2s forwards; }
    .flash-fever { animation: f-fever 1.5s forwards; }

    .btn { width: 100%; padding: 15px; border: none; border-radius: 12px; font-weight: bold; font-size: 16px; cursor: pointer; color: white; background: linear-gradient(#e67e22, #d35400); box-shadow: 0 4px 0 #8e44ad; transition: 0.2s; margin-top: 10px; text-align: center; text-decoration: none; box-sizing: border-box; display: block;}
    .btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #8e44ad; }
    .btn-sub { background: #444; box-shadow: 0 4px 0 #222; }
    .btn-battle { background: linear-gradient(#2ecc71, #27ae60); box-shadow: 0 4px 0 #1e8449; }

    /* ========== バトル画面スタイル ========== */
    .game-wrapper { width: 100%; max-width: 600px; padding: 20px; box-sizing: border-box; }
    .header { display: flex; justify-content: space-between; align-items: center; background: #1a1a1a; padding: 10px 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #333; }
    .floor-display { text-align: center; color: #ffd700; font-size: 20px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 10px #f00; }
    .battle-field { background: linear-gradient(to bottom, #000, #2c0000); border: 2px solid #500; border-radius: 20px; padding: 20px; position: relative; margin-bottom: 20px; min-height: 300px; display: flex; flex-direction: column; justify-content: space-between; transition: transform 0.1s, background 1s ease, box-shadow 1s ease; }
    .boss-area { text-align: center; padding: 20px; }
    .boss-icon { font-size: 80px; text-shadow: 0 0 30px #f00; animation: boss-float 3s infinite ease-in-out; }
    @keyframes boss-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    .shake { animation: shake-anim 0.3s infinite; }
    @keyframes shake-anim { 0% { transform: translate(2px, 2px); } 25% { transform: translate(-2px, -2px); } 50% { transform: translate(-2px, 2px); } 75% { transform: translate(2px, -2px); } 100% { transform: translate(0, 0); } }
    .hp-bar-container { width: 100%; height: 20px; background: #333; border-radius: 10px; overflow: hidden; border: 1px solid #fff; margin-top: 10px; }
    .hp-bar-fill { height: 100%; width: 100%; transition: width 0.3s ease; }
    .hp-boss { background: linear-gradient(to right, #f00, #ff00ff); }
    .hp-player { background: linear-gradient(to right, #00ffcc, #00ff00); }
    .party-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 20px; }
    .unit-slot { aspect-ratio: 2/3; background: rgba(255,255,255,0.05); border: 1px dashed #666; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; cursor: pointer; position: relative; transition: 0.3s; }
    .unit-slot.occupied { border-style: solid; background: #222; }
    .unit-icon { font-size: 24px; pointer-events: none; }
    .unit-hp-mini { width: 80%; height: 4px; background: #444; margin-top: 4px; pointer-events: none; position: relative; border-radius: 2px; overflow: visible; }
    .unit-hp-mini-bar { position: absolute; top: 0; left: 0; height: 100%; border-radius: 2px; }
    .unit-shield-bar { position: absolute; top: -3px; left: 0; height: 10px; border-radius: 2px; background: linear-gradient(to right, #00aaff, #44ddff); opacity: 0.85; box-shadow: 0 0 5px #00aaff, 0 0 2px #fff; pointer-events: none; transition: width 0.3s ease; }
    .unit-shield-label { position: absolute; top: 6px; left: 50%; transform: translateX(-50%); font-size: 7px; color: #44ddff; font-weight: bold; white-space: nowrap; pointer-events: none; text-shadow: 0 0 4px #00aaff; }
    .unit-slot:hover::after { content: attr(data-info); position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.95); border: 1px solid #fff; padding: 8px; width: 160px; font-size: 10px; border-radius: 5px; z-index: 5000; pointer-events: none; white-space: pre-wrap; color: #fff; text-align: left; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
    .owned-list .unit-slot:nth-child(5n):hover::after, .owned-list .unit-slot:nth-child(5n-1):hover::after { left: auto; right: 0; transform: translateX(0); }
    .owned-list .unit-slot:nth-child(5n+1):hover::after { left: 0; transform: translateX(0); }
    .skill-flash { animation: skill-glow 0.3s infinite alternate; z-index: 10; transform: scale(1.15); box-shadow: 0 0 30px #fff; }
    @keyframes skill-glow { from { background: #222; } to { background: #ff0; color: #000; } }
    .battle-log { background: rgba(0,0,0,0.8); border: 1px solid #444; height: 100px; overflow-y: auto; padding: 10px; font-size: 12px; color: #0f0; font-family: monospace; border-radius: 5px; margin-bottom: 15px; }
    #selectorModal { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index: 7000; justify-content:center; align-items:center; }
    .selector-content { background:#1a1a1a; width:95%; max-width:800px; height:85vh; border-radius:20px; padding:20px; display:flex; flex-direction:column; position: relative; border: 1px solid #444; }
    .owned-list { flex:1; overflow-y:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap:15px; padding: 120px 10px 20px 10px; align-content: start; }
    .unit-slot.banned { filter: grayscale(1) brightness(0.5); cursor: not-allowed; pointer-events: none; }
    .banned-label { position: absolute; background: #f00; color: #fff; font-size: 10px; padding: 2px 5px; border-radius: 3px; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-15deg); z-index: 5; white-space: nowrap; }
    
    .btn-attack { background: linear-gradient(#e74c3c, #c0392b); color: #fff; width: 100%; font-size: 18px; box-shadow: 0 4px 0 #7b241c; }
    .btn-attack:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
    .btn-nav { background: #34495e; color: #fff; font-size: 12px; margin-top: 0; padding: 10px; display: inline-block; width: auto; box-shadow: 0 4px 0 #2c3e50;}
    .btn-pause { background: linear-gradient(#f39c12, #e67e22); color: #fff; font-size: 16px; box-shadow: 0 4px 0 #ca6f1e; width: auto; padding: 12px 20px; flex: 1; margin-top: 10px; }
    .btn-order { background: linear-gradient(#8e44ad, #6c3483); color: #fff; font-size: 14px; box-shadow: 0 4px 0 #4a235a; width: 100%; margin-top: 8px; padding: 12px; }
    .btn-order:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
    .battle-action-row { display: flex; gap: 8px; margin-top: 0; }
    .pause-overlay { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.75); backdrop-filter: blur(6px); z-index: 8000; justify-content: center; align-items: center; flex-direction: column; }
    .pause-overlay.active { display: flex; }
    .pause-box { background: #1a1a1a; border: 3px solid #f39c12; border-radius: 20px; padding: 40px 30px; text-align: center; }
    /* スマホ向けキャラ選択モーダル改善 */
    .owned-list { flex:1; overflow-y:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap:10px; padding: 8px 8px 16px 8px; align-content: start; }
    .selector-content { background:#1a1a1a; width:95%; max-width:800px; height:85vh; border-radius:20px; padding:15px; display:flex; flex-direction:column; position: relative; border: 1px solid #444; box-sizing: border-box; overflow:hidden; }
    .owned-list .unit-slot { min-height: 90px; font-size: 9px; }
    .owned-list .unit-slot .unit-icon { font-size: 28px; }
    @media (max-width: 480px) {
        .owned-list { grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px; padding-top: 65px; }
        .owned-list .unit-slot { min-height: 80px; }
        .owned-list .unit-slot .unit-icon { font-size: 24px; }
        .party-grid { gap: 6px; }
        .unit-slot { font-size: 8px; }
        .unit-icon { font-size: 20px !important; }
    }
    .damage-pop { position: absolute; color: #ff0; font-weight: 900; font-size: 24px; pointer-events: none; animation: pop-up 0.8s forwards; z-index: 2100; text-shadow: 2px 2px 0 #000; }
    .damage-pop.player { color: #f00; font-size: 20px; z-index: 2200;}
    .damage-pop.heal { color: #0f0; }
    @keyframes pop-up { 0% { opacity:1; transform:translateY(0); } 100% { opacity:0; transform:translateY(-80px); } }

    /* ========== タイトルロゴ ========== */
    .title-logo {
        font-size: 52px; font-weight: 900; letter-spacing: 4px;
        background: linear-gradient(135deg, #ff0080, #ff6600, #ffd700, #00ffcc, #ff00ff);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        text-shadow: none; filter: drop-shadow(0 0 18px #ff00cc);
        animation: logo-shine 3s ease-in-out infinite alternate;
        line-height: 1.1; margin-bottom: 4px;
    }
    .title-logo-sub {
        font-size: 13px; letter-spacing: 8px; color: #aaa; text-transform: uppercase;
        margin-bottom: 18px;
    }
    @keyframes logo-shine {
        0%   { filter: drop-shadow(0 0 12px #ff0080) drop-shadow(0 0 4px #ffd700); }
        50%  { filter: drop-shadow(0 0 22px #00ffcc) drop-shadow(0 0 8px #ff00ff); }
        100% { filter: drop-shadow(0 0 16px #ff6600) drop-shadow(0 0 6px #ff0080); }
    }
    .title-deco { font-size: 28px; margin-bottom: 8px; animation: deco-spin 6s linear infinite; display: inline-block; }
    @keyframes deco-spin { 0% { transform: rotate(0deg) scale(1); } 50% { transform: rotate(180deg) scale(1.2); } 100% { transform: rotate(360deg) scale(1); } }

    /* ========== ガチャタブ ========== */
    .gacha-tabs { display: flex; gap: 6px; margin-bottom: 0; width: 100%; max-width: 500px; }
    .gacha-tab { flex: 1; padding: 10px 4px; border: none; border-radius: 10px 10px 0 0; font-size: 11px; font-weight: bold; cursor: pointer; color: #aaa; background: #111; border-bottom: 2px solid #333; transition: 0.2s; }
    .gacha-tab.active-tab { color: #fff; background: #1a2533; border-bottom: 2px solid transparent; }
    .gacha-tab.tab-standard.active-tab { border-top: 2px solid #00ffcc; color: #00ffcc; }
    .gacha-tab.tab-lr.active-tab { border-top: 2px solid #ff00ff; color: #ff00ff; }
    .gacha-tab.tab-ur.active-tab { border-top: 2px solid #ff4444; color: #ff4444; }

    /* ========== ガチャバナー（大型） ========== */
    .banner-large {
        width: 100%; min-height: 130px; border-radius: 15px; margin-bottom: 12px;
        position: relative; overflow: hidden; display: flex; flex-direction: column;
        justify-content: flex-end; padding: 14px; box-sizing: border-box;
        border: 2px solid #555;
    }
    .banner-large.banner-standard { background: linear-gradient(135deg, #0a0a1a 0%, #1a0a3a 40%, #0d2a1a 100%); border-color: #00ffcc; }
    .banner-large.banner-lr       { background: linear-gradient(135deg, #1a0020 0%, #3a0040 50%, #200030 100%); border-color: #ff00ff; }
    .banner-large.banner-ur       { background: linear-gradient(135deg, #200000 0%, #4a0000 50%, #200010 100%); border-color: #ff3333; }
    .banner-deco-chars { position: absolute; top: 0; right: 0; bottom: 0; width: 55%; display: flex; align-items: center; justify-content: flex-end; padding-right: 12px; gap: 4px; pointer-events: none; }
    .banner-pickup-icon { font-size: 52px; filter: drop-shadow(0 0 12px rgba(255,255,255,0.5)); animation: banner-float 3s ease-in-out infinite alternate; }
    .banner-pickup-icon:nth-child(2) { font-size: 36px; animation-delay: 1s; opacity: 0.7; }
    @keyframes banner-float { from { transform: translateY(0); } to { transform: translateY(-8px); } }
    .banner-info { position: relative; z-index: 2; }
    .banner-tag { display: inline-block; font-size: 9px; font-weight: bold; padding: 2px 8px; border-radius: 4px; margin-bottom: 5px; letter-spacing: 1px; }
    .banner-tag.tag-standard { background: #00ffcc; color: #000; }
    .banner-tag.tag-lr { background: #ff00ff; color: #000; }
    .banner-tag.tag-ur { background: linear-gradient(90deg, #ff2200, #ff6600); color: #fff; }
    .banner-title-text { font-size: 18px; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); margin-bottom: 3px; }
    .banner-pickup-name { font-size: 12px; color: #ddd; }
    .banner-pickup-name span { font-weight: bold; }
    .banner-timer { font-size: 10px; color: #aaa; margin-top: 3px; }
    .banner-timer .timer-val { color: #ffd700; font-weight: bold; }
    .banner-shine {
        position: absolute; top: -50%; left: -60%; width: 40%; height: 200%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent);
        transform: skewX(-20deg); animation: banner-shine 4s ease-in-out infinite;
    }
    @keyframes banner-shine { 0% { left: -60%; } 60%, 100% { left: 120%; } }
    .banner.fever-mode { border: 3px solid #ffd700; box-shadow: 0 0 20px #ffd700; animation: fever-shake 0.1s infinite; }

    /* ========== 一時停止ログ ========== */
    .pause-log-area { background: #0a0a0a; border: 1px solid #333; border-radius: 10px; max-height: 260px; overflow-y: auto; padding: 10px; font-size: 11px; color: #0f0; font-family: monospace; margin-top: 16px; text-align: left; width: 100%; box-sizing: border-box; }
    .pause-log-area div { padding: 1px 0; border-bottom: 1px solid #111; }

    /* ========== 覚醒確定演出 ========== */
    #kakusei-overlay {
        display: none; position: fixed; inset: 0; z-index: 9800;
        background: #000; justify-content: center; align-items: center;
        flex-direction: column; overflow: hidden;
    }
    #kakusei-overlay.active { display: flex; }

    /* 光線背景 */
    .kk-rays {
        position: absolute; inset: 0; display: flex; justify-content: center; align-items: center;
        pointer-events: none;
    }
    .kk-rays::before {
        content: ''; position: absolute;
        width: 250vmax; height: 250vmax;
        background: conic-gradient(
            transparent 0deg,   rgba(255,100,255,0.09) 8deg,  transparent 16deg,
            transparent 25deg,  rgba(255,200,50,0.07)  33deg, transparent 41deg,
            transparent 50deg,  rgba(100,200,255,0.07) 58deg, transparent 66deg,
            transparent 90deg,  rgba(255,100,255,0.09) 98deg, transparent 106deg,
            transparent 135deg, rgba(255,200,50,0.07)  143deg,transparent 151deg,
            transparent 180deg, rgba(100,200,255,0.07) 188deg,transparent 196deg,
            transparent 225deg, rgba(255,100,255,0.09) 233deg,transparent 241deg,
            transparent 270deg, rgba(255,200,50,0.07)  278deg,transparent 286deg,
            transparent 315deg, rgba(100,200,255,0.07) 323deg,transparent 331deg
        );
        animation: kk-spin 4s linear infinite;
    }
    @keyframes kk-spin { to { transform: rotate(360deg); } }

    /* 背景グロー */
    .kk-bg {
        position: absolute; inset: 0;
        animation: kk-bg-pulse 0.7s ease-in-out infinite alternate;
    }
    .kk-bg.lr { background: radial-gradient(ellipse at center, #280040 0%, #000 65%); }
    .kk-bg.ur { background: radial-gradient(ellipse at center, #300000 0%, #000 65%); }
    @keyframes kk-bg-pulse {
        from { opacity: 0.8; }
        to   { opacity: 1; }
    }

    /* パーティクルキャンバス */
    #kk-canvas { position: absolute; inset: 0; pointer-events: none; }

    /* メインコンテンツ */
    .kk-content {
        position: relative; z-index: 5; text-align: center; padding: 24px 20px;
        opacity: 0;
    }
    .kk-content.visible {
        animation: kk-content-in 0.8s cubic-bezier(0.15, 1.4, 0.4, 1) forwards;
        opacity: 1;
    }
    @keyframes kk-content-in {
        from { transform: scale(0.1) rotate(-20deg); opacity: 0; filter: blur(8px); }
        to   { transform: scale(1)   rotate(0deg);   opacity: 1; filter: blur(0); }
    }

    /* ラベル点滅 */
    .kk-label {
        font-size: 12px; letter-spacing: 6px; font-weight: 900;
        margin-bottom: 14px; text-transform: uppercase;
        animation: kk-label-blink 0.6s ease-in-out infinite alternate;
    }
    .kk-label.lr { color: #ff88ff; text-shadow: 0 0 14px #ff00ff, 0 0 28px #ff00ff; }
    .kk-label.ur { color: #ffaa44; text-shadow: 0 0 14px #ff4400, 0 0 28px #ff2200; }
    @keyframes kk-label-blink {
        from { opacity: 0.75; }
        to   { opacity: 1; filter: brightness(1.4); }
    }

    /* キャラアイコン周辺 */
    .kk-icon-wrap { position: relative; display: inline-block; margin-bottom: 18px; }
    .kk-icon {
        font-size: 108px; display: block; position: relative; z-index: 2;
        animation: kk-icon-pulse 0.45s ease-in-out infinite alternate;
    }
    @keyframes kk-icon-pulse {
        from { transform: scale(1) rotate(-3deg);
               filter: drop-shadow(0 0 24px rgba(255,255,255,0.7)); }
        to   { transform: scale(1.12) rotate(3deg);
               filter: drop-shadow(0 0 50px rgba(255,255,255,1)) drop-shadow(0 0 90px rgba(255,100,255,0.7)); }
    }

    /* 覚醒演出：追加オーラリング */
    .kk-aura-ring {
        position: absolute; top: 50%; left: 50%; border-radius: 50%;
        transform: translate(-50%, -50%); pointer-events: none; z-index: 1;
    }
    .kk-aura-ring.lr { border: 2px solid rgba(255,0,255,0.5); animation: kk-aura-expand 2s ease-out infinite; }
    .kk-aura-ring.ur { border: 2px solid rgba(255,80,0,0.5);  animation: kk-aura-expand 2s ease-out infinite; }
    .kk-aura-ring:nth-child(2) { animation-delay: 0.67s; }
    .kk-aura-ring:nth-child(3) { animation-delay: 1.34s; }
    @keyframes kk-aura-expand {
        0%   { width: 100px; height: 100px; opacity: 0.9; }
        100% { width: 340px; height: 340px; opacity: 0; }
    }

    /* 覚醒演出：カウントダウンテキスト */
    #kk-countdown {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 120px; font-weight: 900; color: #fff; z-index: 10;
        pointer-events: none;
        text-shadow: 0 0 40px currentColor;
    }
    .kk-countdown-anim { animation: kk-count-pop 0.6s cubic-bezier(0.2, 1.4, 0.2, 1) forwards; }
    @keyframes kk-count-pop {
        0%   { transform: translate(-50%,-50%) scale(2.5); opacity: 1; }
        70%  { transform: translate(-50%,-50%) scale(0.9); opacity: 0.9; }
        100% { transform: translate(-50%,-50%) scale(1);   opacity: 0; }
    }
    /* 拡大する輪 */
    .kk-ring {
        position: absolute; top: 50%; left: 50%; border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: kk-ring-out 1.6s ease-out infinite;
        pointer-events: none;
    }
    .kk-ring.lr { border: 2px solid rgba(255, 80, 255, 0.7); }
    .kk-ring.ur { border: 2px solid rgba(255, 100, 0, 0.7); }
    .kk-ring:nth-child(2) { animation-delay: 0.53s; }
    .kk-ring:nth-child(3) { animation-delay: 1.06s; }
    @keyframes kk-ring-out {
        0%   { width: 80px;  height: 80px;  opacity: 1; }
        100% { width: 280px; height: 280px; opacity: 0; }
    }

    /* テキスト */
    .kk-rarity {
        display: inline-block; font-size: 15px; font-weight: 900;
        letter-spacing: 5px; padding: 4px 20px; border-radius: 20px; margin-bottom: 10px;
    }
    .kk-rarity.lr {
        background: linear-gradient(90deg, #7700bb, #ff00ff, #7700bb);
        background-size: 200%; color: #fff; box-shadow: 0 0 18px #ff00ff;
        animation: kk-shimmer 1.2s linear infinite;
    }
    .kk-rarity.ur {
        background: linear-gradient(90deg, #880000, #ff3300, #ff7700, #ff3300, #880000);
        background-size: 200%; color: #fff; box-shadow: 0 0 18px #ff3300;
        animation: kk-shimmer 1.2s linear infinite;
    }
    @keyframes kk-shimmer { to { background-position: 200% 0; } }

    .kk-name {
        font-size: 30px; font-weight: 900; color: #fff; letter-spacing: 3px;
        margin-bottom: 8px; text-shadow: 0 0 16px #fff, 0 0 40px rgba(200,100,255,0.8);
        animation: kk-name-glow 0.9s ease-in-out infinite alternate;
    }
    @keyframes kk-name-glow {
        from { text-shadow: 0 0 16px #fff, 0 0 32px rgba(200,100,255,0.6); }
        to   { text-shadow: 0 0 30px #fff, 0 0 70px rgba(100,200,255,0.9), 0 0 110px rgba(255,0,255,0.4); }
    }
    .kk-catch {
        font-size: 12px; font-style: italic; margin-bottom: 24px;
        min-height: 18px;
        animation: kk-fade-up 0.6s 0.7s both;
    }
    .kk-catch.lr { color: #ffbbff; text-shadow: 0 0 6px #ff00ff; }
    .kk-catch.ur { color: #ffcc88; text-shadow: 0 0 6px #ff6600; }
    @keyframes kk-fade-up {
        from { opacity: 0; transform: translateY(10px); }
        to   { opacity: 1; transform: translateY(0); }
    }
    .kk-btn {
        font-size: 15px; font-weight: bold; padding: 13px 44px;
        border: none; border-radius: 30px; cursor: pointer; letter-spacing: 2px;
        background: linear-gradient(135deg, #ffd700, #ff8c00);
        color: #000; box-shadow: 0 0 22px rgba(255, 180, 0, 0.6);
        animation: kk-fade-up 0.5s 1.1s both, kk-btn-glow 1.2s 1.6s ease-in-out infinite alternate;
    }
    @keyframes kk-btn-glow {
        from { box-shadow: 0 0 16px rgba(255,180,0,0.5); }
        to   { box-shadow: 0 0 36px rgba(255,180,0,0.9), 0 0 70px rgba(255,80,0,0.4); }
    }

    /* ========== 絶対覇者確定演出 ========== */
    #hasha-overlay {
        display: none; position: fixed; inset: 0; z-index: 9850;
        background: #000; justify-content: center; align-items: center;
        flex-direction: column; overflow: hidden;
    }
    #hasha-overlay.active { display: flex; }
    #hasha-bg {
        position: absolute; inset: 0;
        background: radial-gradient(ellipse at center, #1a0000 0%, #000 70%);
        animation: hasha-bg-pulse 0.5s ease-in-out infinite alternate;
    }
    @keyframes hasha-bg-pulse {
        from { background: radial-gradient(ellipse at center, #1a0000 0%, #000 70%); }
        to   { background: radial-gradient(ellipse at center, #2a0010 0%, #050000 70%); }
    }
    #hasha-rays { position: absolute; inset: 0; pointer-events: none; }
    #hasha-rays::before {
        content: ''; position: absolute;
        width: 300vmax; height: 300vmax; top: 50%; left: 50%;
        background: conic-gradient(
            transparent 0deg,   rgba(255,0,80,0.12)  5deg,  transparent 10deg,
            transparent 18deg,  rgba(255,100,0,0.08) 23deg, transparent 28deg,
            transparent 45deg,  rgba(255,0,80,0.10)  50deg, transparent 55deg,
            transparent 90deg,  rgba(255,100,0,0.10) 95deg, transparent 100deg,
            transparent 135deg, rgba(255,0,80,0.12)  140deg,transparent 145deg,
            transparent 180deg, rgba(255,100,0,0.08) 185deg,transparent 190deg,
            transparent 225deg, rgba(255,0,80,0.10)  230deg,transparent 235deg,
            transparent 270deg, rgba(255,100,0,0.10) 275deg,transparent 280deg
        );
        transform: translate(-50%,-50%);
        animation: kk-spin 3s linear infinite;
    }
    #hasha-canvas { position: absolute; inset: 0; pointer-events: none; }
    #hasha-countdown {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        font-size: 130px; font-weight: 900; z-index: 10; pointer-events: none;
        color: #ff2200; text-shadow: 0 0 60px #ff0000, 0 0 120px #ff4400;
    }
    .hasha-countdown-anim { animation: hasha-count-pop 0.65s cubic-bezier(0.2, 1.4, 0.2, 1) forwards; }
    @keyframes hasha-count-pop {
        0%   { transform: translate(-50%,-50%) scale(3); opacity: 1; }
        60%  { transform: translate(-50%,-50%) scale(0.85); opacity: 0.9; }
        100% { transform: translate(-50%,-50%) scale(1); opacity: 0; }
    }
    #hasha-content {
        position: relative; z-index: 5; text-align: center; padding: 28px 24px;
        opacity: 0;
    }
    #hasha-content.visible {
        animation: hasha-content-in 0.9s cubic-bezier(0.1, 1.5, 0.3, 1) forwards;
        opacity: 1;
    }
    @keyframes hasha-content-in {
        from { transform: scale(0.05) rotate(15deg); opacity: 0; filter: blur(12px); }
        to   { transform: scale(1)    rotate(0deg);  opacity: 1; filter: blur(0); }
    }
    /* 覇者演出：キャラ選択カード */
    .hasha-card {
        background: linear-gradient(160deg, #1a0008, #300010);
        border: 2px solid rgba(255,80,0,0.5);
        border-radius: 12px; padding: 10px 6px; cursor: pointer;
        text-align: center; transition: 0.2s;
        position: relative; overflow: hidden;
        animation: hasha-card-in 0.5s cubic-bezier(0.2, 1.4, 0.2, 1) both;
    }
    .hasha-card:hover { border-color: #ff4400; transform: scale(1.08); box-shadow: 0 0 20px rgba(255,80,0,0.7); }
    .hasha-card:hover::after { content:''; position:absolute; inset:0; background:rgba(255,60,0,0.12); border-radius:10px; }
    .hasha-card-icon { font-size: 36px; display: block; margin-bottom: 4px; filter: drop-shadow(0 0 8px rgba(255,100,0,0.8)); }
    .hasha-card-rarity { font-size: 9px; font-weight: 900; letter-spacing: 2px; margin-bottom: 3px; }
    .hasha-card-rarity.ur { color: #ff4444; text-shadow: 0 0 8px #ff2200; }
    .hasha-card-rarity.lr { color: #ff88ff; text-shadow: 0 0 8px #ff00ff; }
    .hasha-card-name { font-size: 8px; color: #ffcc99; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    @keyframes hasha-card-in {
        from { transform: scale(0) rotate(-10deg); opacity: 0; }
        to   { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    #hasha-label {
        font-size: 13px; letter-spacing: 7px; font-weight: 900; margin-bottom: 18px;
        color: #ff6644; text-shadow: 0 0 16px #ff2200, 0 0 32px #ff4400;
        text-transform: uppercase;
        animation: hasha-label-blink 0.5s ease-in-out infinite alternate;
    }
    @keyframes hasha-label-blink {
        from { opacity: 0.8; }
        to   { opacity: 1; filter: brightness(1.5); }
    }
    #hasha-icon-wrap { position: relative; display: inline-block; margin-bottom: 20px; }
    #hasha-icon {
        font-size: 110px; display: block; position: relative; z-index: 2;
        animation: hasha-icon-pulse 0.4s ease-in-out infinite alternate;
    }
    @keyframes hasha-icon-pulse {
        from { transform: scale(1) rotate(-2deg);
               filter: drop-shadow(0 0 30px rgba(255,50,0,0.9)); }
        to   { transform: scale(1.15) rotate(2deg);
               filter: drop-shadow(0 0 60px rgba(255,0,0,1)) drop-shadow(0 0 100px rgba(255,100,0,0.8)); }
    }
    .hasha-ring {
        position: absolute; top: 50%; left: 50%; border-radius: 50%;
        transform: translate(-50%, -50%); pointer-events: none;
        animation: hasha-ring-out 1.4s ease-out infinite;
    }
    .hasha-ring:nth-child(1) { border: 3px solid rgba(255,50,0,0.8); }
    .hasha-ring:nth-child(2) { border: 2px solid rgba(255,150,0,0.6); animation-delay: 0.47s; }
    .hasha-ring:nth-child(3) { border: 2px solid rgba(255,0,50,0.5); animation-delay: 0.93s; }
    @keyframes hasha-ring-out {
        0%   { width: 90px;  height: 90px;  opacity: 1; }
        100% { width: 320px; height: 320px; opacity: 0; }
    }
    #hasha-title-badge {
        font-size: 11px; letter-spacing: 5px; color: #ff8866; text-transform: uppercase;
        margin-bottom: 10px; display: block; text-shadow: 0 0 12px #ff2200;
    }
    #hasha-name {
        font-size: 32px; font-weight: 900; color: #fff; letter-spacing: 3px; margin-bottom: 8px;
        text-shadow: 0 0 20px #fff, 0 0 50px rgba(255,100,0,0.9);
        animation: hasha-name-glow 0.8s ease-in-out infinite alternate;
    }
    @keyframes hasha-name-glow {
        from { text-shadow: 0 0 16px #fff, 0 0 36px rgba(255,80,0,0.7); }
        to   { text-shadow: 0 0 36px #fff, 0 0 80px rgba(255,200,0,0.9), 0 0 120px rgba(255,50,0,0.5); }
    }
    #hasha-rarity-badge {
        display: inline-block; font-size: 14px; font-weight: 900;
        letter-spacing: 4px; padding: 5px 22px; border-radius: 20px; margin-bottom: 10px;
        background: linear-gradient(90deg, #880000, #ff2200, #ff8800, #ff2200, #880000);
        background-size: 200%; color: #fff; box-shadow: 0 0 20px #ff2200;
        animation: kk-shimmer 1.0s linear infinite;
    }
    #hasha-catch {
        font-size: 12px; font-style: italic; margin-bottom: 28px;
        min-height: 18px; color: #ffcc88; text-shadow: 0 0 6px #ff6600;
        animation: kk-fade-up 0.6s 0.7s both;
    }
    #hasha-sub {
        font-size: 10px; letter-spacing: 4px; color: rgba(255,180,100,0.7);
        margin-bottom: 24px; display: block; text-transform: uppercase;
        animation: kk-fade-up 0.6s 0.5s both;
    }
    #hasha-btn {
        font-size: 15px; font-weight: bold; padding: 13px 44px;
        border: none; border-radius: 30px; cursor: pointer; letter-spacing: 2px;
        background: linear-gradient(135deg, #ff2200, #ff8800);
        color: #fff; box-shadow: 0 0 22px rgba(255,80,0,0.7);
        animation: kk-fade-up 0.5s 1.2s both, hasha-btn-glow 1.2s 1.7s ease-in-out infinite alternate;
    }
    @keyframes hasha-btn-glow {
        from { box-shadow: 0 0 16px rgba(255,80,0,0.6); }
        to   { box-shadow: 0 0 40px rgba(255,80,0,1), 0 0 80px rgba(255,200,0,0.5); }
    }

    /* ========== 塔完全制覇演出 ========== */
    #towerClearOverlay { display:none; position:fixed; inset:0; z-index:9200; justify-content:center; align-items:center; flex-direction:column; background:radial-gradient(ellipse at center, rgba(0,0,40,0.98) 0%, rgba(0,0,0,0.99) 100%); }
    #towerClearOverlay.active { display:flex; }
    #towerClearCanvas { position:absolute; inset:0; pointer-events:none; z-index:1; }
    #towerClearContent { position:relative; z-index:3; text-align:center; padding:40px 30px; animation:tower-clear-in 1.2s cubic-bezier(0.1,1.5,0.3,1) both; }
    @keyframes tower-clear-in { from { transform:scale(0.1) rotate(-20deg); opacity:0; filter:blur(20px); } to { transform:scale(1) rotate(0deg); opacity:1; filter:blur(0); } }
    #towerClearBadge { font-size:14px; letter-spacing:6px; color:#ffd700; text-transform:uppercase; margin-bottom:16px; animation:badge-pulse 1s infinite alternate; }
    #towerClearIcon { font-size:120px; display:block; margin-bottom:20px; animation:tower-icon-float 1.5s ease-in-out infinite alternate; filter:drop-shadow(0 0 30px #ffd700); }
    @keyframes tower-icon-float { from{transform:translateY(0) scale(1);} to{transform:translateY(-15px) scale(1.1); filter:drop-shadow(0 0 60px #fff) drop-shadow(0 0 100px #ffd700);} }
    #towerClearTitle { font-size:52px; font-weight:900; letter-spacing:6px; color:#ffd700; text-shadow:0 0 30px #ffd700, 0 0 60px #ff8800, 0 0 100px #ff4400; margin-bottom:12px; animation:tower-title-glow 0.8s ease-in-out infinite alternate; display:block; }
    @keyframes tower-title-glow { from{filter:brightness(1);} to{filter:brightness(1.4) drop-shadow(0 0 20px #ffd700);} }
    #towerClearSub { font-size:18px; letter-spacing:4px; color:#ffe066; margin-bottom:8px; display:block; }
    #towerClearMessage { font-size:13px; color:rgba(255,220,100,0.85); margin-bottom:30px; display:block; letter-spacing:2px; }
    #towerClearReward { font-size:24px; font-weight:bold; color:#00ffcc; margin-bottom:32px; display:block; text-shadow:0 0 20px #00ffcc; }
    #towerClearNewTitle { font-size:16px; font-weight:bold; color:#ff88ff; margin-bottom:16px; display:block; background:rgba(0,0,0,0.5); border:1px solid #ff88ff; border-radius:12px; padding:10px 20px; display:inline-block; text-shadow:0 0 12px #ff88ff; animation:badge-pulse 1.2s infinite alternate; }
    #towerClearBtn { font-size:18px; font-weight:bold; padding:16px 60px; border:none; border-radius:30px; cursor:pointer; letter-spacing:3px; background:linear-gradient(135deg,#ffd700,#ff8c00); color:#000; box-shadow:0 0 30px rgba(255,180,0,0.7); animation:tower-btn-glow 1.2s ease-in-out infinite alternate; }
    @keyframes tower-btn-glow { from{box-shadow:0 0 20px rgba(255,180,0,0.6);} to{box-shadow:0 0 50px rgba(255,180,0,1), 0 0 90px rgba(255,80,0,0.5);} }
    #towerClearRays { position:absolute; inset:0; pointer-events:none; z-index:0; }
    #towerClearRays::before { content:''; position:absolute; width:300vmax; height:300vmax; top:50%; left:50%; transform:translate(-50%,-50%); background:conic-gradient(transparent 0deg, rgba(255,215,0,0.08) 6deg, transparent 12deg, transparent 18deg, rgba(255,150,0,0.06) 24deg, transparent 30deg); animation:kk-spin 4s linear infinite; }

    /* ========== 称号システム ========== */
    #titleModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); backdrop-filter:blur(12px); z-index:7000; justify-content:center; align-items:center; }
    .title-modal-box { background:#0a0a1a; border:2px solid #aa66ff; border-radius:20px; padding:24px 20px; width:92%; max-width:460px; max-height:88vh; overflow-y:auto; color:#fff; box-sizing:border-box; }
    .title-modal-header { font-size:20px; font-weight:900; text-align:center; color:#cc88ff; letter-spacing:3px; margin-bottom:18px; text-shadow:0 0 12px #8800ff; }
    .title-active-display { text-align:center; margin-bottom:16px; background:rgba(180,0,255,0.1); border:1px solid rgba(180,0,255,0.4); border-radius:12px; padding:12px; }
    .title-active-label { font-size:10px; color:#aa66ff; letter-spacing:2px; }
    .title-active-name { font-size:22px; font-weight:900; color:#ff88ff; margin-top:4px; text-shadow:0 0 12px #ff00ff; }
    .title-list { display:flex; flex-direction:column; gap:8px; }
    .title-item { background:#111; border:1.5px solid #333; border-radius:10px; padding:10px 14px; display:flex; align-items:center; gap:10px; cursor:pointer; transition:0.2s; }
    .title-item:hover { background:#1a1a2e; border-color:#aa66ff; }
    .title-item.active-title { background:#1a0030; border-color:#ff00ff; box-shadow:0 0 12px rgba(255,0,255,0.3); }
    .title-item.locked { opacity:0.45; cursor:default; filter:grayscale(1); }
    .title-icon { font-size:26px; flex-shrink:0; }
    .title-info { flex:1; }
    .title-name { font-size:14px; font-weight:bold; color:#fff; }
    .title-item.active-title .title-name { color:#ff88ff; }
    .title-cond { font-size:10px; color:#888; margin-top:2px; }
    .title-set-btn { font-size:10px; padding:4px 10px; border:1px solid #aa66ff; border-radius:6px; background:transparent; color:#aa66ff; cursor:pointer; white-space:nowrap; }
    .title-set-btn:hover { background:#aa66ff22; }
    .title-set-btn.is-active { background:#aa66ff; color:#000; }
    .title-unlock-badge { font-size:9px; background:linear-gradient(135deg,#ff00ff,#8800ff); color:#fff; padding:2px 6px; border-radius:4px; margin-left:6px; }
    .title-close-btn { width:100%; padding:12px; margin-top:16px; border:none; border-radius:10px; background:#333; color:#fff; font-size:15px; font-weight:bold; cursor:pointer; }
    /* 称号獲得通知 */
    #titleToast { display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:9500; background:linear-gradient(135deg,#1a0030,#2a0050); border:2px solid #ff00ff; border-radius:14px; padding:12px 24px; text-align:center; box-shadow:0 0 30px rgba(255,0,255,0.5); animation:title-toast-in 0.5s cubic-bezier(0.2,1.5,0.3,1); min-width:220px; }
    @keyframes title-toast-in { from{transform:translateX(-50%) scale(0.3) translateY(-20px); opacity:0;} to{transform:translateX(-50%) scale(1) translateY(0); opacity:1;} }
    #titleToastLabel { font-size:10px; color:#aa66ff; letter-spacing:3px; }
    #titleToastName { font-size:18px; font-weight:900; color:#ff88ff; text-shadow:0 0 10px #ff00ff; }
    /* ユーザーステータスバーの称号表示 */
    .user-title-badge { font-size:11px; font-weight:bold; letter-spacing:2px; margin-top:2px; }

    /* ========== 開発者モード ========== */
    #devBadge { display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); background:linear-gradient(90deg,#ff0080,#ff6600,#ffd700); color:#000; font-size:11px; font-weight:900; padding:4px 16px; border-radius:20px; z-index:9999; letter-spacing:2px; pointer-events:none; box-shadow:0 0 16px #ff0080; animation:badge-pulse 1s infinite alternate; }
    #devPanel { display:none; position:fixed; bottom:0; left:0; right:0; background:rgba(10,0,20,0.97); border-top:2px solid #ff0080; z-index:8500; padding:10px 12px; box-sizing:border-box; }
    #devPanel.open { display:block; }
    .dev-panel-inner { max-width:500px; margin:0 auto; }
    .dev-panel-title { color:#ff0080; font-size:13px; font-weight:900; letter-spacing:2px; margin-bottom:8px; display:flex; align-items:center; justify-content:space-between; }
    .dev-tabs { display:flex; gap:6px; margin-bottom:10px; }
    .dev-tab { flex:1; padding:7px 4px; border:none; border-radius:8px 8px 0 0; font-size:11px; font-weight:bold; cursor:pointer; color:#aaa; background:#1a1a1a; border-bottom:2px solid #333; }
    .dev-tab.active { color:#ff0080; background:#220010; border-bottom:2px solid #ff0080; }
    .dev-tab-content { display:none; }
    .dev-tab-content.active { display:block; }
    .dev-char-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(72px,1fr)); gap:6px; max-height:160px; overflow-y:auto; padding:4px 0; }
    .dev-char-btn { background:#1a1a1a; border:1px solid #444; border-radius:8px; padding:6px 4px; font-size:10px; color:#fff; cursor:pointer; text-align:center; transition:0.15s; }
    .dev-char-btn:hover { border-color:#ff0080; background:#2a0018; }
    .dev-char-btn .dev-icon { font-size:22px; display:block; }
    .dev-char-btn .dev-rarity { font-size:9px; font-weight:bold; }
    .dev-char-btn .dev-name { font-size:8px; color:#aaa; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .dev-演出-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .dev-演出-btn { padding:10px; border:none; border-radius:10px; font-size:13px; font-weight:bold; cursor:pointer; }
    .dev-lb-area { padding:4px 0; }
    .dev-lb-select { width:100%; background:#1a1a1a; color:#fff; border:1px solid #444; border-radius:8px; padding:8px; font-size:12px; margin-bottom:8px; }
    .dev-lb-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .dev-lb-num { background:#1a1a1a; color:#fff; border:1px solid #444; border-radius:8px; padding:6px 10px; font-size:13px; width:60px; text-align:center; }
    .dev-lb-btn { padding:8px 16px; border:none; border-radius:8px; font-size:13px; font-weight:bold; cursor:pointer; background:#4a0040; color:#ff88ff; border:1px solid #ff00ff; }
    .dev-lb-btn:hover { background:#7a0060; }
    .dev-toggle-btn { position:fixed; bottom:16px; right:16px; z-index:8600; background:linear-gradient(135deg,#ff0080,#4b0082); border:none; border-radius:50%; width:48px; height:48px; font-size:22px; cursor:pointer; box-shadow:0 0 16px #ff0080; display:none; color:#fff; }

    /* ========== 排出率モーダル ========== */
    #rateModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); backdrop-filter:blur(10px); z-index:6000; justify-content:center; align-items:center; }
    .rate-modal-content { background:#111; border-radius:18px; padding:20px; width:90%; max-width:420px; max-height:85vh; overflow-y:auto; border:2px solid #444; color:#fff; box-sizing:border-box; }
    .rate-modal-title { font-size:18px; font-weight:900; text-align:center; margin-bottom:14px; letter-spacing:2px; }
    .rate-rarity-block { margin-bottom:14px; border-radius:10px; overflow:hidden; border:1px solid #333; }
    .rate-rarity-header { padding:8px 14px; font-weight:bold; font-size:13px; display:flex; justify-content:space-between; align-items:center; }
    .rate-char-row { display:flex; justify-content:space-between; align-items:center; padding:5px 14px; font-size:12px; border-top:1px solid #222; background:#1a1a1a; }
    .rate-char-row.pickup-row { background:#1a1208; }
    .rate-char-name { display:flex; align-items:center; gap:6px; }
    .rate-pu-badge { background:#ffd700; color:#000; font-size:9px; font-weight:bold; padding:1px 5px; border-radius:3px; }
    .rate-pct { color:#00ffcc; font-weight:bold; font-size:12px; }
    .rate-close-btn { width:100%; padding:12px; margin-top:14px; border:none; border-radius:10px; background:#444; color:#fff; font-size:15px; font-weight:bold; cursor:pointer; }
    .rate-close-btn:hover { background:#555; }
    .rate-note { font-size:10px; color:#888; text-align:center; margin-bottom:10px; }
    /* ========== PVP スタイル ========== */
    /* バトルモード選択モーダル */
    #battleModeModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.88); backdrop-filter:blur(8px); z-index:6200; justify-content:center; align-items:center; }
    .bm-content { background:#0d0d1a; border:2px solid #555; border-radius:20px; padding:30px 24px; width:88%; max-width:380px; text-align:center; }
    .bm-title { font-size:22px; font-weight:900; color:#fff; margin-bottom:6px; letter-spacing:2px; }
    .bm-subtitle { font-size:12px; color:#888; margin-bottom:24px; }
    .bm-btn { width:100%; padding:18px; border:none; border-radius:14px; font-size:16px; font-weight:bold; cursor:pointer; margin-bottom:12px; transition:0.2s; letter-spacing:1px; }
    .bm-btn:active { transform:scale(0.97); }
    .bm-btn-tower { background:linear-gradient(135deg,#4b0082,#8e44ad); color:#fff; box-shadow:0 4px 18px rgba(142,68,173,0.45); }
    .bm-btn-pvp { background:linear-gradient(135deg,#003388,#0066cc); color:#fff; box-shadow:0 4px 18px rgba(0,102,204,0.45); }
    .bm-btn-cancel { background:#222; color:#888; font-size:13px; padding:12px; }

    /* PVP 編成・ID設定モーダル */
    #pvpSetupModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.93); backdrop-filter:blur(10px); z-index:6500; justify-content:center; align-items:center; }
    #pvpBattleSetupModal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.93); backdrop-filter:blur(10px); z-index:6500; justify-content:center; align-items:center; }
    .pvp-modal-box { background:#080818; border:2px solid #0066cc; border-radius:20px; padding:20px 18px; width:92%; max-width:460px; max-height:90vh; overflow-y:auto; color:#fff; box-sizing:border-box; }
    .pvp-modal-title { font-size:20px; font-weight:900; text-align:center; color:#00aaff; letter-spacing:3px; margin-bottom:16px; text-shadow:0 0 12px #00aaff55; }
    .pvp-section { background:rgba(0,100,200,0.07); border:1px solid rgba(0,150,255,0.25); border-radius:12px; padding:13px 12px; margin-bottom:12px; }
    .pvp-section-label { font-size:10px; color:#55aaff; font-weight:bold; letter-spacing:2px; margin-bottom:9px; text-transform:uppercase; }
    .pvp-party-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-bottom:10px; }
    .pvp-slot { aspect-ratio:2/3; background:rgba(0,100,200,0.1); border:1.5px dashed rgba(0,150,255,0.35); border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center; font-size:8px; cursor:pointer; position:relative; transition:0.2s; color:#888; }
    .pvp-slot:hover { border-color:#00aaff; background:rgba(0,150,255,0.18); color:#fff; }
    .pvp-slot.occupied { border-style:solid; border-color:#0088dd; background:#050e1a; }
    .pvp-slot-icon { font-size:24px; line-height:1; }
    .pvp-slot-name { font-size:6.5px; text-align:center; color:#99ccff; margin-top:2px; overflow:hidden; max-width:100%; }
    .pvp-slot-lb { font-size:9px; color:#00aaff; font-weight:bold; }
    .pvp-pw-box { background:#000; border:1px solid #0066cc; border-radius:8px; padding:10px 12px; font-family:monospace; font-size:11px; color:#00ffcc; word-break:break-all; margin:8px 0; min-height:36px; cursor:pointer; transition:0.2s; }
    .pvp-pw-box:hover { background:#001122; border-color:#00aaff; }
    .pvp-input { width:100%; padding:10px; background:#0a0a1a; border:1px solid rgba(0,150,255,0.3); border-radius:8px; color:#fff; font-size:13px; box-sizing:border-box; margin-bottom:8px; outline:none; }
    .pvp-input:focus { border-color:#00aaff; }
    .pvp-btn { width:100%; padding:13px; border:none; border-radius:10px; font-size:14px; font-weight:bold; cursor:pointer; margin-top:6px; letter-spacing:1px; transition:0.2s; }
    .pvp-btn:active { transform:scale(0.97); }
    .pvp-btn-primary { background:linear-gradient(135deg,#003399,#0055cc); color:#fff; box-shadow:0 0 16px rgba(0,100,255,0.35); }
    .pvp-btn-green { background:linear-gradient(135deg,#004400,#007722); color:#00ffcc; }
    .pvp-btn-cancel { background:#1a1a1a; color:#888; }
    .pvp-opp-box { background:rgba(255,80,0,0.07); border:1px solid rgba(255,100,0,0.3); border-radius:12px; padding:12px; margin-bottom:12px; }
    .pvp-opp-name { font-size:16px; font-weight:900; color:#ff7733; }
    .pvp-opp-floor { font-size:11px; color:#ffaa66; margin:3px 0 8px; }
    .pvp-opp-party-row { display:flex; gap:6px; flex-wrap:wrap; }
    .pvp-opp-char { background:#120800; border:1px solid rgba(255,100,0,0.3); border-radius:8px; padding:6px 8px; text-align:center; min-width:42px; }
    .pvp-opp-char-icon { font-size:22px; display:block; }
    .pvp-opp-char-lb { font-size:9px; color:#ff7733; }

    /* PVPバトル画面 */
    #pvpView { display:none; width:100%; flex-direction:column; align-items:center; }
    .pvp-wrapper { width:100%; max-width:580px; padding:0 10px; box-sizing:border-box; }
    .pvp-header { display:flex; justify-content:space-between; align-items:center; background:#0d0d1a; padding:10px 16px; border-radius:10px; margin-bottom:14px; border:1px solid #222; }
    .pvp-field { background:linear-gradient(to bottom,#020216,#050a1a); border:2px solid #0055aa; border-radius:20px; padding:16px; position:relative; margin-bottom:14px; }
    .pvp-fighters { display:flex; align-items:flex-start; gap:8px; margin-bottom:12px; }
    .pvp-side { flex:1; min-width:0; }
    .pvp-side-label { font-size:10px; font-weight:bold; letter-spacing:1.5px; margin-bottom:5px; }
    .pvp-side.you .pvp-side-label { color:#00ffcc; }
    .pvp-side.opp .pvp-side-label { color:#ff7733; text-align:right; }
    .pvp-total-hp-wrap { margin-bottom:4px; }
    .pvp-total-hp-text { font-size:11px; font-weight:bold; }
    .pvp-total-hp-text.you { color:#00ffcc; }
    .pvp-total-hp-text.opp { color:#ff7733; text-align:right; display:block; }
    .pvp-hp-bar { width:100%; height:14px; background:#1a1a1a; border-radius:7px; overflow:visible; border:1px solid #333; position:relative; }
    .pvp-hp-fill { height:100%; border-radius:7px; transition:width 0.4s ease; position:relative; z-index:1; }
    .pvp-hp-fill.you { background:linear-gradient(to right,#00ffcc,#00cc88); }
    .pvp-hp-fill.opp { background:linear-gradient(to right,#ff4400,#ff8800); }
    .pvp-hp-shield-bar { position:absolute; top:0; left:0; height:100%; border-radius:7px; background:linear-gradient(to right,#0066cc,#00aaff); opacity:0.6; box-shadow:0 0 6px #00aaff inset; pointer-events:none; transition:width 0.4s ease; z-index:2; }
    .pvp-mini-party { display:grid; grid-template-columns:repeat(5,1fr); gap:4px; margin-top:6px; }
    .pvp-mini-slot { aspect-ratio:2/3; background:#0a0a1a; border:1px solid #222; border-radius:5px; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative; transition:0.2s; overflow:visible; }
    .pvp-mini-slot.dead { filter:grayscale(1) brightness(0.25); }
    .pvp-mini-slot.acting-you { box-shadow:0 0 10px #00ffcc; border-color:#00ffcc; transform:scale(1.08); }
    .pvp-mini-slot.acting-opp { box-shadow:0 0 10px #ff7733; border-color:#ff7733; transform:scale(1.08); }
    .pvp-mini-icon { font-size:15px; }
    .pvp-mini-hp-bar { width:75%; height:3px; background:#333; border-radius:2px; margin-top:2px; overflow:visible; position:relative; }
    .pvp-mini-hp-fill { height:100%; background:#00ffcc; border-radius:2px; transition:width 0.3s; position:relative; z-index:1; }
    .pvp-mini-hp-fill.opp { background:#ff6600; }
    .pvp-mini-shield-bar { position:absolute; top:-2px; left:0; height:7px; border-radius:2px; background:linear-gradient(to right,#00aaff,#44ddff); opacity:0.9; box-shadow:0 0 4px #00aaff; pointer-events:none; transition:width 0.3s; z-index:2; }
    .pvp-shield-text { font-size:7px; color:#44ddff; font-weight:bold; text-align:center; margin-top:3px; text-shadow:0 0 3px #00aaff; line-height:1; white-space:nowrap; }
    .pvp-vs-label { align-self:center; font-size:22px; font-weight:900; color:#ffd700; text-shadow:0 0 10px #ffd700; padding:0 4px; flex-shrink:0; }
    .pvp-log { background:rgba(0,0,0,0.8); border:1px solid rgba(0,100,255,0.2); height:88px; overflow-y:auto; padding:8px 10px; font-size:11px; color:#88ccff; font-family:monospace; border-radius:8px; margin-bottom:12px; }
    .pvp-turn-label { text-align:center; font-size:12px; color:#556; font-weight:bold; margin-bottom:8px; letter-spacing:2px; }

    /* PVP 一時停止オーバーレイ */
    #pvpPauseOverlay { display:none; position:fixed; inset:0; background:rgba(0,0,20,0.92); backdrop-filter:blur(8px); z-index:8500; flex-direction:column; align-items:center; justify-content:center; }
    #pvpPauseOverlay.active { display:flex; }

    /* PVPキャラ選択モーダル (既存selectorModal流用、識別用クラスのみ追加) */
    .pvp-selector-content { background:#050518; border:2px solid #0055aa; }

    /* キャラ一覧並べ替えボタン */
    .sort-bar { display:flex; gap:5px; flex-wrap:wrap; padding:4px 8px; background:#111; border-bottom:1px solid #333; margin-top:40px; flex-shrink:0; }
    .sort-btn { padding:4px 8px; border:1px solid #555; border-radius:6px; background:#222; color:#aaa; font-size:10px; cursor:pointer; white-space:nowrap; transition:0.2s; }
    .sort-btn:hover { border-color:#00aaff; color:#00aaff; }
    .sort-btn.active { background:#003366; border-color:#00aaff; color:#00ffcc; font-weight:bold; }

    /* PVP再戦ボタン */
    #pvpCheerBtn { display: none !important; }
    #pvpCheerBtn_DISABLED {
        display: none; width: 100%; padding: 14px; border: none; border-radius: 12px;
        font-size: 18px; font-weight: bold; cursor: pointer; margin-bottom: 8px;
        background: linear-gradient(135deg, #880088, #cc00cc, #880088);
        color: #fff; box-shadow: 0 0 20px rgba(200,0,200,0.5);
        letter-spacing: 2px; animation: cheer-btn-glow 1.2s ease-in-out infinite alternate;
    }
    @keyframes cheer-btn-glow {
        from { box-shadow: 0 0 15px rgba(200,0,200,0.5); }
        to   { box-shadow: 0 0 35px rgba(255,0,255,0.9), 0 0 60px rgba(200,0,200,0.4); }
    }
    #pvpCheerBtn:active { transform: scale(0.95); }
    #pvpRematchBtn {
        display: none; width: 100%; padding: 14px; border: none; border-radius: 12px;
        font-size: 15px; font-weight: bold; cursor: pointer; margin-bottom: 8px;
        background: linear-gradient(135deg, #004400, #00aa44); color: #fff;
        box-shadow: 0 0 16px rgba(0,200,80,0.4); letter-spacing: 1px;
    }
    #pvpRematchBtn:hover { filter: brightness(1.2); }
    /* PVP応援パーティクルキャンバス */
    #pvpCheerCanvas {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 8900;
    }

</style>
</head>
<body>

<div id="startScreen">
    <div class="title-deco">⚔️</div>
    <div class="title-logo">絵文字大戦</div>
    <div class="title-logo-sub">Emoji war</div>
    <div class="user-form">
        <div id="existingUserArea" style="display:none;">
            <p style="font-size:12px; color:#aaa;">保存済みのユーザー</p>
            <select id="userSelector" class="user-input" style="background:#333; color:white;"></select>
            <button class="btn" onclick="loginSelected()">選択して開始</button>
            <hr style="border:0; border-top:1px solid #444; margin:15px 0;">
        </div>
        <p style="font-size:12px; color:#aaa;">新規ユーザー登録</p>
        <input type="text" id="userNameInput" class="user-input" placeholder="名前を入力してください" maxlength="12">
        <button class="btn" id="startBtn" onclick="registerUser()">新しく始める</button>
    </div>
    <button class="btn btn-sub" onclick="openGameDescription()" style="background:rgba(0,100,200,0.3); border:1px solid #0088ff; margin-top:8px; font-size:13px; width:90%; cursor:pointer;">📖 ゲーム説明</button>
</div>

<!-- ゲーム説明モーダル -->
<div id="gameDescModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); backdrop-filter:blur(10px); z-index:9500; justify-content:center; align-items:flex-start; overflow-y:auto;">
    <div style="background:#0a0a1a; border:2px solid #0066cc; border-radius:20px; padding:24px 20px; width:92%; max-width:480px; color:#fff; margin:30px auto; box-sizing:border-box;">
        <div style="font-size:20px; font-weight:900; text-align:center; color:#00aaff; letter-spacing:2px; margin-bottom:16px;">📖 絵文字大戦 ゲーム説明</div>
        
        <div style="background:rgba(0,80,150,0.15); border:1px solid rgba(0,150,255,0.3); border-radius:12px; padding:14px; margin-bottom:12px;">
            <div style="font-size:13px; font-weight:bold; color:#00ffcc; margin-bottom:8px;">🎲 ガチャシステム</div>
            <div style="font-size:12px; color:#ccc; line-height:1.7;">
                💎 <b>聖晶石</b>を使って英傑（キャラクター）を召喚します。<br>
                10連召喚で一気に10体排出！<br>
                <b>200連天井</b>でUR/LRが確定します。<br>
                レアリティ：<span style="color:#ff0000;">UR</span> &gt; <span style="color:#ff00ff;">LR</span> &gt; <span style="color:#ffd700;">SSR</span> &gt; <span style="color:#00ffff;">SR</span> &gt; <span style="color:#cd7f32;">R</span><br>
                同じキャラを重ねると<b>LB（限界突破）</b>が進み、ステータスが上昇。最大LB10まで可能。
            </div>
        </div>

        <div style="background:rgba(80,0,100,0.15); border:1px solid rgba(150,0,200,0.3); border-radius:12px; padding:14px; margin-bottom:12px;">
            <div style="font-size:13px; font-weight:bold; color:#cc88ff; margin-bottom:8px;">🏰 魔王の塔</div>
            <div style="font-size:12px; color:#ccc; line-height:1.7;">
                全15階層のボスに挑む<b>タワーバトル</b>です。<br>
                英傑を最大5体編成してバトル開始！<br>
                各英傑は固有の<b>奥義（スキル）</b>を持ち、確率で発動します。<br>
                ⚠️ <b>敗北</b>すると出撃した英傑は一時的に使用不可になります。<br>
                ✅ 勝利すると💎聖晶石を獲得！階層が上がるほど多く獲得できます。<br>
                🔑 <b>英傑の号令</b>：使い切りの特殊コマンド。全英傑が奥義を必ず発動！
            </div>
        </div>

        <div style="background:rgba(0,80,0,0.15); border:1px solid rgba(0,200,100,0.3); border-radius:12px; padding:14px; margin-bottom:12px;">
            <div style="font-size:13px; font-weight:bold; color:#00ffcc; margin-bottom:8px;">⚔️ PVPバトル</div>
            <div style="font-size:12px; color:#ccc; line-height:1.7;">
                他のプレイヤーと<b>非同期対戦</b>できます！<br>
                <b>手順：</b><br>
                1️⃣ 設定ボタン ⚙️ から「PVP編成・ID確認」を開く<br>
                2️⃣ 英傑を5体選んで「IDを生成」→IDをコピーして相手に送る<br>
                3️⃣ 相手からIDをもらったら「バトルへ」→「PVPバトル」を選択<br>
                4️⃣ 相手のIDを入力して読み込み、自分の編成を選んで出撃！<br>
                試合は最大35ターンまで続き、勝敗がつかないときは<br>
                <b>残りHP合計</b>が多い方が勝利となります。
            </div>
        </div>

        <div style="background:rgba(100,60,0,0.15); border:1px solid rgba(200,150,0,0.3); border-radius:12px; padding:14px; margin-bottom:16px;">
            <div style="font-size:13px; font-weight:bold; color:#ffd700; margin-bottom:8px;">💡 攻略ヒント</div>
            <div style="font-size:12px; color:#ccc; line-height:1.7;">
                ・LBが高いほどステータスが大幅上昇。同キャラを重ねよう！<br>
                ・UR/LRキャラは強力な奥義を持つ。積極的に狙おう！<br>
                ・高層突破には回復役（天照など）やダメージ軽減役（ブリュンヒルデなど）がカギ！<br>
                ・高階層ほどボスが強力。LBを進めてから挑もう！<br>
                ・バトル中は一時停止ボタンで中断できます。
            </div>
        </div>

        <button onclick="closeGameDescription()" style="width:100%; padding:14px; border:none; border-radius:12px; background:linear-gradient(135deg,#0044aa,#0066cc); color:#fff; font-size:15px; font-weight:bold; cursor:pointer; letter-spacing:2px;">✔ 閉じる</button>
    </div>
</div>

<div id="flash"></div>

<!-- ========== 開発者モードUI ========== -->
<div id="devBadge">⚙ DEVELOPER MODE ⚙</div>

<button id="devToggleBtn" class="dev-toggle-btn" onclick="toggleDevPanel()" title="開発者パネル">🛠</button>

<div id="devPanel">
    <div class="dev-panel-inner">
        <div class="dev-panel-title">
            <span>🛠 開発者パネル</span>
            <button onclick="toggleDevPanel()" style="background:none;border:none;color:#ff0080;font-size:16px;cursor:pointer;">✕</button>
        </div>
        <div class="dev-tabs">
            <button class="dev-tab active" onclick="switchDevTab('chars', this)">キャラ取得</button>
            <button class="dev-tab" onclick="switchDevTab('演出', this)">確定演出</button>
            <button class="dev-tab" onclick="switchDevTab('lb', this)">凸操作</button>
        </div>
        <!-- キャラ取得タブ -->
        <div class="dev-tab-content active" id="devTab-chars">
            <div style="font-size:10px; color:#888; margin-bottom:6px;">クリックで即時取得（myBoxに追加）</div>
            <div class="dev-char-grid" id="devCharGrid"></div>
        </div>
        <!-- 確定演出タブ -->
        <div class="dev-tab-content" id="devTab-演出">
            <div style="font-size:10px; color:#888; margin-bottom:8px;">次のガチャで選択した演出が発動します</div>
            <div style="margin-bottom:8px;">
                <label style="font-size:10px; color:#aaa;">演出タイプ：</label>
                <select id="devEffectType" class="dev-lb-select" style="margin-bottom:6px;">
                    <option value="">演出なし（通常）</option>
                    <option value="kakusei_lr">💜 LRピックアップ確定（覚醒演出）</option>
                    <option value="kakusei_ur">🔴 URピックアップ確定（覚醒演出）</option>
                    <option value="lr_flash">✨ LR演出（フラッシュのみ）</option>
                    <option value="ur_flash">🔥 UR演出（フラッシュのみ）</option>
                    <option value="upgrade">⬆️ 全部開いてからレアキャラが高レアに変化</option>
                    <option value="fever">🎉 フィーバーモード</option>
                    <option value="hasha">👑 絶対覇者召喚（5体選択）</option>
                </select>
                <label style="font-size:10px; color:#aaa;">キャラ選択（オプション）：</label>
                <select id="devKakuseiChar" class="dev-lb-select">
                    <option value="">ランダム</option>
                </select>
            </div>
            <div style="font-size:11px; color:#00ffcc; margin-top:4px;" id="devEffectStatus">🎯 ガチャボタンを押すと設定した演出が発動します</div>
        </div>
        <!-- 凸操作タブ -->
        <div class="dev-tab-content" id="devTab-lb">
            <div style="font-size:10px; color:#888; margin-bottom:6px;">所持キャラの凸数を自由に変更</div>
            <select id="devLbChar" class="dev-lb-select" onchange="updateDevLbDisplay()">
                <option value="">所持キャラを選択...</option>
            </select>
            <div class="dev-lb-controls">
                <span style="font-size:12px; color:#aaa;">現在の凸:</span>
                <input type="number" id="devLbNum" class="dev-lb-num" min="0" max="10" value="0">
                <button class="dev-lb-btn" onclick="devSetLimitBreak()">✔ 適用</button>
                <button class="dev-lb-btn" style="background:#002244; color:#00ffcc; border-color:#00ffcc;" onclick="devSetLimitBreak(10)">MAX(10凸)</button>
            </div>
            <div id="devLbStatus" style="font-size:11px; color:#00ffcc; margin-top:6px;"></div>
        </div>
    </div>
</div>

<!-- ========== 排出率モーダル ========== -->
<div id="rateModal" onclick="closeRateModal()">
    <div class="rate-modal-content" onclick="event.stopPropagation()">
        <div class="rate-modal-title" id="rateModalTitle">📊 排出率</div>
        <div class="rate-note" id="rateModalNote">※ピックアップキャラは同レアリティの4倍の排出率</div>
        <div id="rateModalBody"></div>
        <button class="rate-close-btn" onclick="closeRateModal()">閉じる</button>
    </div>
</div>

<div id="gachaView" style="display: none; width: 100%; flex-direction: column; align-items: center;">
    
    <div id="settingsModal" onclick="closeSettings()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2 style="margin-top:0;">USER SETTINGS</h2>
            <div style="text-align:left; margin-bottom:20px;">
                <label>BGM音量:</label>
                <input type="range" min="0" max="1" step="0.1" value="0.3" onchange="updateVolume(this.value)" style="width:100%;">
            </div>
            <button class="btn btn-sub" onclick="resetUserData()" style="background:#c0392b;">データをリセット</button>
            <button class="btn btn-sub" onclick="logout()">ログアウト</button>
            <button class="btn" onclick="openPvpSetup()" style="background:linear-gradient(135deg,#003399,#0055cc); margin-top:8px;">⚔️ PVP編成・ID確認</button>
            <button class="btn" onclick="openTitleModal()" style="background:linear-gradient(135deg,#4b0082,#8e44ad); margin-top:8px;">🏅 称号確認・設定</button>
            <button class="btn" onclick="closeSettings()" style="background:#7f8c8d;">閉じる</button>
        </div>
    </div>

    <div id="detailModal" onclick="closeModal()">
        <div class="modal-content" id="modalContent" onclick="event.stopPropagation()">
            <div id="modalLimit" style="color:#00ffcc; font-weight:bold; letter-spacing: 2px; font-size: 14px; margin-bottom: 5px;"></div>
            <div id="modalRarity" style="font-size:28px; font-weight:900; text-shadow: 0 0 10px rgba(0,0,0,0.5);"></div>
            <div id="modalImg" style="font-size:100px; margin:15px; position:relative; display:inline-block;">
                <div id="modalIconRings"></div>
                <span id="modalIconEmoji"></span>
            </div>
            <div id="modalName" style="font-size:24px; font-weight:bold"></div>
            <div style="display:flex; justify-content: space-around; margin:15px 0; font-size:18px; font-weight: bold;">
                <span style="color:#ff4d4d;">HP <span id="modalHP"></span></span>
                <span style="color:#ffaa00;">ATK <span id="modalATK"></span></span>
            </div>
            <div class="skill-box">
                <div style="color:#00ffcc; font-weight:bold; font-size:13px; border-bottom: 1px solid #444; padding-bottom:3px; margin-bottom:5px;">SPECIAL SKILL</div>
                <div id="modalSkillName" style="font-size:16px; margin:5px 0; font-weight:bold;"></div>
                <div id="modalSkillDesc" style="font-size:12px; color:#ddd; line-height: 1.4;"></div>
            </div>
            <button class="btn btn-sub" onclick="closeModal()">CLOSE</button>
        </div>
    </div>

    <div class="game-container">
        <button id="settingsBtn" onclick="openSettings()">⚙️</button>
        <div class="status-bar">
            <div class="user-tag" id="activeUserNameGacha">Guest</div>
            💎 聖晶石: <span id="stoneCountGacha">0</span><br>
            <span class="pity-counter">天井まであと <span id="pityCount">200</span> 連 (UR/LR確定)</span>
            <div class="user-title-badge" id="statusBarTitle" style="color:#ff88ff; text-shadow:0 0 8px #ff00ff; display:none;"></div>
        </div>

        <!-- ガチャタブ -->
        <div class="gacha-tabs">
            <button class="gacha-tab tab-standard active-tab" onclick="switchGachaTab('standard', this)">⚖️ 通常召喚</button>
            <button class="gacha-tab tab-lr" onclick="switchGachaTab('lr', this)">💜 LRピックアップ</button>
            <button class="gacha-tab tab-ur" onclick="switchGachaTab('ur', this)">❤️ URピックアップ</button>
        </div>

        <!-- 通常バナー -->
        <div id="banner-standard" class="banner-large banner-standard" onclick="openRateModal('standard')" style="cursor:pointer;">
            <div class="banner-shine"></div>
            <div class="banner-deco-chars">
                <div class="banner-pickup-icon" id="std-icon1">⚔️</div>
                <div class="banner-pickup-icon" id="std-icon2">🛡️</div>
            </div>
            <div class="banner-info">
                <span class="banner-tag tag-standard">STANDARD GACHA</span>
                <div class="banner-title-text">究極英雄召喚</div>
                <div class="banner-pickup-name">全英傑まんべんなく排出！</div>
                <div class="banner-timer">🎯 200連天井 | UR 0.2% / LR 0.5%</div>
            </div>
        </div>

        <!-- LRピックアップバナー -->
        <div id="banner-lr" class="banner-large banner-lr" onclick="openRateModal('lr')" style="display:none; cursor:pointer;">
            <div class="banner-shine"></div>
            <div class="banner-deco-chars">
                <div class="banner-pickup-icon" id="lr-pickup-icon">💜</div>
            </div>
            <div class="banner-info">
                <span class="banner-tag tag-lr">LR PICKUP</span>
                <div class="banner-title-text" id="lr-banner-title">LR 覚醒召喚</div>
                <div class="banner-pickup-name">ピックアップ：<span id="lr-pickup-name">---</span></div>
                <div id="lr-pickup-catch" style="font-size:10px; color:#ffb3ff; margin-top:3px; font-style:italic; min-height:14px;"></div>
                <div class="banner-timer">⏰ 次の入れ替えまで <span class="timer-val" id="lr-timer">--:--:--</span></div>
            </div>
        </div>

        <!-- URピックアップバナー -->
        <div id="banner-ur" class="banner-large banner-ur" onclick="openRateModal('ur')" style="display:none; cursor:pointer;">
            <div class="banner-shine"></div>
            <div class="banner-deco-chars">
                <div class="banner-pickup-icon" id="ur-pickup-icon">🔴</div>
            </div>
            <div class="banner-info">
                <span class="banner-tag tag-ur">UR PICKUP</span>
                <div class="banner-title-text" id="ur-banner-title">UR 覚醒召喚</div>
                <div class="banner-pickup-name">ピックアップ：<span id="ur-pickup-name">---</span></div>
                <div id="ur-pickup-catch" style="font-size:10px; color:#ffb3b3; margin-top:3px; font-style:italic; min-height:14px;"></div>
                <div class="banner-timer">⏰ 次の入れ替えまで <span class="timer-val" id="ur-timer">--:--:--</span></div>
            </div>
        </div>

        <!-- フィーバー用バナー（演出用、通常は非表示） -->
        <div class="banner" id="mainBanner" style="display:none;">
            <h1 id="bannerTitle" style="margin:0; font-size:28px; color:#fff; text-shadow:0 0 15px var(--lr);">ULTIMATE FES</h1>
            <div id="bannerSub" style="font-size:11px; opacity:0.8;">200連で最高レア確定！</div>
        </div>

        <div class="result-grid" id="resultGrid"></div>
        <button class="btn" id="gachaBtn" onclick="playGacha(10)">10連召喚</button>
        <button class="btn btn-battle" onclick="openBattleModeSelect()">バトルへ</button>
    </div>

    <div class="box-container" id="collectionContainer"></div>
</div>

<!-- ========== バトルスキル演出オーバーレイ ========== -->
<div id="skillOverlay">
    <div id="skillOverlayBg"></div>
    <div id="skillOverlayLines"></div>
    <div id="skillOverlayText">
        <span id="skillOverlayCharIcon">⭐</span>
        <span class="skill-overlay-skill-name" id="skillOverlaySkillName">スキル名</span>
        <span class="skill-overlay-char-name"  id="skillOverlayCharName">キャラ名</span>
    </div>
</div>

<!-- ========== 覚醒確定演出オーバーレイ ========== -->
<div id="kakusei-overlay">
    <div class="kk-bg" id="kk-bg"></div>
    <div class="kk-rays"></div>
    <canvas id="kk-canvas"></canvas>
    <div id="kk-countdown"></div>
    <div class="kk-content">
        <div class="kk-label" id="kk-label">✦ 覚醒確定召喚 ✦</div>
        <div class="kk-icon-wrap">
            <div class="kk-aura-ring" id="kk-aura1"></div>
            <div class="kk-aura-ring" id="kk-aura2"></div>
            <div class="kk-aura-ring" id="kk-aura3"></div>
            <div class="kk-ring" id="kk-ring1"></div>
            <div class="kk-ring" id="kk-ring2"></div>
            <div class="kk-ring" id="kk-ring3"></div>
            <div class="kk-icon" id="kk-icon">⭐</div>
        </div>
        <div class="kk-rarity" id="kk-rarity">LR</div>
        <div class="kk-name" id="kk-name">---</div>
        <div class="kk-catch" id="kk-catch"></div>
        <button class="kk-btn" id="kk-btn" onclick="closeKakusei()">✦ 召喚結果を確認 ✦</button>
    </div>
</div>

<!-- ========== 絶対覇者確定演出オーバーレイ ========== -->
<div id="hasha-overlay">
    <div id="hasha-bg"></div>
    <div id="hasha-rays"></div>
    <canvas id="hasha-canvas"></canvas>
    <div id="hasha-countdown"></div>
    <div id="hasha-content">
        <div id="hasha-label">✦ 絶対召喚 ✦</div>
        <div id="hasha-sub-title" style="font-size:12px; color:rgba(255,180,100,0.85); letter-spacing:2px; margin-bottom:18px;">LR・URの中から1体を選択して入手せよ</div>
        <div id="hasha-select-grid" style="display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin-bottom:20px; max-width:420px;"></div>
        <span id="hasha-sub">— 共に歩む仲間を選べ —</span>
    </div>
</div>

<div id="battleView" style="display: none; width: 100%; flex-direction: column; align-items: center;">
    
    <div class="game-wrapper">
        <div class="header" style="position:relative; justify-content:space-between; align-items:center;">
            <div>
                <span id="activeUserNameBattle" style="color:var(--sr);">---</span>
                <br><small>💎 <span id="stoneCountBattle">0</span></small>
            </div>
            <button class="btn btn-nav" onclick="switchToGacha()">召喚へ戻る</button>
            <button id="battleSettingsBtn" onclick="openBattleSettings()" style="background:none; border:none; font-size:22px; cursor:pointer; color:#888; padding:4px; margin-left:5px;">⚙️</button>
        </div>

        <div id="battleSettingsModal" onclick="closeBattleSettings()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); backdrop-filter:blur(8px); z-index:5000; justify-content:center; align-items:center;">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width:300px;">
                <h2 style="margin-top:0;">バトル設定</h2>
                <div style="text-align:left; margin-bottom:20px;">
                    <label style="color:#00ffcc; font-weight:bold;">バトルスピード：<span id="battleSpeedLabel">x1.0</span></label>
                    <input type="range" min="1" max="5" step="1" value="2" oninput="updateBattleSpeed(this.value)" style="width:100%; margin-top:8px;">
                    <div style="display:flex; justify-content:space-between; font-size:11px; color:#888; margin-top:4px;">
                        <span>x0.5</span><span>x1.0</span><span>x2.0</span><span>x4.0</span><span>x8.0</span>
                    </div>
                </div>
                <div style="text-align:left; margin-bottom:20px;">
                    <label>BGM音量:</label>
                    <input type="range" min="0" max="1" step="0.1" value="0.3" onchange="updateVolume(this.value)" style="width:100%;">
                </div>
                <button class="btn" onclick="closeBattleSettings()" style="background:#7f8c8d;">閉じる</button>
            </div>
        </div>

        <div class="floor-display" id="floorTitle">第 1 階層</div>

        <div class="battle-field" id="battleField">
            <div class="boss-area">
                <div id="bossName" style="color:var(--ur); font-weight:bold; letter-spacing: 2px;">魔王：デウス・エクス・マキナ</div>
                <div class="boss-icon" id="bossIcon">👿</div>
                <div class="hp-bar-container">
                    <div id="bossHpBar" class="hp-bar-fill hp-boss"></div>
                </div>
                <div id="bossHpText" style="font-size:12px; margin-top:5px;">HP: -- / --</div>
            </div>
            <div id="battleLog" class="battle-log">パーティーを編成して、いざ魔王城へ。</div>
            <div class="player-area">
                <div class="party-grid" id="partyGrid">
                    <div class="unit-slot" onclick="openSelector(0)" id="slot-0">SELECT</div>
                    <div class="unit-slot" onclick="openSelector(1)" id="slot-1">SELECT</div>
                    <div class="unit-slot" onclick="openSelector(2)" id="slot-2">SELECT</div>
                    <div class="unit-slot" onclick="openSelector(3)" id="slot-3">SELECT</div>
                    <div class="unit-slot" onclick="openSelector(4)" id="slot-4">SELECT</div>
                </div>
            </div>
        </div>
        <div class="battle-action-row">
            <button id="attackBtn" class="btn btn-attack" onclick="executeBattle()" style="flex:3; margin-top:10px;">全軍、突撃ッ！</button>
            <button id="pauseBtn" class="btn btn-pause" onclick="togglePause()" style="display:none;">⏸ 一時停止</button>
        </div>
        <button id="orderBtn" class="btn btn-order" onclick="useHeroOrder()">📯 英傑の号令（残り1回）</button>
    </div>

    <!-- 一時停止オーバーレイ -->
    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-box" style="width:90%; max-width:460px; max-height:85vh; overflow-y:auto;">
            <div style="font-size:40px; margin-bottom:8px;">⏸</div>
            <div style="font-size:20px; font-weight:bold; color:#f39c12; margin-bottom:6px;">一時停止中</div>
            <button class="btn" onclick="togglePause()" style="background:linear-gradient(#27ae60,#1e8449); font-size:16px; max-width:180px; margin:0 auto 14px; display:block; padding:10px;">▶ 再開</button>
            <!-- ⚙️ 設定パネル（一時停止中に操作可能） -->
            <div style="background:#111; border:1px solid #444; border-radius:12px; padding:14px; margin-bottom:14px; text-align:left;">
                <div style="font-size:13px; font-weight:bold; color:#f39c12; margin-bottom:10px;">⚙️ バトル設定</div>
                <div style="margin-bottom:12px;">
                    <label style="color:#00ffcc; font-size:12px; font-weight:bold;">バトルスピード：<span id="pauseSpeedLabel">x1.0</span></label>
                    <input type="range" min="1" max="5" step="1" value="2" id="pauseSpeedSlider" oninput="updateBattleSpeedFromPause(this.value)" style="width:100%; margin-top:6px;">
                    <div style="display:flex; justify-content:space-between; font-size:10px; color:#666; margin-top:3px;">
                        <span>x0.5</span><span>x1.0</span><span>x2.0</span><span>x4.0</span><span>x8.0</span>
                    </div>
                </div>
                <div>
                    <label style="color:#aaa; font-size:12px;">BGM音量：</label>
                    <input type="range" min="0" max="1" step="0.1" value="0.3" id="pauseVolumeSlider" onchange="updateVolume(this.value)" style="width:100%; margin-top:6px;">
                </div>
            </div>
            <div style="font-size:12px; color:#aaa; margin-bottom:6px; text-align:left;">📜 これまでの戦いのログ</div>
            <div class="pause-log-area" id="pauseLogArea"></div>
        </div>
    </div>

    <div id="selectorModal">
        <div class="selector-content">
            <h3 style="margin:0; padding:10px 0; border-bottom:1px solid #333; position:absolute; top:15px; left:15px; right:15px; background:#1a1a1a; z-index:10; font-size:14px;">召喚英傑リスト</h3>
            <div class="sort-bar" id="selectorSortBar">
                <span style="font-size:10px;color:#666;align-self:center;">並替:</span>
                <button class="sort-btn active" onclick="setSelectorSort('rarity')" id="selectorSort_rarity">レアリティ</button>
                <button class="sort-btn" onclick="setSelectorSort('hp')" id="selectorSort_hp">HP</button>
                <button class="sort-btn" onclick="setSelectorSort('atk')" id="selectorSort_atk">ATK</button>
                <button class="sort-btn" onclick="setSelectorSort('dmg')" id="selectorSort_dmg">実質ダメ</button>
            </div>
            <div class="owned-list" id="ownedList"></div>
            <button class="btn btn-nav" style="margin-top:10px; width: 100%;" onclick="closeSelector()">閉じる</button>
        </div>
    </div>
</div>

<!-- ========== 英傑の号令演出オーバーレイ ========== -->
<div id="orderOverlay">
    <div id="orderOverlayBg"></div>
    <div id="orderOverlayLines"></div>
    <div id="orderOverlayText">
        <span id="orderOverlayIcon">📯</span>
        <span id="orderOverlayTitle">英傑の号令！</span>
        <span id="orderOverlaySubtitle">全英傑が奥義を解放する！</span>
    </div>
</div>

<!-- ========== ボススキル演出オーバーレイ ========== -->
<div id="bossSkillOverlay">
    <div id="bossSkillOverlayBg"></div>
    <div id="bossSkillOverlayLines"></div>
    <div id="bossSkillOverlayText">
        <span id="bossSkillOverlayIcon">👿</span>
        <span id="bossSkillOverlayTitle">スキル名</span>
        <span id="bossSkillOverlayMsg">説明</span>
    </div>
</div>

<!-- ========== 勝利・敗北演出オーバーレイ ========== -->
<div id="battleResultOverlay">
    <canvas id="battleResultCanvas"></canvas>
    <div id="battleResultRays"></div>
    <div id="battleResultContent">
        <span id="battleResultIcon">🏆</span>
        <span id="battleResultTitle">VICTORY</span>
        <span id="battleResultSub">階層クリア！</span>
        <span id="battleResultReward"></span>
        <div id="battleResultDamageList" style="display:none; background:rgba(0,0,0,0.5); border:1px solid #444; border-radius:10px; padding:10px 14px; margin-bottom:16px; width:100%; box-sizing:border-box; max-height:180px; overflow-y:auto;"></div>
        <button id="battleResultBtn" onclick="closeBattleResult()">続ける</button>
        <br>
        <button id="battleResultRestartBtn" onclick="restartTowerFromBeginning()">🔄 最初からやり直す（1層〜）</button>
    </div>
</div>

<script>
    // ==========================================
    // 共通データ・システム管理
    // ==========================================
    let currentUser = "";
    let userData = { stones: 0, totalDraws: 0, myBox: {}, bannedUnits: [] };
    const pityThreshold = 200;

    // --- バトル用の変数を上部で定義 ---
    let party = [null, null, null, null, null];
    let selectedSlot = -1;
    let isBattleRunning = false;
    let isPaused = false;          // 一時停止フラグ
    let heroOrderUsed = false;     // 号令使用済みフラグ（1戦1回）
    let forceSkillNextTurn = false; // 号令：次ターン全員スキル強制フラグ
    let currentFloor = 1;
    let battleSpeedMultiplier = 1.0; // バトルスピード倍率
    let bossMaxHp = 15000;
    let bossHp = 15000;
    let bossAtk = 100;

    // ========== ガチャタイプ管理 ==========
    let currentGachaType = 'standard'; // 'standard' | 'lr' | 'ur'
    // 開発者モード：次のガチャで強制発動する演出
    let devForcedEffect = ''; // 'kakusei_lr' | 'kakusei_ur' | 'lr_flash' | 'ur_flash' | 'upgrade' | 'fever' | ''

    // ========== キャラ強み一言キャッチコピー ==========
    const catchCopyMap = {
        // UR
        "終焉の龍神ラグナロク":  "ATK5500の極限火力で単独無双！",
        "秩序の女神アストレア":   "攻撃しながら全体回復！攻守完璧のオールラウンダー",
        "虚空の王アザトース":    "ATK6666から繰り出す規格外ダメージ！覚悟があれば最強",
        "次元の守護者クロノス":   "通常攻撃に敵HP1%削りが乗る二段構えの削り魔",
        "天照大御神":           "毎ターン全体5%回復！長期戦を制す不滅のサポーター",
        "魔王ルシファー":        "全体ATK×1.3倍！仲間全員を覇王に変える支配者",
        "深海の主リヴァイアサン": "常時被ダメ18%軽減！圧倒的耐久でパーティを守る",
        "戦乙女ブリュンヒルデ":   "常時30%ダメ軽減！盾となり仲間の壊滅を防ぐ守護神",
        "星砕きの巨神":         "常時被ダメ70%カット！どんな攻撃も無効化に近い鉄壁",
        "万物の父オーディン":     "仲間ダウンで強化される！逆境で真価を発揮する神",
        "無限の可能性メビウス":   "LBを重ねるごとに別次元の強さに。これこそが可能性",
        "運命の女神フォルトゥナ": "全行動がランダム！ミスもあれば攻撃や全体回復も！運命を賭けろ",
        "奈落の支配者ヘカトンケイル": "千の腕が敵を縛る！常時ATK50%ダウンでパーティの耐久力が異次元に！",
        "天壁の守護神エギル": "鉄壁の聖盾が仲間を包む！ダメージを遮断する最強の守護者",
        // LR
        "創造神ゼウス":          "HP・ATKバランス抜群！どの編成にも馴染む万能の神",
        "竜神バハムート":         "高HPと高ATKを両立！序盤から終盤まで頼れる主力",
        "獄炎公サタン":          "ターンごとATK+2%！長引くほど手がつけられない怪物",
        "氷の女王シヴァ":         "低確率で敵攻撃スキップ！運命を操る不確定の恐怖",
        "不死鳥フェニックス":     "攻撃しながら自己回復！倒れそうで倒れない不死の鳥",
        "冥王ハデス":            "敵現在HPに比例する割合ダメ！どんな大物も削り殺す",
        "英雄王ギルガメッシュ":    "ATK5400のLR最高峰火力！一撃で勝敗を決める覇王",
        "雷神トール":            "HPが減るほど自動強化！追い詰められるほど恐ろしい",
        "太陽神ラー":            "全体ATK×1.2倍バフ！パーティの総火力を一段引き上げ",
        "知恵の梟アテナ":         "発動ターン被ダメ99%カット！絶体絶命を覆す究極盾",
        "幽冥の審判者ノルン":      "三つの運命が敵を断罪！常時ATK30%ダウンで戦況を掌握せよ",
        "封印の巫女イズナ":        "古の封印術で敵を弱体化！常時ATK15%ダウンで長期戦を制す",
        "聖域の乙女アルテミス":   "月光の聖壁が降り注ぐ！シールドで味方を守り抜く月の守護者",
    };

    // ========== 覚醒確定演出 ==========
    let _kakuseiResolve = null;
    let _kkAnimHandle = null;

    function _kkParticles(canvas, isUR) {
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const cx = canvas.width / 2, cy = canvas.height / 2;
        const colors = isUR
            ? ['#ff2200','#ff6600','#ffaa00','#ffffff','#ff4400','#ffdd00','#ff8800']
            : ['#ff00ff','#cc00ff','#ff88ff','#ffffff','#bb00ee','#ffccff','#dd66ff'];
        const particles = [];
        // 通常パーティクル
        for (let i = 0; i < 160; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 5;
            particles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: 2 + Math.random() * 6,
                color: colors[Math.floor(Math.random() * colors.length)],
                alpha: 1,
                decay: 0.006 + Math.random() * 0.01,
                trail: [],
                type: 'circle'
            });
        }
        // 星形パーティクル
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2.5;
            particles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: 4 + Math.random() * 8,
                color: '#ffffff',
                alpha: 1,
                decay: 0.004 + Math.random() * 0.008,
                trail: [],
                type: 'star',
                rot: Math.random() * Math.PI
            });
        }
        function drawStar(ctx, x, y, r, rot) {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const a = rot + (i * Math.PI * 2 / 5) - Math.PI / 2;
                const b = rot + ((i + 0.5) * Math.PI * 2 / 5) - Math.PI / 2;
                if (i === 0) ctx.moveTo(x + Math.cos(a) * r, y + Math.sin(a) * r);
                else ctx.lineTo(x + Math.cos(a) * r, y + Math.sin(a) * r);
                ctx.lineTo(x + Math.cos(b) * (r * 0.4), y + Math.sin(b) * (r * 0.4));
            }
            ctx.closePath();
        }
        function frame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let alive = false;
            for (const p of particles) {
                if (p.alpha <= 0) continue;
                alive = true;
                p.trail.push({x: p.x, y: p.y});
                if (p.trail.length > 10) p.trail.shift();
                for (let t = 0; t < p.trail.length - 1; t++) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[t].x, p.trail[t].y);
                    ctx.lineTo(p.trail[t+1].x, p.trail[t+1].y);
                    ctx.strokeStyle = p.color;
                    ctx.globalAlpha = p.alpha * (t / p.trail.length) * 0.4;
                    ctx.lineWidth = p.r * 0.5;
                    ctx.stroke();
                }
                ctx.globalAlpha = p.alpha;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = p.r * 4;
                if (p.type === 'star') {
                    ctx.fillStyle = p.color;
                    drawStar(ctx, p.x, p.y, p.r, p.rot);
                    ctx.fill();
                    p.rot += 0.05;
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                p.x += p.vx; p.y += p.vy;
                p.vy += 0.05;
                p.alpha -= p.decay;
            }
            if (alive) _kkAnimHandle = requestAnimationFrame(frame);
        }
        _kkAnimHandle = requestAnimationFrame(frame);
        // 2秒後と3.5秒後に再噴射
        [2000, 3500].forEach(delay => {
            setTimeout(() => {
                if (!document.getElementById('kakusei-overlay').classList.contains('active')) return;
                for (const p of particles) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = p.type === 'star' ? (0.5 + Math.random() * 2) : (1 + Math.random() * 4);
                    p.x = cx; p.y = cy;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.alpha = 0.9; p.trail = [];
                    if (p.type === 'star') p.rot = Math.random() * Math.PI;
                }
                if (!_kkAnimHandle) _kkAnimHandle = requestAnimationFrame(frame);
            }, delay);
        });
    }

    // 覚醒演出：カウントダウン演出 (3→2→1→KAKUSEI!)
    function _kkCountdown(isUR) {
        return new Promise(resolve => {
            const el = document.getElementById('kk-countdown');
            const color = isUR ? '#ff6600' : '#ff00ff';
            el.style.color = color;
            const steps = ['3','2','1','GO！'];
            let i = 0;
            function next() {
                if (i >= steps.length) { el.textContent = ''; resolve(); return; }
                el.textContent = steps[i];
                // アニメーションリセット：クラスを除去→reflow→再追加
                el.className = '';
                void el.offsetHeight;
                el.className = 'kk-countdown-anim';
                // ショートSE
                if (audioCtx) {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.type = 'sine';
                    const pitch = i < 3 ? (220 + i * 110) : 880;
                    osc.frequency.setValueAtTime(pitch, audioCtx.currentTime);
                    g.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                    osc.connect(g); g.connect(audioCtx.destination);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.35);
                }
                i++;
                setTimeout(next, i <= 3 ? 500 : 700);
            }
            next();
        });
    }

    async function showKakusei(item, rarity) {
        const isUR = rarity === 'UR';
        const overlay = document.getElementById('kakusei-overlay');
        const theme = isUR ? 'ur' : 'lr';

        // 背景色クラス
        document.getElementById('kk-bg').className = 'kk-bg ' + theme;

        // ラベル・輪・バッジのテーマ色
        document.getElementById('kk-label').className = 'kk-label ' + theme;
        document.getElementById('kk-label').textContent = isUR ? '✦ UR 覚醒確定召喚 ✦' : '✦ LR 覚醒確定召喚 ✦';
        ['kk-ring1','kk-ring2','kk-ring3'].forEach(id => document.getElementById(id).className = 'kk-ring ' + theme);
        ['kk-aura1','kk-aura2','kk-aura3'].forEach(id => document.getElementById(id).className = 'kk-aura-ring ' + theme);
        document.getElementById('kk-rarity').className = 'kk-rarity ' + theme;
        document.getElementById('kk-rarity').textContent = rarity;

        // キャラ情報
        document.getElementById('kk-icon').textContent = item.icon;
        document.getElementById('kk-name').textContent = item.name;
        const catchEl = document.getElementById('kk-catch');
        catchEl.className = 'kk-catch ' + theme;
        catchEl.textContent = catchCopyMap[item.name] ? `「${catchCopyMap[item.name]}」` : '';

        // ボタンアニメーションリセット
        const btn = document.getElementById('kk-btn');
        btn.style.animation = 'none';
        void btn.offsetHeight;
        btn.style.animation = '';

        // BGM停止
        bgmNormal.pause(); bgmEpic.pause(); bgmFever.pause();

        // オーバーレイ表示（カウントダウン前は内容を隠す）
        const kkContent = document.querySelector('.kk-content');
        kkContent.classList.remove('visible');
        overlay.classList.add('active');

        // カウントダウン演出
        await _kkCountdown(isUR);

        // コンテンツ表示アニメーション
        kkContent.classList.add('visible');

        // パーティクル起動
        const canvas = document.getElementById('kk-canvas');
        if (_kkAnimHandle) cancelAnimationFrame(_kkAnimHandle);
        _kkParticles(canvas, isUR);

        // 効果音（上昇音階 + 最後にファンファーレ）
        if (audioCtx) {
            const freqs = isUR
                ? [220, 330, 440, 550, 660, 880, 1100, 1320]
                : [196, 262, 330, 392, 523, 659, 784, 1047];
            freqs.forEach((f, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = i < freqs.length - 2 ? 'sine' : 'triangle';
                osc.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.10);
                gain.gain.setValueAtTime(0.22, audioCtx.currentTime + i * 0.10);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.10 + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime + i * 0.10);
                osc.stop(audioCtx.currentTime + i * 0.10 + 0.55);
            });
            // ベース音
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bassOsc.type = 'sine';
            bassOsc.frequency.setValueAtTime(isUR ? 55 : 65, audioCtx.currentTime);
            bassGain.gain.setValueAtTime(0.18, audioCtx.currentTime);
            bassGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
            bassOsc.connect(bassGain); bassGain.connect(audioCtx.destination);
            bassOsc.start(); bassOsc.stop(audioCtx.currentTime + 1.2);
        }

        return new Promise(resolve => { _kakuseiResolve = resolve; });
    }

    function closeKakusei() {
        document.getElementById('kakusei-overlay').classList.remove('active');
        if (_kkAnimHandle) { cancelAnimationFrame(_kkAnimHandle); _kkAnimHandle = null; }
        const canvas = document.getElementById('kk-canvas');
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        if (_kakuseiResolve) { _kakuseiResolve(); _kakuseiResolve = null; }
    }

    // ========== 絶対覇者確定演出 ==========
    let _hashaResolve = null;
    let _hashaAnimHandle = null;
    let _hashaSelectedItem = null;

    function _hashaParticles(canvas) {
        const W = canvas.width = window.innerWidth;
        const H = canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        const particles = [];
        const colors = ['#ff2200','#ff6600','#ff9900','#ffcc00','#fff'];
        for (let k = 0; k < 120; k++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 6;
            particles.push({
                x: W/2, y: H/2,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                r: 2 + Math.random() * 7,
                color: colors[Math.floor(Math.random() * colors.length)],
                alpha: 1, decay: 0.007 + Math.random() * 0.012, gravity: 0.1
            });
        }
        // 炎パーティクル（上向き）
        for (let k = 0; k < 60; k++) {
            const angle = -Math.PI/2 + (Math.random()-0.5) * Math.PI * 0.8;
            const speed = 1 + Math.random() * 5;
            particles.push({
                x: W/2 + (Math.random()-0.5)*120, y: H*0.6,
                vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
                r: 3 + Math.random()*9, color: colors[Math.floor(Math.random()*3)],
                alpha: 1, decay: 0.005 + Math.random()*0.01, gravity: -0.05
            });
        }
        function animate() {
            ctx.clearRect(0,0,W,H);
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy;
                p.vy += p.gravity; p.alpha -= p.decay;
                if (p.alpha <= 0) return;
                ctx.globalAlpha = p.alpha;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                ctx.fillStyle = p.color; ctx.fill();
            });
            ctx.globalAlpha = 1;
            _hashaAnimHandle = requestAnimationFrame(animate);
        }
        animate();
    }

    function _hashaCountdown() {
        return new Promise(resolve => {
            const el = document.getElementById('hasha-countdown');
            el.style.color = '#ff2200';
            const steps = ['3','2','1','GO！'];
            let i = 0;
            function next() {
                if (i >= steps.length) { el.textContent = ''; resolve(); return; }
                el.textContent = steps[i];
                el.className = '';
                void el.offsetHeight;
                el.className = 'hasha-countdown-anim';
                if (audioCtx) {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.type = i < 3 ? 'sawtooth' : 'square';
                    const pitch = i < 3 ? (150 + i * 80) : 660;
                    osc.frequency.setValueAtTime(pitch, audioCtx.currentTime);
                    g.gain.setValueAtTime(0.18, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
                    osc.connect(g); g.connect(audioCtx.destination);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
                }
                i++;
                setTimeout(next, i <= 3 ? 550 : 750);
            }
            next();
        });
    }

    async function showHasha(candidates) {
        // candidates: [{item, rarityInfo}, ...] の5体リスト
        const overlay = document.getElementById('hasha-overlay');

        const btn_old = document.getElementById('hasha-btn');
        if (btn_old) { btn_old.style.animation = 'none'; void btn_old.offsetHeight; btn_old.style.animation = ''; }

        bgmNormal.pause(); bgmEpic.pause(); bgmFever.pause();

        const content = document.getElementById('hasha-content');
        content.classList.remove('visible');
        overlay.classList.add('active');

        await _hashaCountdown();

        // キャラ選択グリッドを構築
        const grid = document.getElementById('hasha-select-grid');
        grid.innerHTML = '';
        candidates.forEach((cand, idx) => {
            const rarity = cand.rarityInfo.rarity;
            const card = document.createElement('div');
            card.className = 'hasha-card';
            card.style.animationDelay = (idx * 0.1) + 's';
            card.innerHTML = `
                <span class="hasha-card-icon">${cand.item.icon}</span>
                <div class="hasha-card-rarity ${rarity.toLowerCase()}">${rarity}</div>
                <div class="hasha-card-name">${cand.item.name}</div>
            `;
            card.onclick = () => _hashaSelectChar(cand);
            grid.appendChild(card);
        });

        content.classList.add('visible');

        const canvas = document.getElementById('hasha-canvas');
        if (_hashaAnimHandle) cancelAnimationFrame(_hashaAnimHandle);
        _hashaParticles(canvas);

        // 効果音（重い音階）
        if (audioCtx) {
            const freqs = [110, 165, 220, 330, 440, 660, 880, 1100];
            freqs.forEach((f, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = i < freqs.length - 2 ? 'sawtooth' : 'triangle';
                osc.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.09);
                gain.gain.setValueAtTime(0.20, audioCtx.currentTime + i * 0.09);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.09 + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime + i * 0.09);
                osc.stop(audioCtx.currentTime + i * 0.09 + 0.55);
            });
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bassOsc.type = 'sine';
            bassOsc.frequency.setValueAtTime(40, audioCtx.currentTime);
            bassGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
            bassGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
            bassOsc.connect(bassGain); bassGain.connect(audioCtx.destination);
            bassOsc.start(); bassOsc.stop(audioCtx.currentTime + 1.5);
        }

        return new Promise(resolve => { _hashaResolve = resolve; });
    }

    function _hashaSelectChar(cand) {
        // 選択されたキャラを確定して閉じる
        _hashaSelectedItem = cand;
        closeHasha();
    }

    function closeHasha() {
        document.getElementById('hasha-overlay').classList.remove('active');
        document.getElementById('hasha-content').classList.remove('visible');
        if (_hashaAnimHandle) { cancelAnimationFrame(_hashaAnimHandle); _hashaAnimHandle = null; }
        const canvas = document.getElementById('hasha-canvas');
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        if (_hashaResolve) { _hashaResolve(); _hashaResolve = null; }
    }

    function _buildHashaCandidates() {
        // LRとURの全キャラをまとめてシャッフルし、5体選ぶ
        const pool = [];
        ['UR','LR'].forEach(r => {
            const g = gachaData.find(g => g.rarity === r);
            if (g) g.items.forEach(item => pool.push({ item, rarityInfo: g }));
        });
        // Fisher-Yates shuffle
        for (let i = pool.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        return pool.slice(0, 5);
    }


    function getPickupSlot() {
        return Math.floor(Date.now() / (1000 * 60 * 60 * 3));
    }

    function getPickupChar(rarity) {
        const slot = getPickupSlot();
        const group = gachaData.find(g => g.rarity === rarity);
        if (!group) return null;
        const idx = slot % group.items.length;
        return group.items[idx];
    }

    function getTimeUntilNextPickup() {
        const msPerSlot = 1000 * 60 * 60 * 3;
        const msLeft = msPerSlot - (Date.now() % msPerSlot);
        const h = Math.floor(msLeft / 3600000);
        const m = Math.floor((msLeft % 3600000) / 60000);
        const s = Math.floor((msLeft % 60000) / 1000);
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updatePickupBanners() {
        const lrChar = getPickupChar('LR');
        const urChar = getPickupChar('UR');
        const timeStr = getTimeUntilNextPickup();
        if (lrChar) {
            document.getElementById('lr-pickup-name').textContent = lrChar.name;
            document.getElementById('lr-pickup-icon').textContent = lrChar.icon;
            document.getElementById('lr-banner-title').textContent = `LR ${lrChar.name} 召喚`;
            document.getElementById('lr-timer').textContent = timeStr;
            const el = document.getElementById('lr-pickup-catch');
            if (el) el.textContent = catchCopyMap[lrChar.name] ? `💬 ${catchCopyMap[lrChar.name]}` : '';
        }
        if (urChar) {
            document.getElementById('ur-pickup-name').textContent = urChar.name;
            document.getElementById('ur-pickup-icon').textContent = urChar.icon;
            document.getElementById('ur-banner-title').textContent = `UR ${urChar.name} 召喚`;
            document.getElementById('ur-timer').textContent = timeStr;
            const el = document.getElementById('ur-pickup-catch');
            if (el) el.textContent = catchCopyMap[urChar.name] ? `💬 ${catchCopyMap[urChar.name]}` : '';
        }
    }

    setInterval(() => {
        if (document.getElementById('lr-timer')) updatePickupBanners();
    }, 1000);

    function switchGachaTab(type, el) {
        currentGachaType = type;
        document.querySelectorAll('.gacha-tab').forEach(t => t.classList.remove('active-tab'));
        el.classList.add('active-tab');
        document.getElementById('banner-standard').style.display = type === 'standard' ? '' : 'none';
        document.getElementById('banner-lr').style.display = type === 'lr' ? '' : 'none';
        document.getElementById('banner-ur').style.display = type === 'ur' ? '' : 'none';
        // ボタンラベルの色
        const btn = document.getElementById('gachaBtn');
        if (type === 'lr') btn.style.background = 'linear-gradient(#8e44ad, #6c3483)';
        else if (type === 'ur') btn.style.background = 'linear-gradient(#c0392b, #96281b)';
        else btn.style.background = 'linear-gradient(#e67e22, #d35400)';
    }

    // 共通のガチャ＆バトルデータ
    const gachaData = [
        { rarity: "UR", color: "#ff0000", prob: 0.2, canLimitBreak: true, items: [
            {name:"終焉の龍神ラグナロク", icon:"🐉", hp:50000, atk:5500, skill:"天終の咆哮", baseVal: 1350, sDesc:"敵に攻撃力の{n}%のダメージを与える。"},
            {name:"秩序の女神アストレア", icon:"⚖️", hp:45000, atk:4500, skill:"ジャッジメント・レイ", baseVal: 800, sDesc:"敵にダメージを与え、味方全体を攻撃力の{n}%回復する。"},
            {name:"虚空の王アザトース", icon:"🌀", hp:66666, atk:6666, skill:"無名の混沌", baseVal: 1550, sDesc:"敵に攻撃力の{n}%ダメージ。ただし味方全体も攻撃力の50%ダメージを受ける。"},
            {name:"次元の守護者クロノス", icon:"⏳", hp:48000, atk:4200, skill:"タイム・イレイザー", baseVal: 900, sDesc:"時を削り、敵に攻撃力の{n}%ダメージを与える。敵のHPの1%の追加攻撃"},
            {name:"天照大御神", icon:"☀️", hp:42000, atk:4800, skill:"八咫の輝き", baseVal: 700, sDesc:"味方全体を攻撃力の{n}%回復。[常時]毎ターン味方全体HP5%回復"},
            {name:"魔王ルシファー", icon:"👼", hp:55000, atk:5500, skill:"パラダイス・ロスト", baseVal: 1200, sDesc:"失楽園の衝撃。敵に攻撃力の{n}%ダメージを与える。味方にバフ1.3倍"},
            {name:"深海の主リヴァイアサン", icon:"🐳", hp:60000, atk:3800, skill:"タイダルウェーブ", baseVal: 850, sDesc:"大海嘯を引き起こし、敵に攻撃力の{n}%ダメージを与える。味方の被ダメ18%軽減"},
            {name:"戦乙女ブリュンヒルデ", icon:"⚔️", hp:47000, atk:5200, skill:"ヴァルハラへの導き", baseVal: 950, sDesc:"戦乙女の導きで味方の被ダメージ30%軽減。敵に攻撃力の{n}%ダメージを与える"},
            {name:"星砕きの巨神", icon:"🪐", hp:70000, atk:6000, skill:"ギャラクシー・バスター", baseVal: 1000, sDesc:"銀河を砕く一撃。敵に攻撃力の{n}%ダメージを与え、常時、被ダメージ70%軽減"},
            {name:"万物の父オーディン", icon:"👁‍🗨", hp:54000, atk:4900, skill:"グングニルの一投", baseVal: 1100, sDesc:"必中の神槍。敵に攻撃力の{n}%ダメージを与える。味方が倒れるたびに回復,ATK30%上昇"},
            {name:"無限の可能性メビウス", icon:"∞", hp:8888, atk:666, skill:"アンリミテット", baseVal: 888, sDesc:"敵に攻撃力の{n}%の連撃（最大8連）。このキャラのLBは通常より強くなる"},
            {name:"運命の女神フォルトゥナ", icon:"🍀", hp:46000, atk:4600, skill:"運命の輪廻", baseVal: 900, sDesc:"運命の導き。行動がランダムで決まり、うまくはまれば強力な効果が発動する"},
            {name:"奈落の支配者ヘカトンケイル", icon:"🕷️", hp:52000, atk:4000, skill:"千の腕の呪縛", baseVal: 700, sDesc:"奈落の縛鎖。敵に攻撃力の{n}%ダメージ。[常時・全体]敵のATKを常時50%ダウン"},
            {name:"天壁の守護神エギル", icon:"🛡️", hp:65000, atk:300, skill:"聖盾の号令", baseVal: 18000, sDesc:"敵に少量ダメージを与え、味方全体に{n}の聖盾シールドを付与する。LBで盾の値が上昇", shieldVal: 20000}
        ]},
        { rarity: "LR", color: "#ff00ff", prob: 0.5, canLimitBreak: true, items: [
            {name:"創造神ゼウス", icon:"👁️", hp:19999, atk:888, skill:"神罰の雷槍", baseVal: 500, sDesc:"全知全能の雷。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"竜神バハムート", icon:"🐲", hp:22000, atk:1200, skill:"メガフレア", baseVal: 600, sDesc:"究極の火炎。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"獄炎公サタン", icon:"😈", hp:21000, atk:1300, skill:"地獄の業火", baseVal: 550, sDesc:"地獄の火。敵に攻撃力の{n}%ダメージを与える。ターン経過ごとに自身のATKを2%ずつ上昇"},
            {name:"氷の女王シヴァ", icon:"🧞‍♀️", hp:19500, atk:1100, skill:"ダイアモンドダスト", baseVal: 480, sDesc:"絶対零度の世界。敵に攻撃力の{n}%ダメージを与える。[常時]低確率で敵の攻撃をスキップ"},
            {name:"不死鳥フェニックス", icon:"🐦‍🔥", hp:25000, atk:900, skill:"転生の炎", baseVal: 400, sDesc:"敵に攻撃力の{n}%ダメージを与え、自身を同量回復する。"},
            {name:"冥王ハデス", icon:"🔱", hp:18500, atk:10, skill:"死の宣告", baseVal: 5, sDesc:"死の宣告。敵の現在HPの{n}%の割合ダメージを与える。"},
            {name:"英雄王ギルガメッシュ", icon:"👑", hp:5000, atk:5400, skill:"財宝の雨", baseVal: 800, sDesc:"王の財宝。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"雷神トール", icon:"🔨", hp:23000, atk:1250, skill:"ミョルニル・ハンマー", baseVal: 580, sDesc:"敵に{n}%ダメ。[常時]HP減少で被ダメ軽減、ATK上昇"},
            {name:"太陽神ラー", icon:"🦅", hp:21000, atk:1000, skill:"ソーラー・フレア", baseVal: 450, sDesc:"太陽の熱線。敵に攻撃力の{n}%ダメージを与える。味方にバフ1.2倍"},
            {name:"知恵の梟アテナ", icon:"🦉", hp:30000, atk:950, skill:"イージスの盾", baseVal: 40, sDesc:"知恵の盾。敵に攻撃力の{n}%ダメージを与える。このターンのみ味方のダメ99%軽減"},
            {name:"幽冥の審判者ノルン", icon:"💠", hp:20000, atk:1100, skill:"運命の裁断", baseVal: 520, sDesc:"三運命の裁き。敵に攻撃力の{n}%ダメージ。[常時・全体]敵のATKを常時30%ダウン"},
            {name:"聖域の乙女アルテミス", icon:"🌸", hp:28000, atk:200, skill:"月光の聖壁", baseVal: 10000, sDesc:"敵に少量ダメージを与え、味方全体に{n}の月光シールドを付与する。LBで盾の値が上昇", shieldVal: 12000}
        ]},
        { rarity: "SSR", color: "#ffd700", prob: 3.5, canLimitBreak: true, items: [
            {name:"聖騎士", icon:"🧙‍♂️", hp:6000, atk:350, skill:"光の加護", baseVal: 30, sDesc:"敵に攻撃力の{n}%ダメージを与える。[常時]自身の被ダメージ30%軽減。"},
            {name:"九尾の狐", icon:"🦊", hp:5500, atk:600, skill:"殺生石", baseVal: 150, sDesc:"妖狐の呪い。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"剛腕の巨人", icon:"👹", hp:8000, atk:400, skill:"アースクエイク", baseVal: 200, sDesc:"大地の震え。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"蒼海のマーメイド", icon:"🧜‍♀️", hp:5800, atk:320, skill:"癒やしの歌", baseVal: 100, sDesc:"癒やしの旋律。味方全体を自身の攻撃力の{n}%回復する。"},
            {name:"死霊術師ネクロ", icon:"💀", hp:5200, atk:550, skill:"ソウルイーター", baseVal: 180, sDesc:"魂の搾取。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"疾風の忍", icon:"🌪️", hp:5000, atk:580, skill:"真空波", baseVal: 140, sDesc:"真空の刃。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"紅蓮の魔女", icon:"🧙‍♀️", hp:5100, atk:620, skill:"プロミネンス", baseVal: 220, sDesc:"爆炎魔法。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"金剛のゴーレム", icon:"🧱", hp:10000, atk:250, skill:"ハードボディ", baseVal: 50, sDesc:"敵に攻撃力の{n}%ダメージを与える。[常時]自身の被ダメージ50%軽減。"},
            {name:"月読の暗殺者", icon:"🌙", hp:100, atk:4000, skill:"月の影", baseVal: 700, sDesc:"影からの急襲。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"麒麟", icon:"🦒", hp:6500, atk:400, skill:"天界の風", baseVal: 120, sDesc:"天界の息吹。最もHPが減っている味方を攻撃力の{n}%回復する。"},
            {name:"封印の巫女イズナ", icon:"🏮", hp:6200, atk:480, skill:"呪縛の御幣", baseVal: 160, sDesc:"古の封印術。敵に攻撃力の{n}%ダメージ。[常時・全体]敵のATKを常時15%ダウン"}
        ]},
        { rarity: "SR", color: "#00ffff", prob: 15, canLimitBreak: true, items: [
            {name:"忍者", icon:"🥷", hp:1800, atk:480, skill:"影縫い", baseVal: 80, sDesc:"影を縫い、敵に攻撃力の{n}%ダメージを与える。"},
            {name:"魔弾の射手", icon:"🏹", hp:1500, atk:420, skill:"チェイスアロー", baseVal: 120, sDesc:"必中の矢。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"鉄壁の重騎士", icon:"🛡️", hp:3000, atk:200, skill:"不退転", baseVal: 50, sDesc:"敵に攻撃力の{n}%ダメージを与える。[常時]自身の被ダメージ50%軽減。"},
            {name:"見習い魔導士", icon:"🧪", hp:1400, atk:450, skill:"バーストマジック", baseVal: 110, sDesc:"不安定な魔弾。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"僧侶", icon:"🙏", hp:2200, atk:150, skill:"ヒール", baseVal: 60, sDesc:"慈愛の光。最もHPが減っている味方を攻撃力の{n}%回復する。"},
            {name:"盗賊", icon:"💰", hp:1600, atk:380, skill:"急襲", baseVal: 90, sDesc:"素早い一撃。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"狂戦士", icon:"🪓", hp:2500, atk:550, skill:"暴走", baseVal: 150, sDesc:"自身の最大HP10%を消費し、敵に攻撃力の{n}%ダメージ。"},
            {name:"弓使い", icon:"🎯", hp:1400, atk:400, skill:"ピアシング", baseVal: 100, sDesc:"急所を狙い、敵に攻撃力の{n}%ダメージを与える。"},
            {name:"格闘家", icon:"👊", hp:2800, atk:350, skill:"連撃", baseVal: 105, sDesc:"怒涛の拳。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"サマナー", icon:"📜", hp:1700, atk:410, skill:"召喚・小鬼", baseVal: 85, sDesc:"小鬼の使役。敵に攻撃力の{n}%ダメージを与える。"}
        ]},
        { rarity: "R", color: "#cd7f32", prob: 80, canLimitBreak: false, items: [
            {name:"スライム", icon:"💧", hp:300, atk:20, skill:"液状化", baseVal: 10, sDesc:"液状の体。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"村人", icon:"👨‍🌾", hp:600, atk:25, skill:"投石", baseVal: 5, sDesc:"石を投げ、敵に攻撃力の{n}%ダメージを与える。"},
            {name:"見習い剣士", icon:"🗡️", hp:800, atk:50, skill:"勇気のしるし", baseVal: 10, sDesc:"勇気の一撃。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"ゴブリン", icon:"👺", hp:500, atk:60, skill:"強奪", baseVal: 5, sDesc:"卑劣な攻撃。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"スケルトン", icon:"🦴", hp:400, atk:45, skill:"骨太", baseVal: 15, sDesc:"骨の一撃。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"コウモリ", icon:"🦇", hp:200, atk:30, skill:"吸血", baseVal: 8, sDesc:"血を吸い、敵に攻撃力の{n}%ダメージを与える。"},
            {name:"巨大ネズミ", icon:"🐀", hp:350, atk:40, skill:"かじる", baseVal: 7, sDesc:"鋭い前歯。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"毒キノコ", icon:"🍄", hp:500, atk:10, skill:"胞子", baseVal: 5, sDesc:"毒の胞子。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"野犬", icon:"🐕", hp:450, atk:55, skill:"遠吠え", baseVal: 10, sDesc:"鋭い牙。敵に攻撃力の{n}%ダメージを与える。"},
            {name:"幽霊", icon:"👻", hp:100, atk:40, skill:"憑依", baseVal: 12, sDesc:"霊障攻撃。敵に攻撃力の{n}%ダメージを与える。"}
        ]}
    ];

    function saveToLocal() {
        if (!currentUser) return;
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        allUsers[currentUser] = userData;
        localStorage.setItem("gacha_users", JSON.stringify(allUsers));
    }

    // ==========================================
    // 称号システム
    // ==========================================
    const TITLE_DEFS = [
        // 塔クリア系
        { id:"tower_complete", icon:"🏆", name:"魔王城の征服者", cond:"塔の全15層を制覇する", check: u => (u.maxFloor||0) >= 15 },
        { id:"tower_10",       icon:"🗡️", name:"勇猛なる英雄",   cond:"塔の10層以上に到達する", check: u => (u.maxFloor||0) >= 10 },
        { id:"tower_7",        icon:"⚔️", name:"塔の挑戦者",     cond:"塔の7層以上に到達する",  check: u => (u.maxFloor||0) >= 7 },
        { id:"tower_1",        icon:"🗺️", name:"冒険の第一歩",   cond:"塔の1層以上に到達する",  check: u => (u.maxFloor||0) >= 1 },
        // ガチャ系
        { id:"lr_comp",        icon:"💜", name:"LRコレクター",    cond:"LRキャラを全員獲得する",  check: u => { const lr = gachaData.find(g=>g.rarity==='LR'); return lr && lr.items.every(i => u.myBox[i.name] !== undefined); } },
        { id:"ur_comp",        icon:"❤️", name:"URコレクター",    cond:"URキャラを全員獲得する",  check: u => { const ur = gachaData.find(g=>g.rarity==='UR'); return ur && ur.items.every(i => u.myBox[i.name] !== undefined); } },
        { id:"ssr_comp",       icon:"🌟", name:"SSRコレクター",   cond:"SSRキャラを全員獲得する", check: u => { const ssr = gachaData.find(g=>g.rarity==='SSR'); return ssr && ssr.items.every(i => u.myBox[i.name] !== undefined); } },
        { id:"all_comp",       icon:"👑", name:"完全なるコレクター", cond:"全レアリティのキャラを全員獲得する", check: u => gachaData.every(g => g.items.every(i => u.myBox[i.name] !== undefined)) },
        { id:"max_lb_lr",      icon:"✨", name:"LR覚醒の証",      cond:"LRキャラを1体10凸にする", check: u => { const lr = gachaData.find(g=>g.rarity==='LR'); return lr && lr.items.some(i => (u.myBox[i.name]||0) >= 10); } },
        { id:"max_lb_ur",      icon:"🔥", name:"UR覚醒の証",      cond:"URキャラを1体10凸にする", check: u => { const ur = gachaData.find(g=>g.rarity==='UR'); return ur && ur.items.some(i => (u.myBox[i.name]||0) >= 10); } },
        { id:"max_lb_all",     icon:"🌈", name:"完凸の覇者",      cond:"任意のキャラを3体10凸にする", check: u => Object.values(u.myBox).filter(v=>v>=10).length >= 3 },
        { id:"draws_100",      icon:"🎰", name:"ガチャ愛好家",    cond:"召喚を合計100回行う",     check: u => (u.totalDraws||0) >= 100 },
        { id:"draws_500",      icon:"💎", name:"ガチャ狂い",      cond:"召喚を合計500回行う",     check: u => (u.totalDraws||0) >= 500 },
        { id:"draws_1000",     icon:"🌌", name:"召喚の申し子",    cond:"召喚を合計1000回行う",    check: u => (u.totalDraws||0) >= 1000 },
        // 時間・その他
        { id:"play_30m",       icon:"⏱️", name:"熱中者",          cond:"合計プレイ時間が30分以上", check: u => (u.totalPlaySec||0) >= 1800 },
        { id:"play_2h",        icon:"🕐", name:"廃人への道",      cond:"合計プレイ時間が2時間以上", check: u => (u.totalPlaySec||0) >= 7200 },
        { id:"play_10h",       icon:"🏅", name:"絵文字大戦の申し子", cond:"合計プレイ時間が10時間以上", check: u => (u.totalPlaySec||0) >= 36000 },
        { id:"stones_100k",    icon:"💰", name:"富豪の称号",      cond:"聖晶石を合計10万以上獲得する", check: u => (u.totalStonesEarned||0) >= 100000 },
        { id:"pvp_first",      icon:"⚔️", name:"初陣の勇者",      cond:"PVPバトルを1回行う",      check: u => (u.pvpBattleCount||0) >= 1 },
        { id:"pvp_10",         icon:"🥊", name:"PVPの猛者",       cond:"PVPバトルを10回行う",     check: u => (u.pvpBattleCount||0) >= 10 },
        { id:"pvp_win",        icon:"🎖️", name:"勝利の覇者",      cond:"PVPで1回勝利する",        check: u => (u.pvpWinCount||0) >= 1 },
        { id:"has_zeus",       icon:"👁️", name:"ゼウスの加護",       cond:"創造神ゼウスを10凸にする",   check: u => (u.myBox["創造神ゼウス"]||0) >= 10 },
        { id:"has_lucifer",    icon:"👼", name:"堕天使の証",         cond:"魔王ルシファーを10凸にする",  check: u => (u.myBox["魔王ルシファー"]||0) >= 10 },
        { id:"beginner",       icon:"🌱", name:"はじめの一歩",       cond:"最初のキャラを召喚する",      check: u => Object.keys(u.myBox).length >= 1 },
        // UR 10凸称号
        { id:"max_ragnarok",   icon:"🐉", name:"終焉の龍の使徒",     cond:"終焉の龍神ラグナロクを10凸にする",    check: u => (u.myBox["終焉の龍神ラグナロク"]||0) >= 10 },
        { id:"max_astraea",    icon:"⚖️", name:"秩序の守護者",       cond:"秩序の女神アストレアを10凸にする",    check: u => (u.myBox["秩序の女神アストレア"]||0) >= 10 },
        { id:"max_azathoth",   icon:"🌀", name:"混沌の王の眷属",     cond:"虚空の王アザトースを10凸にする",      check: u => (u.myBox["虚空の王アザトース"]||0) >= 10 },
        { id:"max_chronos",    icon:"⏳", name:"時間の守護者",       cond:"次元の守護者クロノスを10凸にする",    check: u => (u.myBox["次元の守護者クロノス"]||0) >= 10 },
        { id:"max_amaterasu",  icon:"☀️", name:"太陽の申し子",       cond:"天照大御神を10凸にする",              check: u => (u.myBox["天照大御神"]||0) >= 10 },
        { id:"max_leviathan",  icon:"🐳", name:"深海の覇者",         cond:"深海の主リヴァイアサンを10凸にする",  check: u => (u.myBox["深海の主リヴァイアサン"]||0) >= 10 },
        { id:"max_brynhild",   icon:"⚔️", name:"ヴァルキリーの加護", cond:"戦乙女ブリュンヒルデを10凸にする",    check: u => (u.myBox["戦乙女ブリュンヒルデ"]||0) >= 10 },
        { id:"max_colossus",   icon:"🪐", name:"銀河の砕き手",       cond:"星砕きの巨神を10凸にする",            check: u => (u.myBox["星砕きの巨神"]||0) >= 10 },
        { id:"max_odin",       icon:"👁‍🗨", name:"万物の父の信奉者",   cond:"万物の父オーディンを10凸にする",      check: u => (u.myBox["万物の父オーディン"]||0) >= 10 },
        { id:"max_mobius",     icon:"∞",  name:"無限の可能性の体現者",cond:"無限の可能性メビウスを10凸にする",    check: u => (u.myBox["無限の可能性メビウス"]||0) >= 10 },
        { id:"max_fortuna",    icon:"🍀", name:"運命に選ばれし者",   cond:"運命の女神フォルトゥナを10凸にする",  check: u => (u.myBox["運命の女神フォルトゥナ"]||0) >= 10 },
        // LR 10凸称号
        { id:"max_bahamut",    icon:"🐲", name:"龍神の覇者",         cond:"竜神バハムートを10凸にする",          check: u => (u.myBox["竜神バハムート"]||0) >= 10 },
        { id:"max_satan",      icon:"😈", name:"獄炎の支配者",       cond:"獄炎公サタンを10凸にする",            check: u => (u.myBox["獄炎公サタン"]||0) >= 10 },
        { id:"max_shiva",      icon:"🧞‍♀️", name:"氷河の女王",         cond:"氷の女王シヴァを10凸にする",          check: u => (u.myBox["氷の女王シヴァ"]||0) >= 10 },
        { id:"max_phoenix",    icon:"🐦‍🔥", name:"不死の炎の継承者",   cond:"不死鳥フェニックスを10凸にする",      check: u => (u.myBox["不死鳥フェニックス"]||0) >= 10 },
        { id:"max_hades",      icon:"🔱", name:"冥界の支配者",       cond:"冥王ハデスを10凸にする",              check: u => (u.myBox["冥王ハデス"]||0) >= 10 },
        { id:"max_gilgamesh",  icon:"👑", name:"英雄王の後継者",     cond:"英雄王ギルガメッシュを10凸にする",    check: u => (u.myBox["英雄王ギルガメッシュ"]||0) >= 10 },
        { id:"max_thor",       icon:"🔨", name:"雷鳴の申し子",       cond:"雷神トールを10凸にする",              check: u => (u.myBox["雷神トール"]||0) >= 10 },
        { id:"max_ra",         icon:"🦅", name:"太陽神の使者",       cond:"太陽神ラーを10凸にする",              check: u => (u.myBox["太陽神ラー"]||0) >= 10 },
        { id:"max_athena",     icon:"🦉", name:"知恵と戦略の体現者", cond:"知恵の梟アテナを10凸にする",          check: u => (u.myBox["知恵の梟アテナ"]||0) >= 10 },
        // SSR 10凸称号
        { id:"max_holyknght",  icon:"🧙‍♂️", name:"光の聖騎士",         cond:"聖騎士を10凸にする",                  check: u => (u.myBox["聖騎士"]||0) >= 10 },
        { id:"max_ninetails",  icon:"🦊", name:"九命の狐",           cond:"九尾の狐を10凸にする",                check: u => (u.myBox["九尾の狐"]||0) >= 10 },
        { id:"max_giant",      icon:"👹", name:"剛腕の巨神",         cond:"剛腕の巨人を10凸にする",              check: u => (u.myBox["剛腕の巨人"]||0) >= 10 },
        { id:"max_mermaid",    icon:"🧜‍♀️", name:"蒼海の歌姫",         cond:"蒼海のマーメイドを10凸にする",        check: u => (u.myBox["蒼海のマーメイド"]||0) >= 10 },
        { id:"max_necro",      icon:"💀", name:"死霊使いの極意",     cond:"死霊術師ネクロを10凸にする",          check: u => (u.myBox["死霊術師ネクロ"]||0) >= 10 },
        { id:"max_ninja_ssr",  icon:"🌪️", name:"疾風の体現者",       cond:"疾風の忍を10凸にする",                check: u => (u.myBox["疾風の忍"]||0) >= 10 },
        { id:"max_witch",      icon:"🧙‍♀️", name:"紅蓮の魔女の継承者", cond:"紅蓮の魔女を10凸にする",              check: u => (u.myBox["紅蓮の魔女"]||0) >= 10 },
        { id:"max_golem",      icon:"🧱", name:"金剛の守護者",       cond:"金剛のゴーレムを10凸にする",          check: u => (u.myBox["金剛のゴーレム"]||0) >= 10 },
        { id:"max_assassin",   icon:"🌙", name:"月夜の暗殺者",       cond:"月読の暗殺者を10凸にする",            check: u => (u.myBox["月読の暗殺者"]||0) >= 10 },
        { id:"max_kirin",      icon:"🦒", name:"天界の使者",         cond:"麒麟を10凸にする",                    check: u => (u.myBox["麒麟"]||0) >= 10 },
        // ▼ ver1.3追加 新キャラ10凸称号
        { id:"max_hecatoncheir", icon:"🕷️", name:"奈落の縛鎖",        cond:"奈落の支配者ヘカトンケイルを10凸にする", check: u => (u.myBox["奈落の支配者ヘカトンケイル"]||0) >= 10 },
        {  id:"max_norn",         icon:"💠", name:"三運命の裁き手",     cond:"幽冥の審判者ノルンを10凸にする",         check: u => (u.myBox["幽冥の審判者ノルン"]||0) >= 10 },
        { id:"max_izuna",        icon:"🏮", name:"封印の巫女の継承者", cond:"封印の巫女イズナを10凸にする",           check: u => (u.myBox["封印の巫女イズナ"]||0) >= 10 },
        // ▼ ver1.5追加 新シールドキャラ称号
        { id:"max_egil",         icon:"🛡️", name:"天壁の守護神の加護", cond:"天壁の守護神エギルを10凸にする",         check: u => (u.myBox["天壁の守護神エギル"]||0) >= 10 },
        {  id:"max_artemis",      icon:"🌸", name:"月の守護乙女",       cond:"聖域の乙女アルテミスを10凸にする",       check: u => (u.myBox["聖域の乙女アルテミス"]||0) >= 10 },
        // ▼ ガチャ回数上位称号（1000超）
        { id:"draws_3000",     icon:"🌠", name:"召喚狂の王",          cond:"召喚を合計3000回行う",                  check: u => (u.totalDraws||0) >= 3000 },
        { id:"draws_5000",     icon:"🎆", name:"伝説の召喚師",        cond:"召喚を合計5000回行う",                  check: u => (u.totalDraws||0) >= 5000 },
        { id:"draws_10000",    icon:"👾", name:"一万回の執念",        cond:"召喚を合計10000回行う",                 check: u => (u.totalDraws||0) >= 10000 },
        // ▼ プレイ時間上位称号（10h超）
        { id:"play_24h",       icon:"🌙", name:"不眠の闘士",          cond:"合計プレイ時間が24時間以上",             check: u => (u.totalPlaySec||0) >= 86400 },
        { id:"play_50h",       icon:"🌌", name:"廃人の極み",          cond:"合計プレイ時間が50時間以上",             check: u => (u.totalPlaySec||0) >= 180000 },
        { id:"play_100h",      icon:"💀", name:"伝説の廃人",          cond:"合計プレイ時間が100時間以上",            check: u => (u.totalPlaySec||0) >= 360000 },
        // ▼ 所持石（総獲得）上位称号
        { id:"stones_500k",    icon:"💎", name:"大富豪",              cond:"聖晶石を合計50万以上獲得する",          check: u => (u.totalStonesEarned||0) >= 500000 },
        { id:"stones_1m",      icon:"👑", name:"聖晶石の王",          cond:"聖晶石を合計100万以上獲得する",         check: u => (u.totalStonesEarned||0) >= 1000000 },
        { id:"stones_5m",      icon:"🌟", name:"石の化身",            cond:"聖晶石を合計500万以上獲得する",         check: u => (u.totalStonesEarned||0) >= 5000000 },
        // ▼ PVP系追加称号
        { id:"pvp_50",         icon:"🏹", name:"歴戦のPVP戦士",      cond:"PVPバトルを50回行う",                   check: u => (u.pvpBattleCount||0) >= 50 },
        { id:"pvp_100",        icon:"⚔️", name:"PVP百戦錬磨",         cond:"PVPバトルを100回行う",                  check: u => (u.pvpBattleCount||0) >= 100 },
        { id:"pvp_win_10",     icon:"🥇", name:"十連勝の覇者",        cond:"PVPで累計10回勝利する",                 check: u => (u.pvpWinCount||0) >= 10 },
        { id:"pvp_win_50",     icon:"🏆", name:"PVP最強の証",         cond:"PVPで累計50回勝利する",                 check: u => (u.pvpWinCount||0) >= 50 },
        { id:"pvp_win_100",    icon:"🎗️", name:"闘神の称号",          cond:"PVPで累計100回勝利する",                check: u => (u.pvpWinCount||0) >= 100 },
        // ▼ 塔追加称号
        { id:"tower_15_10",    icon:"🌠", name:"真・魔王城の征服者", cond:"塔の全15層を10回以上制覇する",           check: u => (u.towerClearCount||0) >= 10 },
        { id:"tower_15_50",    icon:"🏰", name:"永遠の魔王城支配者", cond:"塔の全15層を50回以上制覇する",           check: u => (u.towerClearCount||0) >= 50 },
        // ▼ デバフ編成系
        { id:"debuff_trio",    icon:"🔮", name:"呪縛の三位一体",     cond:"ヘカトンケイル・ノルン・イズナを全員獲得する", check: u => u.myBox["奈落の支配者ヘカトンケイル"]!==undefined && u.myBox["幽冥の審判者ノルン"]!==undefined && u.myBox["封印の巫女イズナ"]!==undefined },
        { id:"debuff_max_trio",icon:"💫", name:"完全なる封印者",     cond:"ヘカトンケイル・ノルン・イズナを全員10凸にする", check: u => (u.myBox["奈落の支配者ヘカトンケイル"]||0)>=10 && (u.myBox["幽冥の審判者ノルン"]||0)>=10 && (u.myBox["封印の巫女イズナ"]||0)>=10 },
        { id:"guard_duo",      icon:"🛡️", name:"鉄壁の盾双璧",      cond:"ブリュンヒルデとリヴァイアサンを両方10凸にする", check: u => (u.myBox["戦乙女ブリュンヒルデ"]||0)>=10 && (u.myBox["深海の主リヴァイアサン"]||0)>=10 },
        // ▼ 完凸上位称号
        { id:"max_lb_10units", icon:"✨", name:"凸の求道者",         cond:"10体以上を10凸にする",                   check: u => Object.values(u.myBox).filter(v=>v>=10).length >= 10 },
        { id:"max_lb_all_ur",  icon:"🔥", name:"UR完全覚醒",         cond:"URキャラを全員10凸にする",               check: u => { const ur=gachaData.find(g=>g.rarity==='UR'); return ur&&ur.items.every(i=>(u.myBox[i.name]||0)>=10); } },
        { id:"max_lb_all_lr",  icon:"💜", name:"LR完全覚醒",         cond:"LRキャラを全員10凸にする",               check: u => { const lr=gachaData.find(g=>g.rarity==='LR'); return lr&&lr.items.every(i=>(u.myBox[i.name]||0)>=10); } },
        { id:"max_lb_all_ssr", icon:"🌟", name:"SSR完全覚醒",        cond:"SSRキャラを全員10凸にする",              check: u => { const ssr=gachaData.find(g=>g.rarity==='SSR'); return ssr&&ssr.items.every(i=>(u.myBox[i.name]||0)>=10); } },
        { id:"max_lb_absolute",icon:"🌈", name:"覚醒の絶対者",       cond:"全キャラを10凸にする（R除く）",          check: u => ['UR','LR','SSR'].every(r=>{ const g=gachaData.find(x=>x.rarity===r); return g&&g.items.every(i=>(u.myBox[i.name]||0)>=10); }) },
    ];

    let _titleToastTimer = null;

    function checkAndUnlockTitles(silent=false) {
        if (!userData.titles) userData.titles = { unlocked: [], active: null };
        const newlyUnlocked = [];
        for (const t of TITLE_DEFS) {
            if (!userData.titles.unlocked.includes(t.id)) {
                try {
                    if (t.check(userData)) {
                        userData.titles.unlocked.push(t.id);
                        newlyUnlocked.push(t);
                    }
                } catch(e) {}
            }
        }
        if (newlyUnlocked.length > 0) {
            saveToLocal();
            if (!silent) {
                // 順番にトースト通知
                newlyUnlocked.forEach((t, i) => setTimeout(() => showTitleToast(t), i * 2500));
            }
        }
        return newlyUnlocked;
    }

    function showTitleToast(titleDef) {
        const toast = document.getElementById('titleToast');
        document.getElementById('titleToastName').textContent = titleDef.icon + ' ' + titleDef.name;
        toast.style.display = 'block';
        if (_titleToastTimer) clearTimeout(_titleToastTimer);
        _titleToastTimer = setTimeout(() => { toast.style.display = 'none'; }, 2200);
    }

    function openTitleModal() {
        if (!userData.titles) userData.titles = { unlocked: [], active: null };
        const active = userData.titles.active;
        document.getElementById('titleActiveDisplay').textContent = active ? 
            (TITLE_DEFS.find(t=>t.id===active)?.icon || '') + ' ' + (TITLE_DEFS.find(t=>t.id===active)?.name || active) : '（未設定）';
        
        const list = document.getElementById('titleList');
        list.innerHTML = '';
        for (const t of TITLE_DEFS) {
            const isUnlocked = userData.titles.unlocked.includes(t.id);
            const isActive = active === t.id;
            const div = document.createElement('div');
            div.className = 'title-item' + (isActive ? ' active-title' : '') + (!isUnlocked ? ' locked' : '');
            div.innerHTML = `<div class="title-icon">${t.icon}</div>
                <div class="title-info">
                    <div class="title-name">${t.name}${isUnlocked && !isActive ? '<span class="title-unlock-badge">獲得済み</span>' : ''}</div>
                    <div class="title-cond">${t.cond}</div>
                </div>
                ${isUnlocked ? `<button class="title-set-btn ${isActive ? 'is-active' : ''}" onclick="setActiveTitle('${t.id}')">${isActive ? '設定中' : '設定する'}</button>` : '<span style="font-size:10px;color:#555;">🔒 未解放</span>'}`;
            list.appendChild(div);
        }
        document.getElementById('titleModal').style.display = 'flex';
    }

    function closeTitleModal() {
        document.getElementById('titleModal').style.display = 'none';
    }

    function setActiveTitle(titleId) {
        if (!userData.titles) userData.titles = { unlocked: [], active: null };
        if (userData.titles.active === titleId) {
            // 解除
            userData.titles.active = null;
        } else {
            userData.titles.active = titleId;
        }
        saveToLocal();
        updateStatusBarTitle();
        openTitleModal(); // 再描画
    }

    function updateStatusBarTitle() {
        const el = document.getElementById('statusBarTitle');
        if (!el) return;
        const active = userData.titles && userData.titles.active;
        if (active) {
            const t = TITLE_DEFS.find(td => td.id === active);
            if (t) {
                el.textContent = t.icon + ' ' + t.name;
                el.style.display = '';
                return;
            }
        }
        el.style.display = 'none';
    }

    // ==========================================
    // 塔完全制覇演出
    // ==========================================
    let _towerClearResolve = null;
    let _towerClearAnimHandle = null;

    function startTowerClearParticles(canvas) {
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const W = canvas.width, H = canvas.height;
        const colors = ['#ffd700','#ff8800','#ff4400','#ffffff','#ffdd44','#ff66aa','#00ffcc','#ff00ff','#88aaff'];
        const particles = [];
        function spawnBurst(x, y) {
            for (let i = 0; i < 60; i++) {
                const a = Math.random()*Math.PI*2, s = 2+Math.random()*8;
                particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s - 2, r: 3+Math.random()*6,
                    color: colors[Math.floor(Math.random()*colors.length)], alpha: 1, decay: 0.008+Math.random()*0.012, gravity: 0.12 });
            }
            // 星形
            for (let i = 0; i < 15; i++) {
                const a = Math.random()*Math.PI*2, s = 1+Math.random()*4;
                particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s - 1, r: 2+Math.random()*4,
                    color: '#ffffff', alpha: 1, decay: 0.006+Math.random()*0.01, gravity: 0.08, star: true });
            }
        }
        // 初回複数バースト
        const burstPositions = [
            [W*0.2, H*0.3],[W*0.5, H*0.2],[W*0.8, H*0.3],
            [W*0.3, H*0.6],[W*0.7, H*0.5],[W*0.5, H*0.5]
        ];
        burstPositions.forEach(([x,y]) => spawnBurst(x, y));
        // 定期的に追加バースト
        let burstCount = 0;
        const burstInterval = setInterval(() => {
            spawnBurst(Math.random()*W, Math.random()*H*0.6);
            if (++burstCount > 20) clearInterval(burstInterval);
        }, 600);

        function animate() {
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(0, 0, W, H);
            let alive = false;
            for (let i = particles.length-1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                p.alpha -= p.decay;
                if (p.alpha <= 0) { particles.splice(i, 1); continue; }
                alive = true;
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                if (p.star) {
                    ctx.beginPath();
                    for (let s = 0; s < 5; s++) {
                        const angle = (s/5)*Math.PI*2 - Math.PI/2;
                        const xp = p.x + Math.cos(angle)*p.r;
                        const yp = p.y + Math.sin(angle)*p.r;
                        s === 0 ? ctx.moveTo(xp,yp) : ctx.lineTo(xp,yp);
                    }
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
            if (alive || particles.length > 0) _towerClearAnimHandle = requestAnimationFrame(animate);
            else { clearInterval(burstInterval); }
        }
        _towerClearAnimHandle = requestAnimationFrame(animate);
    }

    function showTowerClear(reward) {
        return new Promise(resolve => {
            _towerClearResolve = resolve;
            document.getElementById('towerClearReward').textContent = '💎 ' + reward.toLocaleString() + ' 獲得！';
            // 新称号獲得チェック
            const newly = checkAndUnlockTitles(true);
            const newTitleEl = document.getElementById('towerClearNewTitle');
            const towerTitle = newly.find(t => t.id === 'tower_complete');
            if (towerTitle) {
                newTitleEl.textContent = '🎊 新称号解放: 「' + towerTitle.icon + ' ' + towerTitle.name + '」';
                newTitleEl.style.display = 'inline-block';
            } else {
                newTitleEl.style.display = 'none';
            }
            const overlay = document.getElementById('towerClearOverlay');
            overlay.classList.add('active');
            const canvas = document.getElementById('towerClearCanvas');
            startTowerClearParticles(canvas);
        });
    }

    function closeTowerClear() {
        if (_towerClearAnimHandle) cancelAnimationFrame(_towerClearAnimHandle);
        document.getElementById('towerClearOverlay').classList.remove('active');
        updateStatusBarTitle();
        if (_towerClearResolve) { _towerClearResolve(); _towerClearResolve = null; }
    }

    function getFloorLabel(maxFloor) {
        if (!maxFloor || maxFloor === 0) return "";
        if (maxFloor >= 15) return { text: "完全制覇者", color: "#ffd700", shadow: "#ff00ff" };
        if (maxFloor >= 13) return { text: `${maxFloor}層到達`, color: "#ff00ff", shadow: "#9900ff" };
        if (maxFloor >= 10) return { text: `${maxFloor}層到達`, color: "#ff6600", shadow: "#ff0000" };
        if (maxFloor >= 7)  return { text: `${maxFloor}層到達`, color: "#00ffcc", shadow: "#007799" };
        return { text: `${maxFloor}層到達`, color: "#aaaaaa", shadow: "#444444" };
    }

    function loadUsers() {
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        const selector = document.getElementById("userSelector");
        const area = document.getElementById("existingUserArea");
        const names = Object.keys(allUsers);
        
        if (names.length > 0) {
            area.style.display = "block";
            selector.innerHTML = names.map(n => {
                const label = getFloorLabel(allUsers[n].maxFloor || 0);
                if (label) {
                    return `<option value="${n}" style="color:${label.color}; font-weight:bold;">[${label.text}] ${n}</option>`;
                }
                return `<option value="${n}">${n}</option>`;
            }).join("");

            // ラベルをセレクタの上に別途テキスト表示（option内の装飾はブラウザ依存なので）
            selector.onchange = function() { renderUserBadge(allUsers); };
            renderUserBadge(allUsers);
        } else {
            area.style.display = "none";
        }
    }

    function renderUserBadge(allUsers) {
        const selector = document.getElementById("userSelector");
        const name = selector.value;
        const existing = document.getElementById("userFloorBadge");
        if (existing) existing.remove();
        const existingTitle = document.getElementById("userTitleBadge");
        if (existingTitle) existingTitle.remove();

        if (!name || !allUsers[name]) return;
        const label = getFloorLabel(allUsers[name].maxFloor || 0);
        if (label) {
            const badge = document.createElement("div");
            badge.id = "userFloorBadge";
            badge.style.cssText = `
                text-align:center; margin:-5px 0 8px 0; font-weight:900; font-size:15px;
                color:${label.color}; text-shadow: 0 0 8px ${label.shadow};
                letter-spacing:2px; animation: badge-pulse 1.5s infinite alternate;
            `;
            badge.innerText = `[ ${label.text} ]`;
            selector.parentNode.insertBefore(badge, selector.nextSibling);
        }

        // 称号表示
        const udata = allUsers[name];
        const activeTitle = udata.titles && udata.titles.active;
        if (activeTitle) {
            const titleDef = TITLE_DEFS.find(t => t.id === activeTitle);
            if (titleDef) {
                const titleBadge = document.createElement("div");
                titleBadge.id = "userTitleBadge";
                titleBadge.style.cssText = `
                    text-align:center; margin:2px 0 6px 0; font-size:13px; font-weight:bold;
                    color:#ff88ff; text-shadow: 0 0 8px #ff00ff; letter-spacing:1px;
                `;
                titleBadge.innerText = `${titleDef.icon} ${titleDef.name}`;
                // floorBadgeの後 or selectorの後に挿入
                const floorBadge = document.getElementById("userFloorBadge");
                const insertAfter = floorBadge || selector;
                insertAfter.parentNode.insertBefore(titleBadge, insertAfter.nextSibling);
            }
        }
    }

    function registerUser() {
        const name = document.getElementById("userNameInput").value.trim();
        if (!name) return alert("名前を入力してください");
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        if (allUsers[name]) return alert("その名前は既に使用されています");
        
        currentUser = name;
        userData = { stones: 30000, totalDraws: 0, myBox: {}, bannedUnits: [], maxFloor: 0 };
        saveToLocal();
        startGame();
    }

    function loginSelected() {
        const name = document.getElementById("userSelector").value;
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        currentUser = name;
        userData = allUsers[name];
        if(!userData.bannedUnits) userData.bannedUnits = [];
        if(userData.maxFloor === undefined) userData.maxFloor = 0;
        startGame();
    }

    function logout() { location.reload(); }

    function resetUserData() {
        if (!confirm(`ユーザー「${currentUser}」のデータを完全に削除しますか？\nこの操作は取り消せません。`)) return;
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        if (allUsers[currentUser]) { delete allUsers[currentUser]; }
        localStorage.setItem("gacha_users", JSON.stringify(allUsers));
        alert("データをリセットしました。タイトルに戻ります。");
        logout();
    }

    window.onload = loadUsers;

    // ==========================================
    // 音響・演出管理
    // ==========================================
    let audioCtx;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    // ガチャ用BGM
    let bgmNormal = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3');
    let bgmEpic = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3');
    let bgmFever = new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3');
    bgmNormal.loop = bgmEpic.loop = bgmFever.loop = true;
    bgmNormal.volume = bgmEpic.volume = 0.3; bgmFever.volume = 0.5;

    // バトル用BGM
    let bgmBattle = new Audio();
    bgmBattle.loop = true;
    bgmBattle.volume = 0.4;
    const bgmList = {
        f1: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3",
        f4: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3",
        f7: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3",
        f10: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3",
        f13: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3",
        f14: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-12.mp3",
        f15: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-14.mp3"
    };

    function startBattleBgm() {
        let selectedUrl = bgmList.f1;
        if (currentFloor >= 15) selectedUrl = bgmList.f15;
        else if (currentFloor >= 14) selectedUrl = bgmList.f14;
        else if (currentFloor >= 13) selectedUrl = bgmList.f13;
        else if (currentFloor >= 10) selectedUrl = bgmList.f10;
        else if (currentFloor >= 7) selectedUrl = bgmList.f7;
        else if (currentFloor >= 4) selectedUrl = bgmList.f4;
        // 前回と同じURLなら再生位置を保ちつつ再生（変わった場合は最初から）
        if (bgmBattle.src !== selectedUrl) {
            bgmBattle.src = selectedUrl;
            bgmBattle.load();
        }
        // canplaythrough で確実に再生開始
        const tryPlay = () => {
            bgmBattle.play().catch(e => {
                // ユーザー操作が必要な環境では次のクリックで再生
                const resume = () => {
                    bgmBattle.play().catch(() => {});
                    document.removeEventListener('click', resume);
                    document.removeEventListener('touchstart', resume);
                };
                document.addEventListener('click', resume, { once: true });
                document.addEventListener('touchstart', resume, { once: true });
            });
        };
        if (bgmBattle.readyState >= 3) {
            tryPlay();
        } else {
            bgmBattle.addEventListener('canplay', tryPlay, { once: true });
        }
    }
    function stopBattleBgm() { bgmBattle.pause(); }

    // ========== 勝利・敗北 独自効果音 ==========
    function playBattleResultSfx(isVictory) {
        if (!audioCtx) return;
        if (isVictory) {
            // 勝利SE：明るいファンファーレ風
            const notes = [523, 659, 784, 1047, 784, 1047, 1319];
            const times = [0, 0.12, 0.24, 0.38, 0.55, 0.65, 0.78];
            notes.forEach((freq, idx) => {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = idx < 3 ? 'square' : 'sine';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime + times[idx]);
                g.gain.setValueAtTime(0, audioCtx.currentTime + times[idx]);
                g.gain.linearRampToValueAtTime(0.22, audioCtx.currentTime + times[idx] + 0.04);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + times[idx] + 0.38);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime + times[idx]);
                osc.stop(audioCtx.currentTime + times[idx] + 0.4);
            });
            // キラキラ上昇音
            setTimeout(() => {
                [1047, 1319, 1568, 2093].forEach((freq, idx) => {
                    const osc2 = audioCtx.createOscillator();
                    const g2 = audioCtx.createGain();
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(freq, audioCtx.currentTime + idx * 0.08);
                    g2.gain.setValueAtTime(0.15, audioCtx.currentTime + idx * 0.08);
                    g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + idx * 0.08 + 0.3);
                    osc2.connect(g2); g2.connect(audioCtx.destination);
                    osc2.start(audioCtx.currentTime + idx * 0.08);
                    osc2.stop(audioCtx.currentTime + idx * 0.08 + 0.35);
                });
            }, 900);
        } else {
            // 敗北SE：重く沈む音
            const defeatNotes = [220, 185, 155, 130];
            const defTimes = [0, 0.22, 0.46, 0.72];
            defeatNotes.forEach((freq, idx) => {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime + defTimes[idx]);
                osc.frequency.linearRampToValueAtTime(freq * 0.85, audioCtx.currentTime + defTimes[idx] + 0.35);
                g.gain.setValueAtTime(0.18, audioCtx.currentTime + defTimes[idx]);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + defTimes[idx] + 0.55);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime + defTimes[idx]);
                osc.stop(audioCtx.currentTime + defTimes[idx] + 0.6);
            });
            // 低い残響
            setTimeout(() => {
                const osc3 = audioCtx.createOscillator();
                const g3 = audioCtx.createGain();
                osc3.type = 'sine';
                osc3.frequency.setValueAtTime(65, audioCtx.currentTime);
                osc3.frequency.linearRampToValueAtTime(40, audioCtx.currentTime + 1.2);
                g3.gain.setValueAtTime(0.25, audioCtx.currentTime);
                g3.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
                osc3.connect(g3); g3.connect(audioCtx.destination);
                osc3.start(audioCtx.currentTime);
                osc3.stop(audioCtx.currentTime + 1.6);
            }, 400);
        }
    }

    function updateVolume(v) { 
        bgmNormal.volume = bgmEpic.volume = v; 
        bgmFever.volume = v * 1.5; 
        bgmBattle.volume = v * 1.3;
    }

    // ==========================================
    // ビュー切り替え
    // ==========================================

    // ========== 開発者モード ==========
    const DEV_ACCOUNT = "dev";  // 開発者アカウント名

    function isDev() { return currentUser === DEV_ACCOUNT; }

    function initDevMode() {
        const isDevUser = isDev();
        document.getElementById("devBadge").style.display = isDevUser ? "block" : "none";
        document.getElementById("devToggleBtn").style.display = isDevUser ? "block" : "none";
        if (!isDevUser) {
            document.getElementById("devPanel").classList.remove("open");
        } else {
            buildDevCharGrid();
            buildDevKakuseiSelect();
        }
    }

    function toggleDevPanel() {
        if (!isDev()) return;
        const panel = document.getElementById("devPanel");
        panel.classList.toggle("open");
        if (panel.classList.contains("open")) {
            buildDevCharGrid();
            buildDevKakuseiSelect();
            buildDevLbSelect();
        }
    }

    function switchDevTab(tabName, el) {
        document.querySelectorAll(".dev-tab").forEach(t => t.classList.remove("active"));
        document.querySelectorAll(".dev-tab-content").forEach(c => c.classList.remove("active"));
        el.classList.add("active");
        document.getElementById("devTab-" + tabName).classList.add("active");
    }

    function buildDevCharGrid() {
        const grid = document.getElementById("devCharGrid");
        grid.innerHTML = "";
        const rarityColors = { UR: '#ff4444', LR: '#ff00ff', SSR: '#ffd700', SR: '#00ffff', R: '#cd7f32' };
        gachaData.forEach(group => {
            group.items.forEach(item => {
                const btn = document.createElement("button");
                btn.className = "dev-char-btn";
                btn.style.borderColor = rarityColors[group.rarity] || '#444';
                btn.innerHTML = `<span class="dev-icon">${item.icon}</span><span class="dev-rarity" style="color:${rarityColors[group.rarity]}">${group.rarity}</span><span class="dev-name">${item.name}</span>`;
                btn.onclick = () => devGetChar(item.name, group);
                grid.appendChild(btn);
            });
        });
    }

    function devGetChar(charName, group) {
        if (!isDev()) return;
        if (userData.myBox[charName] === undefined) {
            userData.myBox[charName] = 0;
        } else if (group.canLimitBreak && userData.myBox[charName] < 10) {
            userData.myBox[charName]++;
        }
        saveToLocal();
        updateBoxDisplay();
        buildDevLbSelect();
        // 取得フィードバック
        const grid = document.getElementById("devCharGrid");
        [...grid.querySelectorAll(".dev-char-btn")].forEach(btn => {
            if (btn.querySelector(".dev-name") && btn.querySelector(".dev-name").textContent === charName) {
                btn.style.background = "#2a0040";
                btn.style.borderColor = "#ff00ff";
                setTimeout(() => { btn.style.background = ""; btn.style.borderColor = ""; buildDevCharGrid(); }, 600);
            }
        });
    }

    function buildDevKakuseiSelect() {
        const sel = document.getElementById("devKakuseiChar");
        if (!sel) return;
        sel.innerHTML = '<option value="">ランダム</option>';
        // UR・LRのみ（覚醒演出用）
        ["UR", "LR"].forEach(rarity => {
            const group = gachaData.find(g => g.rarity === rarity);
            if (!group) return;
            const optgroup = document.createElement("optgroup");
            optgroup.label = rarity;
            group.items.forEach(item => {
                const opt = document.createElement("option");
                opt.value = item.name + "__" + rarity;
                opt.textContent = item.icon + " " + item.name;
                optgroup.appendChild(opt);
            });
            sel.appendChild(optgroup);
        });
        // effectTypeセレクタのonchangeを設定
        const effectSel = document.getElementById("devEffectType");
        if (effectSel) {
            effectSel.onchange = function() {
                devForcedEffect = this.value;
                const status = document.getElementById("devEffectStatus");
                if (status) {
                    if (this.value) {
                        status.textContent = `✅ 次のガチャで「${this.options[this.selectedIndex].textContent}」が発動します`;
                        status.style.color = '#ff0080';
                    } else {
                        status.textContent = '🎯 ガチャボタンを押すと設定した演出が発動します';
                        status.style.color = '#00ffcc';
                    }
                }
            };
        }
    }

    async function devFireKakusei(forceRarity) {
        if (!isDev()) return;
        const sel = document.getElementById("devKakuseiChar");
        const val = sel ? sel.value : '';
        let charName, rarity;
        if (val && val.includes("__")) {
            [charName, rarity] = val.split("__");
        } else {
            rarity = forceRarity;
        }
        const group = gachaData.find(g => g.rarity === rarity);
        if (!group) return;
        let item;
        if (charName) {
            item = group.items.find(i => i.name === charName);
        }
        if (!item) item = group.items[Math.floor(Math.random() * group.items.length)];
        // パネルを閉じてから演出
        document.getElementById("devPanel").classList.remove("open");
        initAudio();
        bgmEpic.pause(); bgmNormal.pause(); bgmFever.pause();
        await showKakusei(item, rarity);
        bgmNormal.play().catch(() => {});
    }

    // 開発者モード：強制演出をガチャに適用するためのヘルパー
    function getDevForcedChar(effectType) {
        const sel = document.getElementById("devKakuseiChar");
        const val = sel ? sel.value : '';
        let charName, rarity;
        if (val && val.includes("__")) {
            [charName, rarity] = val.split("__");
        }
        // デフォルトレアリティ
        if (!rarity) {
            if (effectType === 'kakusei_lr' || effectType === 'lr_flash') rarity = 'LR';
            else rarity = 'UR';
        }
        const group = gachaData.find(g => g.rarity === rarity);
        if (!group) return null;
        let item = charName ? group.items.find(i => i.name === charName) : null;
        if (!item) item = group.items[Math.floor(Math.random() * group.items.length)];
        return { item, group, rarity };
    }

    function buildDevLbSelect() {
        const sel = document.getElementById("devLbChar");
        const prev = sel.value;
        sel.innerHTML = '<option value="">所持キャラを選択...</option>';
        gachaData.forEach(group => {
            if (!group.canLimitBreak) return;
            group.items.forEach(item => {
                if (userData.myBox[item.name] === undefined) return;
                const opt = document.createElement("option");
                opt.value = item.name;
                opt.textContent = item.icon + " " + item.name + " [LB" + userData.myBox[item.name] + "]";
                sel.appendChild(opt);
            });
        });
        if (prev) sel.value = prev;
        updateDevLbDisplay();
    }

    function updateDevLbDisplay() {
        const sel = document.getElementById("devLbChar");
        const numInput = document.getElementById("devLbNum");
        const status = document.getElementById("devLbStatus");
        const name = sel.value;
        if (!name || userData.myBox[name] === undefined) {
            numInput.value = 0;
            status.textContent = "";
            return;
        }
        numInput.value = userData.myBox[name];
        status.textContent = `現在 ${name} の凸数: ${userData.myBox[name]} / 10`;
    }

    function devSetLimitBreak(forceVal) {
        if (!isDev()) return;
        const sel = document.getElementById("devLbChar");
        const name = sel.value;
        if (!name) { alert("キャラを選択してください"); return; }
        if (userData.myBox[name] === undefined) { alert("そのキャラは未所持です。先にキャラ取得タブで取得してください。"); return; }
        const val = forceVal !== undefined ? forceVal : parseInt(document.getElementById("devLbNum").value);
        if (isNaN(val) || val < 0 || val > 10) { alert("0〜10の値を入力してください"); return; }
        userData.myBox[name] = val;
        saveToLocal();
        updateBoxDisplay();
        buildDevLbSelect();
        document.getElementById("devLbStatus").textContent = `✔ ${name} の凸を ${val} に設定しました！`;
    }

    function startGame() {
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("gachaView").style.display = "flex";
        
        document.getElementById("activeUserNameGacha").innerText = currentUser;
        if (!userData.titles) userData.titles = { unlocked: [], active: null };
        if (!userData.totalPlaySec) userData.totalPlaySec = 0;
        if (!userData.totalStonesEarned) userData.totalStonesEarned = userData.stones || 0;
        if (!userData.pvpBattleCount) userData.pvpBattleCount = 0;
        if (!userData.pvpWinCount) userData.pvpWinCount = 0;
        // プレイ時間計測
        if (!window._playTimeInterval) {
            window._playTimeInterval = setInterval(() => {
                if (!userData) return;
                userData.totalPlaySec = (userData.totalPlaySec || 0) + 5;
                saveToLocal();
                checkAndUnlockTitles(false);
            }, 5000);
        }
        updateUI();
        updateBoxDisplay();
        updatePickupBanners();
        initDevMode();
        checkAndUnlockTitles(true);
        updateStatusBarTitle();
        initAudio();
        bgmNormal.play().catch(() => {});
    }

    function switchToBattle() {
        document.getElementById('gachaView').style.display = 'none';
        document.getElementById('battleView').style.display = 'flex';
        
        bgmNormal.pause(); bgmEpic.pause(); bgmFever.pause();
        
        if (!userData.bannedUnits) userData.bannedUnits = [];
        document.getElementById('activeUserNameBattle').innerText = currentUser;
        
        setupFloor();
        renderParty();
    }

    function switchToGacha() {
        if (isBattleRunning) return alert("戦闘中は戻れません！");
        
        document.getElementById('battleView').style.display = 'none';
        document.getElementById('gachaView').style.display = 'flex';
        
        document.body.style.backgroundColor = '#050505';
        stopBattleBgm();
        bgmNormal.play().catch(()=>{});
        
        updateUI();
        updateBoxDisplay();
    }

    // ==========================================
    // ガチャ機能
    // ==========================================
    function openSettings() {
        document.getElementById("settingsModal").style.display = "flex";
        // 魔王の城バトル中なら一時停止する
        if (isBattleRunning && !isPaused) {
            isPaused = true;
            const overlay = document.getElementById("pauseOverlay");
            if (overlay) overlay.classList.add("active");
            const btn = document.getElementById("pauseBtn");
            if (btn) { btn.textContent = "▶ 再開"; btn.style.background = "linear-gradient(#27ae60,#1e8449)"; }
            bgmBattle.pause();
            const logSrc = document.getElementById("battleLog");
            const logDest = document.getElementById("pauseLogArea");
            if (logSrc && logDest) { logDest.innerHTML = logSrc.innerHTML || ""; logDest.scrollTop = logDest.scrollHeight; }
        }
    }
    function closeSettings() {
        document.getElementById("settingsModal").style.display = "none";
        // 魔王の城バトル中（一時停止中）なら再開する
        if (isBattleRunning && isPaused) {
            isPaused = false;
            const overlay = document.getElementById("pauseOverlay");
            if (overlay) overlay.classList.remove("active");
            const btn = document.getElementById("pauseBtn");
            if (btn) { btn.textContent = "⏸ 一時停止"; btn.style.background = "linear-gradient(#f39c12, #e67e22)"; }
            bgmBattle.play().catch(() => {});
        }
    }
    function openGameDescription() { document.getElementById("gameDescModal").style.display = "flex"; }
    function closeGameDescription() { document.getElementById("gameDescModal").style.display = "none"; }

    function openRateModal(gachaType) {
        const modal = document.getElementById("rateModal");
        const body = document.getElementById("rateModalBody");
        const title = document.getElementById("rateModalTitle");
        const note = document.getElementById("rateModalNote");

        // タイトル設定
        if (gachaType === 'standard') {
            title.textContent = "📊 通常召喚 排出率";
            note.style.display = 'none';
        } else if (gachaType === 'lr') {
            title.textContent = "📊 LRピックアップ 排出率";
            note.style.display = '';
        } else {
            title.textContent = "📊 URピックアップ 排出率";
            note.style.display = '';
        }

        // ピックアップキャラ取得
        const pickupLR = (gachaType === 'lr') ? getPickupChar('LR') : null;
        const pickupUR = (gachaType === 'ur') ? getPickupChar('UR') : null;

        // フィーバーなし前提で計算
        const totalProb = gachaData.reduce((s, g) => s + g.prob, 0);

        const rarityColors = { UR: '#ff4444', LR: '#ff00ff', SSR: '#ffd700', SR: '#00ffff', R: '#cd7f32' };
        const rarityBg = { UR: '#2a0000', LR: '#1a0020', SSR: '#1a1500', SR: '#001a1a', R: '#1a1000' };

        let html = '';
        for (const group of gachaData) {
            const rarity = group.rarity;
            const rarityRate = (group.prob / totalProb * 100).toFixed(2);
            const color = rarityColors[rarity] || '#fff';
            const bg = rarityBg[rarity] || '#111';

            // このレアのピックアップキャラ
            let pickupChar = null;
            if (gachaType === 'lr' && rarity === 'LR') pickupChar = pickupLR;
            if (gachaType === 'ur' && rarity === 'UR') pickupChar = pickupUR;

            // 各キャラの排出率計算（重み付き）
            // ピックアップあり: totalWeight = items.length + 3 (4倍-1倍の差分)
            // ピックアップなし: 均等
            const hasPickup = !!pickupChar;
            const n = group.items.length;
            const totalWeight = hasPickup ? (n + 3) : n;
            const rarityRateBase = group.prob / totalProb * 100;

            html += `<div class="rate-rarity-block">
                <div class="rate-rarity-header" style="background:${bg}; color:${color};">
                    <span>${rarity}</span>
                    <span>${rarityRate}%</span>
                </div>`;

            for (const item of group.items) {
                const isPickupChar = hasPickup && pickupChar && item.name === pickupChar.name;
                let charWeight = hasPickup ? (isPickupChar ? 4 : 1) : 1;
                const charRate = (rarityRateBase * charWeight / totalWeight).toFixed(3);
                html += `<div class="rate-char-row ${isPickupChar ? 'pickup-row' : ''}">
                    <div class="rate-char-name">
                        <span>${item.icon}</span>
                        <span>${item.name}</span>
                        ${isPickupChar ? '<span class="rate-pu-badge">PU</span>' : ''}
                    </div>
                    <span class="rate-pct">${charRate}%</span>
                </div>`;
            }
            html += `</div>`;
        }

        body.innerHTML = html;
        modal.style.display = 'flex';
    }

    function closeRateModal() {
        document.getElementById("rateModal").style.display = "none";
    }

    function openBattleSettings() { document.getElementById("battleSettingsModal").style.display = "flex"; }
    function closeBattleSettings() { document.getElementById("battleSettingsModal").style.display = "none"; }

    function togglePause() {
        isPaused = !isPaused;
        const overlay = document.getElementById("pauseOverlay");
        const btn = document.getElementById("pauseBtn");
        if (isPaused) {
            overlay.classList.add("active");
            btn.textContent = "▶ 再開";
            btn.style.background = "linear-gradient(#27ae60,#1e8449)";
            bgmBattle.pause();
            // バトルログをコピーして表示
            const logSrc = document.getElementById("battleLog");
            const logDest = document.getElementById("pauseLogArea");
            if (logSrc && logDest) {
                logDest.innerHTML = logSrc.innerHTML || '<div style="color:#555;">ログはまだありません</div>';
                logDest.scrollTop = logDest.scrollHeight;
            }
            // 一時停止内スライダーの値を現在のスピードに同期
            const speedRevMap = {0.5:1, 1.0:2, 2.0:3, 4.0:4, 8.0:5};
            const pauseSlider = document.getElementById("pauseSpeedSlider");
            const pauseLabel = document.getElementById("pauseSpeedLabel");
            if (pauseSlider) pauseSlider.value = speedRevMap[battleSpeedMultiplier] || 2;
            if (pauseLabel) pauseLabel.innerText = `x${battleSpeedMultiplier}`;
            // BGM音量スライダーも同期
            const pauseVol = document.getElementById("pauseVolumeSlider");
            if (pauseVol && bgmBattle) pauseVol.value = bgmBattle.volume;
        } else {
            overlay.classList.remove("active");
            btn.textContent = "⏸ 一時停止";
            btn.style.background = "linear-gradient(#f39c12, #e67e22)";
            bgmBattle.play().catch(()=>{});
        }
    }

    function waitIfPaused() {
        if (!isPaused) return Promise.resolve();
        return new Promise(resolve => {
            const check = setInterval(() => {
                if (!isPaused) { clearInterval(check); resolve(); }
            }, 100);
        });
    }

    function useHeroOrder() {
        if (!isBattleRunning) return;
        if (heroOrderUsed) return;
        heroOrderUsed = true;
        forceSkillNextTurn = true;
        const btn = document.getElementById("orderBtn");
        btn.disabled = true;
        btn.textContent = "📯 英傑の号令（使用済み）";
        log(`<span style="color:#cc88ff; font-weight:bold; font-size:13px;">📯 英傑の号令！次のターン、全英傑が奥義を解放する！</span>`);
        showOrderOverlay();
    }

    function updateBattleSpeed(val) {
        const speedMap = {1: 0.5, 2: 1.0, 3: 2.0, 4: 4.0, 5: 8.0};
        battleSpeedMultiplier = speedMap[val] || 1.0;
        document.getElementById("battleSpeedLabel").innerText = `x${battleSpeedMultiplier}`;
        // 一時停止オーバーレイ内のスライダー/ラベルも同期
        const pauseSlider = document.getElementById("pauseSpeedSlider");
        const pauseLabel = document.getElementById("pauseSpeedLabel");
        if (pauseSlider) pauseSlider.value = val;
        if (pauseLabel) pauseLabel.innerText = `x${battleSpeedMultiplier}`;
    }

    function updateBattleSpeedFromPause(val) {
        const speedMap = {1: 0.5, 2: 1.0, 3: 2.0, 4: 4.0, 5: 8.0};
        battleSpeedMultiplier = speedMap[val] || 1.0;
        document.getElementById("pauseSpeedLabel").innerText = `x${battleSpeedMultiplier}`;
        // バトル設定モーダル内のスライダー/ラベルも同期
        const mainLabel = document.getElementById("battleSpeedLabel");
        if (mainLabel) mainLabel.innerText = `x${battleSpeedMultiplier}`;
        // メインのスライダー値も同期（存在すれば）
        const mainSlider = document.querySelector('#battleSettingsModal input[type=range]');
        if (mainSlider) mainSlider.value = val;
    }

    function updateUI() {
        // --- ガチャ画面のUI更新 ---
        if (document.getElementById("stoneCountGacha")) {
            document.getElementById("stoneCountGacha").innerText = userData.stones.toLocaleString();
            document.getElementById("pityCount").innerText = pityThreshold - (userData.totalDraws % pityThreshold);
        }
        
        // --- バトル画面のUI更新 ---
        if (document.getElementById("stoneCountBattle")) {
            document.getElementById("stoneCountBattle").innerText = userData.stones.toLocaleString();
        }
        
        // --- ボスのHP表記の修正箇所 ---
        const bossHpBar = document.getElementById("bossHpBar");
        const bossHpText = document.getElementById("bossHpText");
        
        if (bossHpBar && bossHpText && typeof bossHp !== "undefined" && typeof bossMaxHp !== "undefined") {
            const hpPercent = (bossHp / bossMaxHp) * 100;
            bossHpBar.style.width = Math.max(0, hpPercent) + "%";
            bossHpText.innerText = `HP: ${Math.max(0, Math.floor(bossHp)).toLocaleString()} / ${bossMaxHp.toLocaleString()}`;
        }
    }

    function playSE(type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if(type === 'ur' || type === 'lr' || type === 'upgrade' || type === 'fever') {
            osc.frequency.setValueAtTime(type === 'fever' ? 880 : (type === 'ur' ? 150 : 300), audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.6);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        } else {
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        }
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        osc.start(); osc.stop(audioCtx.currentTime + 0.5);
    }

    async function playGacha(times) {
        if (userData.stones < times * 300) return alert("聖晶石が足りません");
        const btn = document.getElementById("gachaBtn");
        btn.disabled = true;

        // 開発者モード：強制演出を取得してリセット
        const forcedEffect = isDev() ? devForcedEffect : '';
        if (forcedEffect) {
            devForcedEffect = '';
            const effectSel = document.getElementById("devEffectType");
            if (effectSel) effectSel.value = '';
            const status = document.getElementById("devEffectStatus");
            if (status) { status.textContent = '🎯 ガチャボタンを押すと設定した演出が発動します'; status.style.color = '#00ffcc'; }
        }

        userData.stones -= times * 300;
        if (!userData.totalStonesEarned) userData.totalStonesEarned = 0;
        
        const grid = document.getElementById("resultGrid");
        grid.innerHTML = "";

        // 強制フィーバーまたは通常フィーバー
        const isFever = (forcedEffect === 'fever') || (!forcedEffect && Math.random() < 0.04);
        const mainBanner = document.getElementById("mainBanner");
        if (isFever) {
            mainBanner.style.display = '';
            document.getElementById('banner-standard').style.display = 'none';
            document.getElementById('banner-lr').style.display = 'none';
            document.getElementById('banner-ur').style.display = 'none';
            mainBanner.classList.add("fever-mode");
            document.getElementById("bannerTitle").innerText = "🔥 FEVER MODE 🔥";
            playSE('fever');
            document.getElementById("flash").className = "flash-fever";
            bgmNormal.pause(); bgmEpic.pause(); bgmFever.play().catch(()=>{});
            await new Promise(r => setTimeout(r, 1500));
        } else {
            mainBanner.style.display = 'none';
            mainBanner.classList.remove("fever-mode");
            bgmFever.pause();
        }

        let hasUR = false;
        const results = [];
        const cardElements = [];

        for (let i = 0; i < times; i++) {
            userData.totalDraws++;
            let res;
            if (userData.totalDraws % pityThreshold === 0) {
                const highRarityIdx = Math.random() < 0.33 ? 0 : 1;
                const group = gachaData[highRarityIdx];
                res = { item: group.items[Math.floor(Math.random() * group.items.length)], rarityInfo: group };
            } else {
                res = draw(isFever);
            }
            results.push(res);
            if (res.rarityInfo.rarity === "UR") hasUR = true;
        }

        // 強制UR/LR（flash系）の場合は最初のカードを差し替え
        if (forcedEffect === 'ur_flash' || forcedEffect === 'lr_flash') {
            const fRarity = forcedEffect === 'ur_flash' ? 'UR' : 'LR';
            const fInfo = getDevForcedChar(forcedEffect);
            if (fInfo) {
                results[0] = { item: fInfo.item, rarityInfo: fInfo.group, isPickup: false };
                if (fRarity === 'UR') hasUR = true;
            }
        }

        // 強制昇格演出の場合は最後のカードを昇格候補として準備（非UR/LRになるようにdrawをやり直す）
        let forceUpgradeIdx = -1;
        if (forcedEffect === 'upgrade') {
            // 昇格対象を確実にするためresults内の非UR/LRを探す
            for (let i = results.length - 1; i >= 0; i--) {
                const r = results[i].rarityInfo.rarity;
                if (r !== 'UR' && r !== 'LR') { forceUpgradeIdx = i; break; }
            }
            if (forceUpgradeIdx === -1) {
                // 全部UR/LRなら最後を強制的にSSRに
                const ssrGroup = gachaData.find(g => g.rarity === 'SSR');
                results[results.length - 1] = { item: ssrGroup.items[0], rarityInfo: ssrGroup };
                forceUpgradeIdx = results.length - 1;
            }
        }

        if (hasUR && !isFever) {
            bgmNormal.pause(); bgmEpic.currentTime = 0; bgmEpic.play().catch(() => {});
        } else if(!isFever) {
            bgmEpic.pause(); bgmNormal.play().catch(() => {});
        }

        updateUI();

        // ========== 覚醒確定演出 ==========
        // 強制kakusei演出 OR 通常の1%確率発動
        if (!isFever && (forcedEffect === 'kakusei_lr' || forcedEffect === 'kakusei_ur')) {
            const kakuRarity = forcedEffect === 'kakusei_ur' ? 'UR' : 'LR';
            const fInfo = getDevForcedChar(forcedEffect);
            const kakuChar = fInfo ? fInfo.item : getPickupChar(kakuRarity);
            if (kakuChar) {
                const kakuGroup = gachaData.find(g => g.rarity === kakuRarity);
                results[0] = { item: kakuChar, rarityInfo: kakuGroup, isPickup: true, isKakusei: true };
                initAudio();
                bgmEpic.pause(); bgmNormal.pause();
                await showKakusei(kakuChar, kakuRarity);
                if (kakuRarity === 'UR') {
                    bgmEpic.currentTime = 0; bgmEpic.play().catch(() => {});
                } else {
                    bgmNormal.play().catch(() => {});
                }
            }
        } else if ((currentGachaType === 'lr' || currentGachaType === 'ur') && !isFever && !forcedEffect && Math.random() < 0.01) {
            const kakuRarity = currentGachaType === 'ur' ? 'UR' : 'LR';
            const kakuChar = getPickupChar(kakuRarity);
            if (kakuChar) {
                const kakuGroup = gachaData.find(g => g.rarity === kakuRarity);
                results[0] = { item: kakuChar, rarityInfo: kakuGroup, isPickup: true, isKakusei: true };
                initAudio();
                bgmEpic.pause(); bgmNormal.pause();
                await showKakusei(kakuChar, kakuRarity);
                if (kakuRarity === 'UR') {
                    bgmEpic.currentTime = 0; bgmEpic.play().catch(() => {});
                } else {
                    bgmNormal.play().catch(() => {});
                }
            }
        } else if (!isFever && !forcedEffect && Math.random() < 0.001) {
            // ========== 絶対覇者確定演出（0.1%） ==========
            // LR・URからランダムに5体を選び、ユーザーが1体選択
            const hashaCandidates = _buildHashaCandidates();
            _hashaSelectedItem = null;
            initAudio();
            bgmEpic.pause(); bgmNormal.pause();
            await showHasha(hashaCandidates);
            // 選択されたキャラを results[0] に設定
            if (_hashaSelectedItem) {
                results[0] = { item: _hashaSelectedItem.item, rarityInfo: _hashaSelectedItem.rarityInfo, isPickup: false, isKakusei: true };
                if (_hashaSelectedItem.rarityInfo.rarity === 'UR') hasUR = true;
            }
            if (hasUR) {
                bgmEpic.currentTime = 0; bgmEpic.play().catch(() => {});
            } else {
                bgmNormal.play().catch(() => {});
            }
        } else if (!isFever && forcedEffect === 'hasha') {
            // 開発者モード：強制覇者演出
            const hashaCandidates = _buildHashaCandidates();
            _hashaSelectedItem = null;
            initAudio();
            bgmEpic.pause(); bgmNormal.pause();
            await showHasha(hashaCandidates);
            if (_hashaSelectedItem) {
                results[0] = { item: _hashaSelectedItem.item, rarityInfo: _hashaSelectedItem.rarityInfo, isPickup: false, isKakusei: true };
                if (_hashaSelectedItem.rarityInfo.rarity === 'UR') hasUR = true;
            }
            if (hasUR) {
                bgmEpic.currentTime = 0; bgmEpic.play().catch(() => {});
            } else {
                bgmNormal.play().catch(() => {});
            }
        }

        for (let i = 0; i < times; i++) {
            const res = results[i];
            const charName = res.item.name;
            const rarity = res.rarityInfo.rarity;

            if (userData.myBox[charName] !== undefined) {
                if (res.rarityInfo.canLimitBreak && userData.myBox[charName] < 10) userData.myBox[charName]++;
            } else { userData.myBox[charName] = 0; }

            const card = document.createElement("div");
            card.className = "card";
            const pickupBadge = res.isKakusei
                ? `<div style="position:absolute;top:2px;left:2px;background:linear-gradient(135deg,#ff00ff,#ff6600);color:#fff;font-size:7px;font-weight:bold;padding:1px 4px;border-radius:3px;box-shadow:0 0 6px #ff00ff;animation:badge-pulse 0.6s infinite alternate;">覚醒!</div>`
                : res.isPickup
                ? `<div style="position:absolute;top:2px;left:2px;background:#ffd700;color:#000;font-size:7px;font-weight:bold;padding:1px 3px;border-radius:3px;">PU!</div>`
                : '';
            card.innerHTML = `<div class="card-back"></div>
                              <div class="card-front card-${rarity.toLowerCase()}" style="position:relative;">
                                ${pickupBadge}
                                <div class="icon-area" style="font-size:22px;">${res.item.icon}</div>
                                <div class="rarity-text" style="font-size:9px; font-weight:bold; margin-top:5px; color:#333;">${rarity}</div>
                              </div>`;
            card.onclick = () => showDetail(charName);
            grid.appendChild(card);
            cardElements.push({element: card, data: res});

            if (rarity === "UR" || rarity === "LR") {
                await new Promise(r => setTimeout(r, 800));
                playSE(rarity.toLowerCase());
                const flash = document.getElementById("flash");
                flash.className = rarity === "UR" ? "flash-ur" : "flash-lr";
                setTimeout(() => flash.className = "", 2500);
                await new Promise(r => setTimeout(r, 1200)); 
            } else {
                playSE('r');
                await new Promise(r => setTimeout(r, 400));
            }
            card.classList.add("is-open");
        }

        // 昇格演出（強制または通常確率）
        const doUpgrade = (forcedEffect === 'upgrade') || (!forcedEffect && !isFever && Math.random() < 0.01);
        if (doUpgrade) {
            // 強制昇格の場合は指定インデックス、通常はランダム
            let upgradable;
            if (forceUpgradeIdx >= 0) {
                upgradable = [cardElements[forceUpgradeIdx]];
            } else {
                upgradable = cardElements.filter(c => c.data.rarityInfo.rarity !== "UR" && c.data.rarityInfo.rarity !== "LR");
            }
            if (upgradable.length > 0) {
                const target = upgradable[Math.floor(Math.random() * upgradable.length)];
                const lrGroup = gachaData[1];
                const newItem = lrGroup.items[Math.floor(Math.random() * lrGroup.items.length)];
                target.element.classList.add("upgrading");
                playSE('upgrade');
                await new Promise(r => setTimeout(r, 1000));
                
                if (userData.myBox[target.data.item.name] > 0) userData.myBox[target.data.item.name]--;
                else delete userData.myBox[target.data.item.name];

                if (userData.myBox[newItem.name] !== undefined) {
                    if (userData.myBox[newItem.name] < 10) userData.myBox[newItem.name]++;
                } else { 
                    userData.myBox[newItem.name] = 0; 
                }

                const front = target.element.querySelector(".card-front");
                front.className = "card-front card-lr";
                front.querySelector(".icon-area").innerText = newItem.icon;
                front.querySelector(".rarity-text").innerText = "LR";
                target.element.onclick = () => showDetail(newItem.name);
                target.element.classList.remove("upgrading");
            }
        }

        saveToLocal();
        updateBoxDisplay();
        btn.disabled = false;
        checkAndUnlockTitles();
        // バナーをフィーバー後に元に戻す
        document.getElementById("mainBanner").style.display = 'none';
        document.getElementById("mainBanner").classList.remove("fever-mode");
        const activeBannerId = currentGachaType === 'lr' ? 'banner-lr' : currentGachaType === 'ur' ? 'banner-ur' : 'banner-standard';
        document.getElementById(activeBannerId).style.display = '';
    }

    // ピックアップ倍率: ピックアップキャラは同レア内で4倍の重みを持つ
    function draw(isFever) {
        const filteredData = isFever ? gachaData.slice(0, 3) : gachaData;

        // まずレアリティを決定
        let totalProb = 0;
        filteredData.forEach(g => totalProb += g.prob);
        const rand = Math.random() * totalProb;
        let current = 0;
        let chosenGroup = filteredData[filteredData.length - 1];
        for (const group of filteredData) {
            current += group.prob;
            if (rand <= current) { chosenGroup = group; break; }
        }

        // そのレア内でピックアップキャラを重み付き抽選
        const items = chosenGroup.items;
        let pickupItem = null;

        if (currentGachaType === 'lr' && chosenGroup.rarity === 'LR') {
            pickupItem = getPickupChar('LR');
        } else if (currentGachaType === 'ur' && chosenGroup.rarity === 'UR') {
            pickupItem = getPickupChar('UR');
        }

        if (pickupItem) {
            // ピックアップ: 対象キャラは通常の4倍の重み
            const totalWeight = items.length + 3; // +3 = 4倍 - 1倍の差分
            const r2 = Math.random() * totalWeight;
            if (r2 < 4) {
                return { item: pickupItem, rarityInfo: chosenGroup, isPickup: true };
            } else {
                // 残りをピックアップ以外から等確率で
                const others = items.filter(i => i.name !== pickupItem.name);
                const item = others[Math.floor(Math.random() * others.length)];
                return { item, rarityInfo: chosenGroup, isPickup: false };
            }
        }

        // 通常ガチャ: 等確率
        return { item: items[Math.floor(Math.random() * items.length)], rarityInfo: chosenGroup, isPickup: false };
    }

    // メビウス凸成長テーブル: 5凸で他UR6凸相当、6凸以降は同凸URを上回る
    const MEBIUS_MUL = [1.0, 1.50, 2.50, 4.00, 7.00, 15.454, 20.0, 27.0, 36.0, 50.0, 70.0];
    function getMebiusMul(lb) {
        return MEBIUS_MUL[Math.min(lb, 10)];
    }

    function getStatus(charName) {
        let base = null; let rarityInfo = null;
        for(const g of gachaData) {
            const item = g.items.find(i => i.name === charName);
            if(item) { base = item; rarityInfo = g; break; }
        }

        const limit = Math.min(userData.myBox[charName] || 0, 10);

        if (!rarityInfo.canLimitBreak) return { ...base, rarity: rarityInfo.rarity, color: rarityInfo.color, limit: 0, skillPower: base.baseVal };
        
        let statMultiplier, skillMultiplier;

        if (charName === "無限の可能性メビウス") {
            statMultiplier = getMebiusMul(limit);
            skillMultiplier = getMebiusMul(limit);
        } else {
            statMultiplier = Math.pow(1.2, limit);
            skillMultiplier = Math.pow(1.2, limit);
        }

        return { 
            ...base, 
            rarity: rarityInfo.rarity, 
            color: rarityInfo.color, 
            limit: limit, 
            hp: Math.floor(base.hp * statMultiplier), 
            atk: Math.floor(base.atk * statMultiplier), 
            skillPower: Math.floor(base.baseVal * skillMultiplier) 
        };
    }

    function updateBoxDisplay() {
        const container = document.getElementById("collectionContainer");
        container.innerHTML = '<h3 style="margin-top:0; color:#00ffcc; border-bottom:1px solid #333; padding-bottom:10px;">英傑図鑑</h3>';
        gachaData.forEach(group => {
            const section = document.createElement("div");
            section.className = "rarity-section";
            section.innerHTML = `<div class="rarity-label" style="background:${group.color}">${group.rarity}</div>`;
            const grid = document.createElement("div");
            grid.className = "collection-grid";
            group.items.forEach(item => {
                const isOwned = userData.myBox[item.name] !== undefined;
                const div = document.createElement("div");
                div.className = `box-item ${isOwned ? 'owned' : ''}`;
                if (isOwned) {
                    const stat = getStatus(item.name);
                    div.style.borderColor = group.color;
                    div.innerHTML = item.icon;
                    if(group.canLimitBreak && stat.limit > 0) div.innerHTML += `<div class="count-badge">LB${stat.limit}</div>`;
                    div.onclick = () => showDetail(item.name);
                } else { div.innerHTML = "?"; }
                grid.appendChild(div);
            });
            section.appendChild(grid);
            container.appendChild(section);
        });
    }

    function showDetail(charName) {
        const char = getStatus(charName);
        const modal = document.getElementById("modalContent");
        modal.classList.remove("lb-aura-1", "lb-aura-3", "lb-aura-5", "lb-aura-7", "evolve-10");
        
        modal.style.setProperty('--lb-color', char.color);
        modal.style.borderColor = char.color;

        if (char.limit >= 10) modal.classList.add("evolve-10");
        else if (char.limit >= 7) modal.classList.add("lb-aura-7");
        else if (char.limit >= 5) modal.classList.add("lb-aura-5");
        else if (char.limit >= 3) modal.classList.add("lb-aura-3");
        else if (char.limit >= 1) modal.classList.add("lb-aura-1");

        // ===== 凸リング演出 =====
        const ringsEl = document.getElementById("modalIconRings");
        ringsEl.innerHTML = "";
        ringsEl.style.setProperty('--lb-color', char.color);
        const lb = char.limit;
        if (lb >= 10) {
            // MAX凸：虹色三重リング
            ['lb-ring-max','lb-ring-max2','lb-ring-max3'].forEach(cls => {
                const r = document.createElement('div');
                r.className = 'lb-ring ' + cls;
                ringsEl.appendChild(r);
            });
            // 星スパーク（MAX専用）
            for (let i = 0; i < 12; i++) {
                const star = document.createElement('div');
                star.className = 'lb-star';
                const angle = (i / 12) * 360;
                const dist = 80 + Math.random() * 20;
                const x = 50 + Math.cos(angle * Math.PI / 180) * dist / 1.5;
                const y = 50 + Math.sin(angle * Math.PI / 180) * dist / 1.5;
                star.style.cssText = `--lb-color:${char.color}; left:${x}%; top:${y}%; width:${4+Math.random()*5}px; height:${4+Math.random()*5}px; transform:translate(-50%,-50%); animation-delay:${(i*0.12).toFixed(2)}s;`;
                ringsEl.appendChild(star);
            }
        } else if (lb >= 7) {
            ['lb-ring-7','lb-ring-7b','lb-ring-7c'].forEach(cls => {
                const r = document.createElement('div');
                r.className = 'lb-ring ' + cls;
                r.style.setProperty('--lb-color', char.color);
                ringsEl.appendChild(r);
            });
        } else if (lb >= 5) {
            ['lb-ring-5','lb-ring-5b','lb-ring-5c'].forEach(cls => {
                const r = document.createElement('div');
                r.className = 'lb-ring ' + cls;
                r.style.setProperty('--lb-color', char.color);
                ringsEl.appendChild(r);
            });
        } else if (lb >= 3) {
            ['lb-ring-3','lb-ring-3b'].forEach(cls => {
                const r = document.createElement('div');
                r.className = 'lb-ring ' + cls;
                r.style.setProperty('--lb-color', char.color);
                ringsEl.appendChild(r);
            });
        } else if (lb >= 1) {
            const r = document.createElement('div');
            r.className = 'lb-ring lb-ring-1';
            r.style.setProperty('--lb-color', char.color);
            ringsEl.appendChild(r);
        }

        document.getElementById("modalLimit").innerText = char.limit >= 10 ? "★MAX LIMIT BREAK★" : `LIMIT BREAK: ${char.limit}/10`;
        document.getElementById("modalRarity").innerText = char.rarity;
        document.getElementById("modalRarity").style.color = char.color;

        // アイコン表示
        const iconEmoji = document.getElementById("modalIconEmoji");
        if (iconEmoji) iconEmoji.textContent = char.icon;
        else document.getElementById("modalImg").innerHTML = `<div id="modalIconRings" style="--lb-color:${char.color}"></div><span id="modalIconEmoji">${char.icon}</span>`;

        document.getElementById("modalName").innerText = char.name;

        let baseItem;
        for(const g of gachaData) {
            baseItem = g.items.find(i => i.name === charName);
            if(baseItem) break;
        }

        const hpDiff = char.hp - baseItem.hp;
        const atkDiff = char.atk - baseItem.atk;
        const skillDiff = char.skillPower - baseItem.baseVal;

        if (char.limit > 0) {
            document.getElementById("modalHP").innerHTML = `${baseItem.hp.toLocaleString()}<span style="color:#00ffcc; font-size:0.8em;"> +${hpDiff.toLocaleString()}</span>`;
            document.getElementById("modalATK").innerHTML = `${baseItem.atk.toLocaleString()}<span style="color:#00ffcc; font-size:0.8em;"> +${atkDiff.toLocaleString()}</span>`;
            const skillValHtml = `${baseItem.baseVal.toLocaleString()}<span style="color:#00ffcc;">+${skillDiff.toLocaleString()}</span>`;
            document.getElementById("modalSkillDesc").innerHTML = char.sDesc.replace("{n}", skillValHtml);
        } else {
            document.getElementById("modalHP").innerText = char.hp.toLocaleString();
            document.getElementById("modalATK").innerText = char.atk.toLocaleString();
            document.getElementById("modalSkillDesc").innerText = char.sDesc.replace("{n}", char.skillPower.toLocaleString());
        }
        
        document.getElementById("modalSkillName").innerText = char.skill;
        document.getElementById("detailModal").style.display = "flex";
    }

    function closeModal() { document.getElementById("detailModal").style.display = "none"; }

    // ==========================================
    // バトル機能
    // ==========================================
    // ボスデータ：attacks=通常攻撃バリエーション(各{msg, mult}), skill={name, msg, effect}
    // effect: 'aoe'=全体攻撃(mult倍), 'drain'=吸収, 'debuff'=ATK下げ, 'regen'=自己回復, 'charge'=ATK強化
    const bossesByFloor = [
        { name: "門番：スケルトン・ガード", icon: "💀",
          attacks: [
            { msg: "骨の剣で斬りつける！", mult: 1.0 },
            { msg: "骨の盾で弾いて反撃！", mult: 0.8 },
            { msg: "骸骨投げ！複数の骨が飛んでくる！", mult: 1.2 }
          ],
          skill: { name: "死者の咆哮", msg: "💀 スケルトンが恐ろしい叫び声を上げた！全体に衝撃波！", effect: "aoe", mult: 1.5 }
        },
        { name: "森の略奪者：ハイ・ゴブリン", icon: "👺",
          attacks: [
            { msg: "錆びたナイフで刺す！", mult: 1.0 },
            { msg: "砂を目に投げつけてから攻撃！", mult: 0.9 },
            { msg: "集団攻撃！仲間を呼んで連撃！", mult: 1.3 }
          ],
          skill: { name: "略奪の暴走", msg: "👺 ゴブリンが狂ったように暴れ回る！全体に乱撃！", effect: "aoe", mult: 1.4 }
        },
        { name: "森の管理者：ティターニア", icon: "🧚‍♀️",
          attacks: [
            { msg: "妖精の粉をまき散らす！", mult: 1.0 },
            { msg: "幻惑の光で目を眩ませて攻撃！", mult: 0.9 },
            { msg: "自然の力で傷を癒した！（自己回復）", mult: 0.0, selfRegen: 0.1 }
          ],
          skill: { name: "森の呪縛", msg: "🧚‍♀️ ティターニアが森の力を解放！呪いの茨が全員を締め付ける！", effect: "aoe", mult: 1.6 }
        },
        { name: "真祖：ヴァンパイア", icon: "🧛",
          attacks: [
            { msg: "鋭い牙で噛みつく！（吸血）", mult: 1.0, drain: 0.5 },
            { msg: "バット変身して突進！", mult: 1.1 },
            { msg: "催眠の眼差し…！弱い者から攻撃！", mult: 1.2 }
          ],
          skill: { name: "血の洗礼", msg: "🧛 ヴァンパイアが翼を広げた！血の嵐が全体を襲う！", effect: "drain", mult: 1.8 }
        },
        { name: "大賢者：マーリン", icon: "🧙‍♀️",
          attacks: [
            { msg: "火球呪文を放つ！", mult: 1.0 },
            { msg: "呪縛の魔法！動きを封じて攻撃！", mult: 1.1 },
            { msg: "魔力を蓄えている…（次ターン強化）", mult: 0.5, charge: true }
          ],
          skill: { name: "大魔法陣", msg: "🧙‍♀️ マーリンが巨大な魔法陣を展開！全体に魔力の奔流！", effect: "aoe", mult: 2.0 }
        },
        { name: "ファンキーYUMA", icon: "🦹‍♂️",
          attacks: [
            { msg: "ファンキーな蹴りを繰り出す！", mult: 1.0 },
            { msg: "奇天烈なダンスで撹乱しながら攻撃！", mult: 0.9 },
            { msg: "超ファンキーパンチ！渾身の一撃！", mult: 1.4 }
          ],
          skill: { name: "ファンキーフィーバー", msg: "🦹‍♂️ YUMAがフィーバー状態に！全員に強烈なコンビネーション！", effect: "aoe", mult: 1.8 }
        },
        { name: "死人：フランケンYUMA", icon: "🧟",
          attacks: [
            { msg: "巨大な拳を叩きつける！", mult: 1.1 },
            { msg: "電撃でしびれさせて攻撃！", mult: 1.0 },
            { msg: "死体の腕を投げつける！（ランダム単体大ダメージ）", mult: 1.5, targetRandom: true }
          ],
          skill: { name: "ガルバニック・トルネード", msg: "🧟 フランケンYUMAに強力な電流が流れた！全体に電撃嵐！", effect: "aoe", mult: 2.0 }
        },
        { name: "呪われた鎧：リビングアーマー", icon: "🤖",
          attacks: [
            { msg: "重い剣で叩き斬る！", mult: 1.0 },
            { msg: "呪われた鎧が収縮し体当たり！", mult: 1.2 },
            { msg: "鎧の呪いが発動、防御無視攻撃！", mult: 1.3 }
          ],
          skill: { name: "呪縛の鉄壁", msg: "🤖 鎧の呪いが爆発！全体に呪いのダメージ＋ATK低下！", effect: "debuff", mult: 1.6 }
        },
        { name: "死を運ぶ者：デュラハン", icon: "🏇",
          attacks: [
            { msg: "首なし騎士が斬りかかる！", mult: 1.0 },
            { msg: "漆黒の剣で斬り払う！", mult: 1.2 },
            { msg: "死の刻印！最も体力の低い者に全力攻撃！", mult: 1.8, targetLowest: true }
          ],
          skill: { name: "死神の大鎌", msg: "🏇 デュラハンが大鎌を振り下ろす！全体に死の一薙ぎ！", effect: "aoe", mult: 2.2 }
        },
        { name: "氷結の女王：シヴァ", icon: "🧞‍♀️",
          attacks: [
            { msg: "絶対零度の吐息！", mult: 1.0 },
            { msg: "氷の槍を投げつける！", mult: 1.2 },
            { msg: "吹雪を召喚！全体に凍結攻撃！", mult: 0.9, allTarget: true }
          ],
          skill: { name: "ダイアモンドブリザード", msg: "🧞‍♀️ シヴァが真の力を解放！極寒の嵐が全体を凍てつかせる！", effect: "aoe", mult: 2.4 }
        },
        { name: "奈落の番犬：ケルベロス", icon: "🐕‍🦺",
          attacks: [
            { msg: "三つ首が一斉に噛みつく！3連撃！", mult: 1.4 },
            { msg: "地獄の炎のブレス！", mult: 1.1 },
            { msg: "尻尾の蛇が毒牙で噛む！（ランダム単体）", mult: 1.3, targetRandom: true }
          ],
          skill: { name: "冥府の咆哮", msg: "🐕‍🦺 ケルベロスの三つ首が同時に吠えた！全体に冥府の衝撃！", effect: "aoe", mult: 2.3 }
        },
        { name: "獄炎の巨神：スルト", icon: "🔥",
          attacks: [
            { msg: "炎の巨剣で薙ぎ払う！", mult: 1.1 },
            { msg: "溶岩を降り注がせる！全体攻撃！", mult: 0.9, allTarget: true },
            { msg: "灼熱の拳で一点集中！（最前の英傑に）", mult: 1.6, targetFirst: true }
          ],
          skill: { name: "ラグナロクの炎", msg: "🔥 スルトが世界を燃やす炎を解き放つ！全体に壊滅的火炎！", effect: "aoe", mult: 2.5 }
        },
        { name: "深淵の龍：ヨルムンガンド", icon: "🐍",
          attacks: [
            { msg: "世界蛇が締め付ける！全体拘束攻撃！", mult: 1.0, allTarget: true },
            { msg: "毒の牙で噛みちぎる！（ランダム単体）", mult: 1.5, targetRandom: true },
            { msg: "猛毒のブレスを吐く！（全体）", mult: 1.2, allTarget: true }
          ],
          skill: { name: "世界蛇の呪縛", msg: "🐍 ヨルムンガンドが世界を包む呪縛を解放！全体に深淵の毒！", effect: "aoe", mult: 2.6 }
        },
        { name: "堕天使：ルシファー", icon: "👼",
          attacks: [
            { msg: "堕天の剣で斬りつける！", mult: 1.1 },
            { msg: "暗黒の羽根を無数に放つ！全体攻撃！", mult: 1.0, allTarget: true },
            { msg: "失楽園の衝撃！最大HPの高い英傑を狙う！", mult: 2.0, targetHighestMax: true }
          ],
          skill: { name: "パラダイス・ロスト", msg: "👼 ルシファーが全力の黒炎を解き放つ！全体に滅びの光！", effect: "aoe", mult: 2.8 }
        },
        { name: "終焉の魔王：デウス・エクス・マキナ", icon: "🌑",
          attacks: [
            { msg: "終焉の剣が全てを断ち切る！全体攻撃！", mult: 1.2, allTarget: true },
            { msg: "魔王の暗黒魔法！（ランダム単体、大ダメージ）", mult: 2.0, targetRandom: true },
            { msg: "世界の終焉の力が収束する…（次ターン超強化）", mult: 0.3, charge: true }
          ],
          skill: { name: "終焉の審判", msg: "🌑 魔王が真の力を解放！全体に絶対的な終焉の光！ATKも上昇！", effect: "chargeAoe", mult: 3.0 }
        }
    ];

    function playBattleSfx(freq, type, duration, vol=0.1) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + duration);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function playChargeSfx() {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
    }

    function setupFloor() {
        if (currentFloor === 1) {
            userData.bannedUnits = [];
            saveToLocal();
        }

        // 号令・一時停止リセット
        heroOrderUsed = false;
        forceSkillNextTurn = false;
        isPaused = false;
        document.getElementById("pauseOverlay").classList.remove("active");
        const orderBtn = document.getElementById("orderBtn");
        if (orderBtn) { orderBtn.disabled = false; orderBtn.textContent = "📯 英傑の号令（残り1回）"; }
        const pauseBtn = document.getElementById("pauseBtn");
        if (pauseBtn) { pauseBtn.textContent = "⏸ 一時停止"; pauseBtn.style.background = "linear-gradient(#f39c12, #e67e22)"; }

        // 指数関数をやめ、より制御しやすい累乗計算（nのx乗）に切り替えたっぴ！
        const n = currentFloor - 1;

        // --- HP設定：10層(12M) / 15層(70M) に着地する調整 ---
        if (currentFloor === 1) {
            bossMaxHp = 15000;
        } else {
        // 3.8乗のカーブで、10層付近から一気にHPが増える「ボスラッシュ感」を演出
            bossMaxHp = Math.floor(15000 + Math.pow(n, 3.8) * 3000);
        }
        bossHp = bossMaxHp;

        // --- ATK設定：10層(5000) / 15層(50000) に着地する調整 ---
        if (currentFloor === 1) {
            bossAtk = 200;
        } else {
            // 5.15乗の急カーブ。終盤は「軽減スキル」がないと即死する絶望感を再現
            bossAtk = Math.floor(200 + Math.pow(n, 5.15) * 0.138);
        }


        const currentBoss = bossesByFloor[currentFloor - 1] || bossesByFloor[bossesByFloor.length - 1];
        document.getElementById("bossName").innerText = currentBoss.name;
        document.getElementById("bossIcon").innerText = currentBoss.icon;
        document.getElementById("floorTitle").innerText = `第 ${currentFloor} 階層`;
        
        updateVisuals();
        updateUI();
    }

    function updateVisuals() {
        //const intensity = (currentFloor - 1) / 14;
        //const r = Math.floor(5 + intensity * 40);
        //const g = Math.floor(5 - intensity * 5);
        //const b = Math.floor(5 + intensity * 20);
        //document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        //const field = document.getElementById("battleField");
        //const darkRed = Math.floor(44 + intensity * 150);
        //const purple = Math.floor(intensity * 100);
        //field.style.background = `linear-gradient(to bottom, #000, rgb(${darkRed}, 0, ${purple}))`;
        //if(currentFloor >= 5) field.style.boxShadow = `0 0 ${10 + intensity * 40}px rgba(255, 0, 0, ${0.2 + intensity * 0.5})`;
        //else field.style.boxShadow = "none";
        // 分母を 14 (15階層 - 1) にして、15層目で強度が MAX (1.0) になるよう調整だっぴ
        const intensity = (currentFloor - 1) / 14;

        // 背景色：階層が深くなるほど暗いグレーから血の混じったような暗赤紫色へ
        const r = Math.floor(5 + intensity * 65);
        const g = Math.max(0, Math.floor(5 - intensity * 5));
        const b = Math.floor(5 + intensity * 35);
        document.body.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

        // バトルフィールド：下部からじわじわと不気味な赤紫がせり上がってくるグラデーション
        const field = document.getElementById("battleField");
        const darkRed = Math.floor(44 + intensity * 200); // 最大 244 
        const purple = Math.floor(intensity * 120);       // 最大 120
        field.style.background = `linear-gradient(to bottom, #000, rgb(${darkRed}, 0, ${purple}))`;

        // ボックスシャドウ（魔王の覇気）：
        // 5層目から発生し、15層目ではフィールド全体が激しく赤く発光するっぴ！
        if (currentFloor >= 5) {
            const blurSize = 10 + intensity * 70; // 5層の約30pxから15層の80pxまで拡大
            const opacity = 0.2 + intensity * 0.6; // 最大 0.8 まで濃くなる
            field.style.boxShadow = `0 0 ${blurSize}px rgba(255, 0, 0, ${opacity})`;
        } else {
            field.style.boxShadow = "none";
        }
    }

    function getSkillDesc(unitName, baseVal) {
        if (unitName === "天照大御神") return `[効果] 味方全体を攻撃力の${baseVal}%回復。[常時]毎ターン味方全体HP5%回復`;
        if (["秩序の女神アストレア", "蒼海のマーメイド"].includes(unitName)) return `[効果] 味方全体を攻撃力の${baseVal}%回復`;
        if (unitName === "虚空の王アザトース") return `[効果] 敵に${baseVal}%ダメ。味方全員に50%ダメ`;
        if (unitName === "冥王ハデス") return `[効果] 敵の現在HPの${baseVal}%割合ダメ`;
        if (unitName === "不死鳥フェニックス") return `[効果] 敵に${baseVal}%ダメ。自分を${baseVal}%回復`;
        if (unitName === "終焉の龍神ラグナロク") return `[効果] 敵に${baseVal}%超絶ダメ＋自分HP${baseVal}回復`;
        if (unitName === "次元の守護者クロノス") return `[効果] 攻撃${baseVal}%ダメ＋敵HP1%減少`;
        if (unitName === "戦乙女ブリュンヒルデ") return `[効果] 敵に${baseVal}%ダメ。[常時]全被ダメ30%軽減`;
        if (unitName === "魔王ルシファー") return `[効果] 敵に${baseVal}%ダメ。[常時]味方全体の攻撃力1.3倍`;
        if (unitName === "太陽神ラー") return `[効果] 敵に${baseVal}%ダメ。[常時]味方全体の攻撃力1.2倍`;
        if (unitName === "知恵の梟アテナ") return `[効果] 敵に${baseVal}%ダメ。発動ターン味方被ダメ99%軽減`;
        if (unitName === "深海の主リヴァイアサン") return `[効果] 敵に${baseVal}%ダメ。[常時]全被ダメ18%軽減`;
        if (unitName === "奈落の支配者ヘカトンケイル") return `[効果] 敵に${baseVal}%ダメ。[常時・全体]敵ATK50%ダウン`;
        if (unitName === "幽冥の審判者ノルン") return `[効果] 敵に${baseVal}%ダメ。[常時・全体]敵ATK30%ダウン`;
        if (unitName === "封印の巫女イズナ") return `[効果] 敵に${baseVal}%ダメ。[常時・全体]敵ATK15%ダウン`;
        if (unitName === "万物の父オーディン") return `[効果] 敵に${baseVal}%ダメ。[常時]味方死亡時HP${baseVal}%回復＆ATK30%UP`;
        if (unitName === "無限の可能性メビウス") return `[効果] 敵に${baseVal}%ダメ。確率で最大8連撃`;
        if (unitName === "獄炎公サタン") return `[効果] 敵に${baseVal}%ダメ。[常時]ターンごとに自身のATK2%上昇`;
        if (unitName === "雷神トール") return `[効果] 敵に${baseVal}%ダメ。[常時]HP減少で被ダメ軽減＆ATK上昇`;
        if (unitName === "氷の女王シヴァ") return `[効果] 敵に${baseVal}%ダメ。[常時]10%の確率で敵の攻撃をスキップ`;
        if (unitName === "星砕きの巨神") return `[効果] 敵に${baseVal}%ダメ。[常時]自被ダメ70%軽減`;
        if (unitName === "運命の女神フォルトゥナ") return `[効果] 行動がランダムで決まる。ミス・回復・防御・全体強化・3倍大ダメージなど様々な効果が発動`;
        if (unitName === "天壁の守護神エギル") return `[効果] 敵に攻撃力×数%ダメ。[奥義]味方全体に${baseVal.toLocaleString()}のシールドを付与（ダメージを吸収）`;
        if (unitName === "聖域の乙女アルテミス") return `[効果] 敵に攻撃力×数%ダメ。[奥義]味方全体に${baseVal.toLocaleString()}のシールドを付与（ダメージを吸収）`;
        if (["僧侶", "麒麟"].includes(unitName)) return `[効果] 最低HPの味方を攻撃力の${baseVal}%回復`;
        if (unitName === "狂戦士") return `[効果] 自HP10%消費し、敵に${Math.floor(baseVal * 1.5)}%ダメ`;
        if (["金剛のゴーレム", "鉄壁の重騎士"].includes(unitName)) return `[効果] 敵に${baseVal}%ダメ。[常時]自被ダメ50%軽減`;
        if (unitName === "聖騎士") return `[効果] 敵に${baseVal}%ダメ。[常時]自被ダメ30%軽減`;
        return `[効果] 敵に攻撃力の${baseVal}%ダメージ`;
    }

    // ===== キャラ選択モーダル 並べ替え =====
    let _selectorSort = 'rarity';
    let _pvpSelectorSort = 'rarity';
    let _pvpBattleSelectorSort = 'rarity';

    const RARITY_ORDER = { 'UR': 5, 'LR': 4, 'SSR': 3, 'SR': 2, 'R': 1 };

    function getCharSortValue(item, group, lb, sortKey) {
        const mul = item.name === "無限の可能性メビウス" ? getMebiusMul(lb) : Math.pow(1.2, lb);
        const hp = Math.floor(item.hp * mul);
        const atk = Math.floor(item.atk * mul);
        const baseVal = Math.floor(item.baseVal * mul);
        if (sortKey === 'rarity') return RARITY_ORDER[group.rarity] || 0;
        if (sortKey === 'hp') return hp;
        if (sortKey === 'atk') return atk;
        if (sortKey === 'dmg') return Math.floor(atk * baseVal / 100); // 実質ダメージ概算
        return 0;
    }

    function buildOwnedCharList() {
        const result = [];
        for (const group of gachaData) {
            for (const item of group.items) {
                if (userData.myBox[item.name] !== undefined) {
                    result.push({ item, group, lb: userData.myBox[item.name] });
                }
            }
        }
        return result;
    }

    function renderSelectorList(listEl, chars, sortKey, onClickFn, isBanned=false) {
        listEl.innerHTML = "";
        const sorted = [...chars].sort((a, b) => getCharSortValue(b.item, b.group, b.lb, sortKey) - getCharSortValue(a.item, a.group, a.lb, sortKey));
        for (const { item, group, lb } of sorted) {
            const mul = item.name === "無限の可能性メビウス" ? getMebiusMul(lb) : Math.pow(1.2, lb);
            const buffedBaseVal = Math.floor(item.baseVal * mul);
            const desc = getSkillDesc(item.name, buffedBaseVal);
            const info = `HP: ${Math.floor(item.hp*mul)}\nATK: ${Math.floor(item.atk*mul)}\nSkill: ${item.skill}\n${desc}`;
            const div = document.createElement("div");
            div.className = "unit-slot occupied";
            const isCharBanned = isBanned && userData.bannedUnits.includes(item.name);
            if (isCharBanned) {
                div.classList.add("banned");
                div.innerHTML = `<div class="banned-label">出撃不可</div>`;
            } else {
                div.onclick = () => onClickFn(item, group);
            }
            div.style.borderColor = group.color;
            div.setAttribute("data-info", info);
            div.innerHTML += `<div class="unit-icon">${item.icon}</div><div style="font-size:8px; text-align:center;">${item.name}</div><div style="color:#ffd700; font-size:10px;">LB${lb}</div>`;
            listEl.appendChild(div);
        }
    }

    function setSelectorSort(key) {
        _selectorSort = key;
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`selectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === key ? ' active' : '');
        });
        const listEl = document.getElementById("ownedList");
        renderSelectorList(listEl, buildOwnedCharList(), _selectorSort, (item, group) => selectUnit(item, group), true);
    }

    function setPvpSelectorSort(key) {
        _pvpSelectorSort = key;
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`pvpSelectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === key ? ' active' : '');
        });
        const listEl = document.getElementById("pvpOwnedList");
        renderSelectorList(listEl, buildOwnedCharList(), _pvpSelectorSort, (item, group) => {
            const lb = userData.myBox[item.name];
            for (let j = 0; j < 5; j++) { if (pvpParty[j] && pvpParty[j].name === item.name) pvpParty[j] = null; }
            pvpParty[pvpSelectedSlot] = buildPvpUnit(item.name, lb);
            renderPvpSetupGrid();
            closePvpSelector();
        });
    }

    function setPvpBattleSelectorSort(key) {
        _pvpBattleSelectorSort = key;
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`pvpBattleSelectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === key ? ' active' : '');
        });
        const listEl = document.getElementById("pvpBattleOwnedList");
        renderSelectorList(listEl, buildOwnedCharList(), _pvpBattleSelectorSort, (item, group) => {
            const lb = userData.myBox[item.name];
            for (let j = 0; j < 5; j++) { if (pvpBattleParty[j] && pvpBattleParty[j].name === item.name) pvpBattleParty[j] = null; }
            pvpBattleParty[pvpBattleSelectedSlot] = buildPvpUnit(item.name, lb);
            renderPvpBattleGrid();
            closePvpBattleSelector();
        });
    }

    function openSelector(slotIdx) {
        if (isBattleRunning) return;
        initAudio();
        selectedSlot = slotIdx;
        const listEl = document.getElementById("ownedList");
        renderSelectorList(listEl, buildOwnedCharList(), _selectorSort, (item, group) => selectUnit(item, group), true);
        // ボタン状態リセット
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`selectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === _selectorSort ? ' active' : '');
        });
        document.getElementById("selectorModal").style.display = "flex";
    }

    function selectUnit(item, group) {
        for (let i = 0; i < party.length; i++) {
            if (party[i] && party[i].name === item.name) party[i] = null;
        }
        const lb = userData.myBox[item.name];
        let multiplier = Math.pow(1.2, lb);
        if (item.name === "無限の可能性メビウス") {
            multiplier = getMebiusMul(lb);
        }
        const originalAtk = Math.floor(item.atk * multiplier);
        party[selectedSlot] = {
            ...item,
            currentHp: Math.floor(item.hp * multiplier),
            maxHp: Math.floor(item.hp * multiplier),
            atk: originalAtk,
            originalAtk: originalAtk,
            baseVal: Math.floor(item.baseVal * multiplier),
            lb: lb, rarityColor: group.color, id: selectedSlot
        };
        renderParty();
        closeSelector();
    }

    function renderParty() {
        party.forEach((unit, idx) => {
            const slot = document.getElementById(`slot-${idx}`);
            if (unit) {
                const desc = getSkillDesc(unit.name, unit.baseVal);
                const shieldInfo = (unit._shield && unit._shield > 0) ? `\nシールド: ${unit._shield.toLocaleString()}` : '';
                const info = `HP: ${unit.currentHp}/${unit.maxHp}\nATK: ${unit.atk}\nSkill: ${unit.skill}\n${desc}${shieldInfo}`;
                slot.className = "unit-slot occupied";
                slot.style.borderColor = unit.rarityColor;
                slot.setAttribute("data-info", info);
                const hpPer = Math.max(0, (unit.currentHp / unit.maxHp) * 100);
                // シールドバー幅：シールド量 / maxHp を割合で（最大100%）
                const shieldPer = (unit._shield && unit._shield > 0 && unit.maxHp > 0)
                    ? Math.min(100, (unit._shield / unit.maxHp) * 100) : 0;
                const shieldLabel = (unit._shield && unit._shield > 0)
                    ? `<div class="unit-shield-label">🛡️${unit._shield.toLocaleString()}</div>` : '';
                slot.innerHTML = `<div class="unit-icon">${unit.icon}</div><div style="font-weight:bold; font-size:8px; text-align:center;">${unit.name}</div><div class="unit-hp-mini"><div class="unit-hp-mini-bar hp-bar-fill hp-player" style="width:${hpPer}%"></div><div class="unit-shield-bar" style="width:${shieldPer}%"></div>${shieldLabel}</div>`;
                slot.style.opacity = unit.currentHp <= 0 ? "0.4" : "1";
            } else {
                slot.innerHTML = "SELECT";
                slot.className = "unit-slot";
                slot.style.borderColor = "#666";
                slot.removeAttribute("data-info");
            }
        });
    }

    function closeSelector() { document.getElementById("selectorModal").style.display = "none"; }
    
    // ===== バトルスキル演出オーバーレイ =====
    function showSkillOverlay(unit, rarityColor, rarityKey) {
        const overlay = document.getElementById('skillOverlay');
        const bg = document.getElementById('skillOverlayBg');
        const linesEl = document.getElementById('skillOverlayLines');
        const skillNameEl = document.getElementById('skillOverlaySkillName');
        const charNameEl = document.getElementById('skillOverlayCharName');

        // テーマカラー設定
        bg.className = '';
        bg.className = 'rarity-' + rarityKey;
        // テキストボックスのボーダーをレアリティ色に
        const textBox = document.getElementById('skillOverlayText');
        textBox.style.borderColor = rarityColor;
        textBox.style.boxShadow = `0 0 30px rgba(0,0,0,0.7), 0 0 20px ${rarityColor}44, inset 0 0 20px rgba(255,255,255,0.04)`;
        skillNameEl.style.color = rarityColor;
        skillNameEl.textContent = '『' + unit.skill + '』';
        charNameEl.textContent = unit.name;
        // キャライコンを表示
        const charIconEl = document.getElementById('skillOverlayCharIcon');
        if (charIconEl) {
            charIconEl.textContent = unit.icon || '⭐';
            charIconEl.style.color = rarityColor;
            charIconEl.style.textShadow = `0 0 20px ${rarityColor}, 0 0 40px ${rarityColor}`;
        }

        // 放射線エフェクト（ランダムに8本）
        linesEl.innerHTML = '';
        for (let i = 0; i < 8; i++) {
            const line = document.createElement('div');
            line.className = 'skill-line';
            const angle = (i / 8) * 360 + Math.random() * 20;
            line.style.setProperty('--angle', angle + 'deg');
            line.style.animationDelay = (Math.random() * 0.1) + 's';
            linesEl.appendChild(line);
        }

        // アニメーションリセット
        overlay.classList.remove('active');
        void overlay.offsetHeight;
        overlay.classList.add('active');
        skillNameEl.style.animation = 'none';
        charNameEl.style.animation = 'none';
        void skillNameEl.offsetHeight;
        skillNameEl.style.animation = '';
        charNameEl.style.animation = '';
        document.getElementById('skillOverlayText').style.animation = 'none';
        void document.getElementById('skillOverlayText').offsetHeight;
        document.getElementById('skillOverlayText').style.animation = '';

        // 自動非表示
        setTimeout(() => { overlay.classList.remove('active'); }, 600);
    }
    function log(msg) {
        const logger = document.getElementById("battleLog");
        logger.innerHTML += `<div>> ${msg}</div>`;
        logger.scrollTop = logger.scrollHeight;
    }

    // ===== 英傑の号令演出 =====
    function showOrderOverlay() {
        const overlay = document.getElementById('orderOverlay');
        const linesEl = document.getElementById('orderOverlayLines');
        linesEl.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const line = document.createElement('div');
            line.className = 'skill-line';
            const angle = (i / 10) * 360 + Math.random() * 15;
            line.style.setProperty('--angle', angle + 'deg');
            line.style.background = 'linear-gradient(to bottom, transparent, rgba(200,130,255,0.4), transparent)';
            line.style.animationDelay = (Math.random() * 0.15) + 's';
            linesEl.appendChild(line);
        }
        overlay.classList.remove('active');
        void overlay.offsetHeight;
        overlay.classList.add('active');
        // アニメーションリセット
        const textBox = document.getElementById('orderOverlayText');
        textBox.style.animation = 'none';
        void textBox.offsetHeight;
        textBox.style.animation = '';
        setTimeout(() => { overlay.classList.remove('active'); }, 1200);
    }

    // ===== ボススキル演出 =====
    function showBossSkillOverlay(bossIcon, skillName, skillMsg) {
        const overlay = document.getElementById('bossSkillOverlay');
        const linesEl = document.getElementById('bossSkillOverlayLines');
        document.getElementById('bossSkillOverlayIcon').textContent = bossIcon || '👿';
        document.getElementById('bossSkillOverlayTitle').textContent = '【' + skillName + '】';
        // msgが長い場合は短縮
        const shortMsg = skillMsg.length > 30 ? skillMsg.slice(0, 28) + '…' : skillMsg;
        document.getElementById('bossSkillOverlayMsg').textContent = shortMsg;

        linesEl.innerHTML = '';
        for (let i = 0; i < 8; i++) {
            const line = document.createElement('div');
            line.className = 'skill-line';
            const angle = (i / 8) * 360 + Math.random() * 20;
            line.style.setProperty('--angle', angle + 'deg');
            line.style.background = 'linear-gradient(to bottom, transparent, rgba(255,0,100,0.4), transparent)';
            line.style.animationDelay = (Math.random() * 0.12) + 's';
            linesEl.appendChild(line);
        }
        overlay.classList.remove('active');
        void overlay.offsetHeight;
        overlay.classList.add('active');
        const textBox = document.getElementById('bossSkillOverlayText');
        textBox.style.animation = 'none';
        void textBox.offsetHeight;
        textBox.style.animation = '';
        setTimeout(() => { overlay.classList.remove('active'); }, 1000);
    }

    // ===== 勝利・敗北演出 =====
    let _battleResultResolve = null;
    let _resultAnimHandle = null;

    function showBattleResult(isVictory, subText, rewardText, showRestartBtn=false, damageData=null) {
        return new Promise(resolve => {
            _battleResultResolve = resolve;
            const overlay = document.getElementById('battleResultOverlay');
            overlay.className = 'active ' + (isVictory ? 'victory' : 'defeat');
            document.getElementById('battleResultIcon').textContent = isVictory ? '🏆' : '💀';
            document.getElementById('battleResultTitle').textContent = isVictory ? 'VICTORY' : 'DEFEAT';
            document.getElementById('battleResultSub').textContent = subText || '';
            document.getElementById('battleResultReward').textContent = rewardText || '';
            const btn = document.getElementById('battleResultBtn');
            btn.textContent = isVictory ? '✦ 続ける ✦' : '✦ 戻る ✦';
            // 敗北時に「最初から」ボタンを表示
            const restartBtn = document.getElementById('battleResultRestartBtn');
            restartBtn.style.display = (showRestartBtn && !isVictory) ? 'inline-block' : 'none';
            // ダメージサマリー表示
            const dmgDiv = document.getElementById('battleResultDamageList');
            if (dmgDiv) {
                if (damageData && damageData.length > 0) {
                    dmgDiv.style.display = 'block';
                    dmgDiv.innerHTML = '<div style="font-size:11px;color:#aaa;letter-spacing:2px;margin-bottom:6px;">⚔️ 与ダメージ集計</div>' +
                        damageData.map(d => `<div style="display:flex;justify-content:space-between;align-items:center;padding:3px 0;border-bottom:1px solid #333;">
                            <span style="font-size:16px;">${d.icon}</span>
                            <span style="font-size:10px;color:#ccc;flex:1;margin-left:6px;text-align:left;">${d.name}</span>
                            <span style="font-size:12px;font-weight:bold;color:#ffcc44;">${d.dmg.toLocaleString()}</span>
                        </div>`).join('');
                } else {
                    dmgDiv.style.display = 'none';
                }
            }
            // 勝利時パーティクル
            if (isVictory) startResultParticles(true);
            else startResultParticles(false);
        });
    }

    function closeBattleResult() {
        const overlay = document.getElementById('battleResultOverlay');
        overlay.classList.remove('active');
        if (_resultAnimHandle) { cancelAnimationFrame(_resultAnimHandle); _resultAnimHandle = null; }
        const canvas = document.getElementById('battleResultCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (_battleResultResolve) { _battleResultResolve(); _battleResultResolve = null; }
    }

    function restartTowerFromBeginning() {
        // 使用不可リセット
        userData.bannedUnits = [];
        saveToLocal();
        // 1層から再スタート
        currentFloor = 1;
        // バトル結果画面を閉じる
        closeBattleResult();
        // バトル状態リセット
        isBattleRunning = false;
        isPaused = false;
        forceSkillNextTurn = false;
        heroOrderUsed = false;
        // セットアップ（bossHpなどもリセット）
        setupFloor();
        // 全パーティーのHPリセット
        party.forEach(u => { if (u) { u.currentHp = u.maxHp; u.atk = u.originalAtk; u._shield = 0; u._shieldCount = 0; } });
        renderParty();
        const btn = document.getElementById("attackBtn");
        if (btn) btn.disabled = false;
        const orderBtn = document.getElementById("orderBtn");
        if (orderBtn) { orderBtn.disabled = false; }
        const pauseBtn = document.getElementById("pauseBtn");
        if (pauseBtn) pauseBtn.style.display = "none";
        document.getElementById("battleLog").innerHTML = "";
        log(`<span style="color:#00ffcc; font-weight:bold;">🔄 1層からやり直し！英傑の出撃制限がリセットされました。</span>`);
        stopBattleBgm();
        startBattleBgm();
    }

    function startResultParticles(isVictory) {
        const canvas = document.getElementById('battleResultCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        const particles = [];
        const count = isVictory ? 120 : 60;
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = isVictory ? (1 + Math.random() * 4) : (0.5 + Math.random() * 2);
            particles.push({
                x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                y: canvas.height / 2 + (Math.random() - 0.5) * 100,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - (isVictory ? 2 : 0),
                size: isVictory ? (3 + Math.random() * 7) : (2 + Math.random() * 4),
                color: isVictory
                    ? ['#ffd700','#ffaa00','#ff6600','#fff','#00ffcc','#ff00ff'][Math.floor(Math.random()*6)]
                    : ['#ff4444','#880000','#cc0000','#ff8888'][Math.floor(Math.random()*4)],
                alpha: 1,
                gravity: isVictory ? 0.05 : 0.03,
                life: 1
            });
        }
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let alive = false;
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                p.life -= 0.012; p.alpha = p.life;
                if (p.life > 0) {
                    alive = true;
                    ctx.globalAlpha = Math.max(0, p.alpha);
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
            if (alive) _resultAnimHandle = requestAnimationFrame(animate);
        }
        _resultAnimHandle = requestAnimationFrame(animate);
    }

    function spawnPop(dmg, isPlayer=false, targetIdx=-1, isHeal=false) {
        const pop = document.createElement("div");
        pop.className = isPlayer ? "damage-pop player" : "damage-pop";
        if(isHeal) { pop.className += " heal"; pop.innerText = `+${Math.floor(dmg).toLocaleString()}`; }
        else { pop.innerText = `-${Math.floor(dmg).toLocaleString()}`; }
        if((isPlayer || isHeal) && targetIdx !== -1) {
            const slot = document.getElementById(`slot-${targetIdx}`);
            const rect = slot.getBoundingClientRect();
            const fieldRect = document.getElementById("battleField").getBoundingClientRect();
            pop.style.left = (rect.left - fieldRect.left + (rect.width/2) - 20) + "px";
            pop.style.top = (rect.top - fieldRect.top) + "px";
        } else {
            pop.style.left = (Math.random() * 40 + 30) + "%";
            pop.style.top = "100px";
        }
        document.getElementById("battleField").appendChild(pop);
        setTimeout(() => pop.remove(), 800);
    }

    async function executeBattle() {
        if (party.every(u => u === null)) return alert("パーティーを編成してください！");
        initAudio(); startBattleBgm();
        const btn = document.getElementById("attackBtn");
        btn.disabled = true; isBattleRunning = true;
        // ダメージ集計リセット
        party.forEach(u => { if (u) u._totalDamage = 0; });
        // 一時停止ボタン表示、号令ボタン有効化
        document.getElementById("pauseBtn").style.display = "block";
        if (!heroOrderUsed) {
            const ob = document.getElementById("orderBtn");
            ob.disabled = false;
        }
        log(`<span style="color:#ffd700">--- 第 ${currentFloor} 階層 戦闘開始 ---</span>`);

        let turn = 1;
        let bossChargeMultiplier = 1.0; // 次ターンへの強化チャージ
        while (bossHp > 0) {
            let athenaShield = false;
            let globalAtkBuff = 1.0;
            const isOrderTurn = forceSkillNextTurn; // このターンが号令ターンかを保存
            if (isOrderTurn) {
                forceSkillNextTurn = false;
                log(`<span style="color:#cc88ff; font-weight:bold;">✨ 英傑の号令発動！全英傑が奥義を解放する！</span>`);
                showOrderOverlay();
                await new Promise(r => setTimeout(r, Math.floor(400 / battleSpeedMultiplier)));
            }
            log(`--- ターン ${turn} ---`);
            await waitIfPaused();
            // ターン間の演出が重ならないよう少し待機（最速x8.0では省略）
            if (battleSpeedMultiplier < 8.0) {
                await new Promise(r => setTimeout(r, Math.floor(500 / battleSpeedMultiplier)));
                await waitIfPaused();
            }
            if (party.some(u => u && u.name === "魔王ルシファー" && u.currentHp > 0)) globalAtkBuff *= 1.3;
            if (party.some(u => u && u.name === "太陽神ラー" && u.currentHp > 0)) globalAtkBuff *= 1.2;

            for (let i = 0; i < party.length; i++) {
                const unit = party[i];
                if (!unit || unit.currentHp <= 0) continue;
                const slotEl = document.getElementById(`slot-${i}`);
                const isSkill = isOrderTurn || Math.random() < 0.3; 
                let damage = unit.atk;
                
                if (isSkill) {
                    log(`<span style="color:#ff0; font-weight:bold;">${unit.name}の奥義：『${unit.skill}』！</span>`);
                    slotEl.classList.add("skill-flash");
                    slotEl.style.color = unit.rarityColor || '#fff';
                    // レアリティキー判定
                    const rarityKeyMap = { '#ff0000':'ur', '#ff00ff':'lr', '#ffd700':'ssr', '#00ffff':'sr', '#cd7f32':'r' };
                    const rKey = rarityKeyMap[unit.rarityColor] || 'sr';
                    showSkillOverlay(unit, unit.rarityColor || '#fff', rKey);
                    playChargeSfx();
                    document.getElementById("battleField").classList.add("shake");
                    await new Promise(r => setTimeout(r, Math.floor(600 / battleSpeedMultiplier)));
                    await waitIfPaused();
                    damage = Math.floor(unit.atk * (unit.baseVal / 100)); 
                    
                    if (["秩序の女神アストレア", "蒼海のマーメイド", "天照大御神"].includes(unit.name)) {
                        party.forEach((u, idx) => { if(u && u.currentHp > 0) { let heal = Math.floor(unit.atk * (unit.baseVal/100)); u.currentHp = Math.min(u.maxHp, u.currentHp + heal); spawnPop(heal, false, idx, true); log(`<span style="color:#0f0;">${u.name}は ${heal.toLocaleString()} 回復した！</span>`); } });
                    } else if (unit.name === "虚空の王アザトース") {
                        party.forEach((u, idx) => { if(u && u.currentHp > 0) { let selfDmg = Math.floor(unit.atk * 0.5); u.currentHp -= selfDmg; spawnPop(selfDmg, true, idx); log(`<span style="color:#f00;">混沌の余波！${u.name}に ${selfDmg.toLocaleString()} の反動ダメージ！</span>`); } });
                    } else if (unit.name === "冥王ハデス") {
                        damage = Math.floor(bossHp * (unit.baseVal / 100));
                    } else if (unit.name === "終焉の龍神ラグナロク") {
                        let heal = unit.baseVal;
                        unit.currentHp = Math.min(unit.maxHp, unit.currentHp + heal);
                        spawnPop(heal, false, i, true);
                        log(`<span style="color:#0f0;">${unit.name}は自身のHPを ${heal.toLocaleString()} 吸収回復！</span>`);
                    } else if (unit.name === "次元の守護者クロノス") {
                        let percentDmg = Math.floor(bossHp * 0.01);
                        damage += percentDmg;
                        log(`<span style="color:#fff;">刻の加速！追加で敵HPの1%(${percentDmg.toLocaleString()})を削り取る！</span>`);
                    } else if (["僧侶", "麒麟"].includes(unit.name)) {
                        let target = party.filter(u => u && u.currentHp > 0).sort((a,b) => (a.currentHp/a.maxHp) - (b.currentHp/b.maxHp))[0];
                        if(target) { let heal = Math.floor(unit.atk * (unit.baseVal/100)); target.currentHp = Math.min(target.maxHp, target.currentHp + heal); spawnPop(heal, false, target.id, true); log(`<span style="color:#0f0;">${unit.name}が${target.name}を ${heal.toLocaleString()} 回復！</span>`); }
                    } else if (unit.name === "不死鳥フェニックス") {
                        let heal = Math.floor(unit.atk * (unit.baseVal/100));
                        unit.currentHp = Math.min(unit.maxHp, unit.currentHp + heal);
                        spawnPop(heal, false, i, true);
                        log(`<span style="color:#0f0;">不死鳥の炎！自身のHPを ${heal.toLocaleString()} 回復！</span>`);
                    } else if (unit.name === "狂戦士") {
                        let consumption = Math.floor(unit.maxHp * 0.1);
                        unit.currentHp -= consumption;
                        damage *= 1.5;
                        log(`<span style="color:#f00;">狂気！HPを ${consumption.toLocaleString()} 消費し攻撃力1.5倍！</span>`);
                    } else if (unit.name === "知恵の梟アテナ") {
                        athenaShield = true;
                        log(`<span style="color:#00ffff;">イージスの盾！このターンのボスの攻撃を99%カット！</span>`);
                    } else if (["天壁の守護神エギル", "聖域の乙女アルテミス"].includes(unit.name)) {
                        const shieldAmt = unit.baseVal;
                        party.forEach((u, idx) => {
                            if (u && u.currentHp > 0) {
                                u._shieldCount = (u._shieldCount || 0);
                                if (u._shieldCount < 3) {
                                    u._shield = (u._shield || 0) + shieldAmt;
                                    u._shieldCount++;
                                    log(`<span style="color:#00ccff;">${unit.icon}${unit.name}の加護！${u.name}に ${shieldAmt.toLocaleString()} のシールド付与！（スタック ${u._shieldCount}/3）</span>`);
                                } else {
                                    log(`<span style="color:#558;">[シールド] ${u.name}はシールドが最大スタック(3)に達しているため追加付与できない！</span>`);
                                }
                            }
                        });
                        damage = unit.atk; // シールドキャラの攻撃ダメージはATKのみ（少量）
                    } else if (unit.name === "運命の女神フォルトゥナ") {
                        // スキル: ランダムな強力効果
                        const roll = Math.random();
                        if (roll < 0.12) {
                            // 大ミス
                            damage = 0;
                            log(`<span style="color:#888;">🍀 運命の気まぐれ…フォルトゥナの奥義は不発に終わった！</span>`);
                        } else if (roll < 0.25) {
                            // 全体大回復
                            party.forEach((u, idx) => { if(u && u.currentHp > 0) { let h = Math.floor(unit.atk * (unit.baseVal/100)); u.currentHp = Math.min(u.maxHp, u.currentHp + h); spawnPop(h, false, idx, true); } });
                            damage = 0;
                            log(`<span style="color:#0f0;">🍀 幸運の女神の加護！味方全体が大回復！</span>`);
                        } else if (roll < 0.40) {
                            // 全体防御バフ（一時的にダメージ軽減フラグ）
                            party.forEach(u => { if(u && u.currentHp > 0) u._fortunaShield = true; });
                            damage = Math.floor(unit.atk * 0.5);
                            log(`<span style="color:#00ffff;">🍀 運命の盾！味方全体にこのターン防御バフ付与！（被ダメ50%軽減）</span>`);
                        } else if (roll < 0.55) {
                            // 超強力一撃
                            damage = Math.floor(unit.atk * (unit.baseVal / 100) * 3.0);
                            log(`<span style="color:#ff4400;">🍀 運命の大逆転！圧倒的な一撃が炸裂！(3倍ダメージ)</span>`);
                        } else if (roll < 0.70) {
                            // 全体ATKバフ
                            party.forEach(u => { if(u && u.currentHp > 0) u.atk = Math.floor(u.atk * 1.4); });
                            log(`<span style="color:#ffd700;">🍀 運命の加護！全英傑の攻撃力が40%上昇！</span>`);
                        } else if (roll < 0.82) {
                            // 割合ダメージ
                            damage = Math.floor(bossHp * 0.15);
                            log(`<span style="color:#ff00ff;">🍀 運命の審判！敵の現在HPの15%割合ダメージ！</span>`);
                        } else {
                            // 通常強め
                            damage = Math.floor(unit.atk * (unit.baseVal / 100) * 1.5);
                            log(`<span style="color:#90ee90;">🍀 運命の女神の微笑み！通常より強い一撃！</span>`);
                        }
                    } else if (unit.name === "無限の可能性メビウス") {
                        let combo = 1;
                        let probability = 0.8;
                        while (combo < 8 && Math.random() < probability) {
                            combo++;
                            probability -= 0.15;
                        }
                        if (combo > 1) {
                            log(`<span style="color:#ff00ff;">アンリミテット！怒涛の ${combo} 連撃！！</span>`);
                            for (let c = 2; c <= combo; c++) {
                                let hitDmg = Math.floor(damage * globalAtkBuff * (0.9 + Math.random() * 0.2));
                                bossHp -= hitDmg;
                                unit._totalDamage = (unit._totalDamage || 0) + hitDmg;
                                setTimeout(() => spawnPop(hitDmg), c * 150);
                            }
                        }
                    }
                    playBattleSfx(150, 'sawtooth', 0.5, 0.2);
                } else {
                    // 通常攻撃
                    if (unit.name === "運命の女神フォルトゥナ") {
                        // 通常攻撃もランダム（スキルより控えめ）
                        const r = Math.random();
                        if (r < 0.15) {
                            // ミス
                            damage = 0;
                            log(`<span style="color:#888;">🍀 運命のいたずら…${unit.name}の攻撃はミスした！</span>`);
                        } else if (r < 0.30) {
                            // 小回復
                            const heal = Math.floor(unit.atk * 0.5);
                            const healTarget = party.filter(u => u && u.currentHp > 0)[Math.floor(Math.random() * party.filter(u => u && u.currentHp > 0).length)];
                            if (healTarget) { healTarget.currentHp = Math.min(healTarget.maxHp, healTarget.currentHp + heal); spawnPop(heal, false, party.indexOf(healTarget), true); }
                            damage = 0;
                            log(`<span style="color:#0f0;">🍀 幸運の女神の微笑み！ ${heal.toLocaleString()} 回復！</span>`);
                        } else if (r < 0.45) {
                            // 超強打
                            damage = Math.floor(unit.atk * 2.5);
                            log(`<span style="color:#ffd700;">🍀 運命の一撃！超強力な攻撃が炸裂！</span>`);
                        } else {
                            // 通常
                            log(`<span style="color:#90ee90;">🍀 運命の一撃！</span>`);
                        }
                    }
                    playBattleSfx(440, 'sine', 0.1);
                }

                if (unit.name === "雷神トール") {
                    let lossRate = 1.0 - (unit.currentHp / unit.maxHp);
                    damage = Math.floor(damage * (1.0 + lossRate));
                }

                const finalDmg = Math.floor(damage * globalAtkBuff * (0.9 + Math.random() * 0.2));
                bossHp -= finalDmg;
                unit._totalDamage = (unit._totalDamage || 0) + finalDmg;
                spawnPop(finalDmg);
                log(`${unit.name}の${isSkill ? '奥義' : '攻撃'}：敵に <span style="color:#ff0; font-weight:bold;">${finalDmg.toLocaleString()}</span> のダメージ！`);
                updateUI(); renderParty();
                if (isSkill) { slotEl.classList.remove("skill-flash"); slotEl.style.color = ''; document.getElementById("battleField").classList.remove("shake"); }
                if (bossHp <= 0) break;
                // スキル演出後の待機（演出の重なり防止）
                const unitActionDelay = isSkill ? Math.floor(400 / battleSpeedMultiplier) : Math.floor(200 / battleSpeedMultiplier);
                await new Promise(r => setTimeout(r, unitActionDelay));
                await waitIfPaused();
            }
            if (bossHp <= 0) break;
            await new Promise(r => setTimeout(r, Math.floor(800 / battleSpeedMultiplier)));
            await waitIfPaused();
            
            party.forEach(u => {
                if (u && u.name === "獄炎公サタン" && u.currentHp > 0) {
                    u.atk = Math.floor(u.atk * 1.02);
                    log(`<span style="color:#ff4d4d;">[サタンの魔力] ターン経過により自身のATKが2%上昇！</span>`);
                }
            });

            if (party.some(u => u && u.name === "天照大御神" && u.currentHp > 0)) {
                log(`<span style="color:#0f0;">[天照大御神の慈愛] 毎ターン味方全体のHPを5%回復！</span>`);
                party.forEach((u, idx) => {
                    if (u && u.currentHp > 0) {
                        let heal = Math.floor(u.maxHp * 0.05);
                        u.currentHp = Math.min(u.maxHp, u.currentHp + heal);
                        spawnPop(heal, false, idx, true);
                    }
                });
            }

            let skipBossAttack = false;
            if (party.some(u => u && u.name === "氷の女王シヴァ" && u.currentHp > 0)) {
                if (Math.random() < 0.10) {
                    skipBossAttack = true;
                }
            }

            if (skipBossAttack) {
                log(`<span style="color:#00ffff; font-weight:bold;">[氷の女王シヴァの冷気] 敵は凍結し、行動をスキップした！</span>`);
            } else {
                const currentBossData = bossesByFloor[currentFloor - 1] || bossesByFloor[bossesByFloor.length - 1];
                const isBossSkillTurn = (turn % 5 === 0);

                // ヘルパー：オーディン発動チェック
                function checkOdin(deadUnit) {
                    party.forEach((oUnit, oIdx) => {
                        if (oUnit && oUnit.name === "万物の父オーディン" && oUnit.currentHp > 0 && oUnit !== deadUnit) {
                            let heal = Math.floor(oUnit.maxHp * (oUnit.baseVal / 100));
                            oUnit.currentHp = Math.min(oUnit.maxHp, oUnit.currentHp + heal);
                            oUnit.atk = Math.floor(oUnit.atk * 1.3);
                            spawnPop(heal, false, oIdx, true);
                            log(`<span style="color:#ffd700;">[オーディンの覚醒] 仲間の犠牲により、HP回復と攻撃力が30%上昇！</span>`);
                        }
                    });
                }
                // ヘルパー：軽減率計算
                function calcUnitReduction(unit) {
                    if(unit.name === "星砕きの巨神") return 0.3;
                    if(["金剛のゴーレム","鉄壁の重騎士"].includes(unit.name)) return 0.5;
                    if(unit.name === "聖騎士") return 0.7;
                    if(unit.name === "雷神トール") { let lr = 1.0-(unit.currentHp/unit.maxHp); return 1.0-(0.8*lr); }
                    if(unit._fortunaShield) { unit._fortunaShield = false; return 0.5; }
                    return 1.0;
                }
                // ヘルパー：全体軽減計算
                function calcGlobalReduction() {
                    let gr = 1.0;
                    let msgs = [];
                    if (party.some(u => u && u.name === "戦乙女ブリュンヒルデ" && u.currentHp > 0)) { gr *= 0.7; msgs.push("<span style='color:#00ffff;'>[ブリュンヒルデの加護] 全ダメージ30%軽減！</span>"); }
                    if (party.some(u => u && u.name === "深海の主リヴァイアサン" && u.currentHp > 0)) { gr *= 0.82; msgs.push("<span style='color:#00ffff;'>[リヴァイアサンの威圧] 全ダメージ18%軽減！</span>"); }
                    // 敵ATKデバフ（デバフキャラ編成による乗算）
                    let atkDebuffMult = 1.0;
                    if (party.some(u => u && u.name === "奈落の支配者ヘカトンケイル" && u.currentHp > 0)) { atkDebuffMult *= 0.5; msgs.push("<span style='color:#ff88ff;'>[ヘカトンケイルの呪縛] 敵ATK50%ダウン！</span>"); }
                    if (party.some(u => u && u.name === "幽冥の審判者ノルン" && u.currentHp > 0)) { atkDebuffMult *= 0.7; msgs.push("<span style='color:#ff88ff;'>[ノルンの裁き] 敵ATK30%ダウン！</span>"); }
                    if (party.some(u => u && u.name === "封印の巫女イズナ" && u.currentHp > 0)) { atkDebuffMult *= 0.85; msgs.push("<span style='color:#ff88ff;'>[イズナの封印] 敵ATK15%ダウン！</span>"); }
                    if (atkDebuffMult < 1.0) { gr *= atkDebuffMult; }
                    if (athenaShield) { gr *= 0.01; msgs.push("<span style='color:#ffff00;'>[イージスの絶対防御] 全ダメージ99%カット！</span>"); }
                    msgs.forEach(m => log(m));
                    return gr;
                }
                // ヘルパー：1体にダメージ
                function applyDmgToUnit(unit, idx, baseDmg) {
                    let remaining = baseDmg;
                    if (unit._shield && unit._shield > 0) {
                        const absorbed = Math.min(unit._shield, remaining);
                        unit._shield -= absorbed;
                        remaining -= absorbed;
                        if (unit._shield <= 0) { unit._shield = 0; unit._shieldCount = 0; }
                        if (absorbed > 0) log(`<span style="color:#00ccff;">[シールド吸収] ${unit.name}のシールドが${absorbed.toLocaleString()}ダメージを防いだ！（残り盾: ${unit._shield.toLocaleString()}）</span>`);
                    }
                    if (remaining > 0) {
                        unit.currentHp -= remaining;
                        spawnPop(remaining, true, idx);
                        log(`${unit.name}は <span style="color:#f00;">${remaining.toLocaleString()}</span> のダメージを受けた！`);
                    } else {
                        log(`<span style="color:#00ccff;">${unit.name}はシールドで完全にダメージを防いだ！</span>`);
                    }
                    if (unit.currentHp <= 0) { unit.currentHp = 0; log(`<span style="color:gray;">${unit.name}は力尽きた...</span>`); checkOdin(unit); }
                }

                if (isBossSkillTurn) {
                    // ===== ボススキル発動（5の倍数ターン）=====
                    const sk = currentBossData.skill;
                    log(`<span style="color:#ff00cc; font-weight:bold; font-size:13px;">【敵スキル発動】${sk.name}！</span>`);
                    log(`<span style="color:#ff88cc;">${sk.msg}</span>`);
                    showBossSkillOverlay(currentBossData.icon || '👿', sk.name, sk.msg);
                    playBattleSfx(80, 'sawtooth', 0.6, 0.25);
                    document.getElementById("battleField").classList.add("shake");
                    setTimeout(()=>document.getElementById("battleField").classList.remove("shake"), 400);

                    const gr = calcGlobalReduction();

                    if (sk.effect === "drain") {
                        // 全体攻撃 + 吸血回復
                        let totalAbsorb = 0;
                        for (let idx = 0; idx < party.length; idx++) {
                            const unit = party[idx];
                            if (unit && unit.currentHp > 0) {
                                let dmg = Math.floor(bossAtk * sk.mult * bossChargeMultiplier * (0.85 + Math.random() * 0.3) * gr * calcUnitReduction(unit));
                                totalAbsorb += dmg;
                                applyDmgToUnit(unit, idx, dmg);
                            }
                        }
                        let healAmt = Math.floor(totalAbsorb * 0.3);
                        bossHp = Math.min(bossMaxHp, bossHp + healAmt);
                        log(`<span style="color:#f0a;">[吸血] 敵が ${healAmt.toLocaleString()} HP回復した！</span>`);
                    } else if (sk.effect === "debuff") {
                        // 全体攻撃 + ATK低下
                        for (let idx = 0; idx < party.length; idx++) {
                            const unit = party[idx];
                            if (unit && unit.currentHp > 0) {
                                let dmg = Math.floor(bossAtk * sk.mult * bossChargeMultiplier * (0.85 + Math.random() * 0.3) * gr * calcUnitReduction(unit));
                                applyDmgToUnit(unit, idx, dmg);
                            }
                        }
                        const aliveList = party.filter(u => u && u.currentHp > 0);
                        if (aliveList.length > 0) {
                            const debuffTarget = aliveList[Math.floor(Math.random() * aliveList.length)];
                            debuffTarget.atk = Math.floor(debuffTarget.atk * 0.9);
                            log(`<span style="color:#f0a;">[呪縛] ${debuffTarget.name}のATKが10%低下した！</span>`);
                        }
                    } else if (sk.effect === "chargeAoe") {
                        // ATK強化 + 全体攻撃（ラスボス専用）
                        bossAtk = Math.floor(bossAtk * 1.15);
                        bossChargeMultiplier = 1.0;
                        log(`<span style="color:#ff4400;">[魔王強化] 終焉の魔王のATKがさらに15%上昇した！</span>`);
                        for (let idx = 0; idx < party.length; idx++) {
                            const unit = party[idx];
                            if (unit && unit.currentHp > 0) {
                                let dmg = Math.floor(bossAtk * sk.mult * (0.85 + Math.random() * 0.3) * gr * calcUnitReduction(unit));
                                applyDmgToUnit(unit, idx, dmg);
                            }
                        }
                    } else {
                        // aoe: 全体攻撃（汎用）
                        for (let idx = 0; idx < party.length; idx++) {
                            const unit = party[idx];
                            if (unit && unit.currentHp > 0) {
                                let dmg = Math.floor(bossAtk * sk.mult * bossChargeMultiplier * (0.85 + Math.random() * 0.3) * gr * calcUnitReduction(unit));
                                applyDmgToUnit(unit, idx, dmg);
                            }
                        }
                    }
                    bossChargeMultiplier = 1.0;

                } else {
                    // ===== 通常攻撃ターン（バリエーション）=====
                    const attackVariants = currentBossData.attacks;
                    const chosenAttack = attackVariants[Math.floor(Math.random() * attackVariants.length)];

                    log(`<span style="color:red; font-weight:bold;">魔王の猛攻！</span> ${chosenAttack.msg}`);
                    playBattleSfx(100, 'square', 0.3, 0.2);
                    document.getElementById("battleField").classList.add("shake");
                    setTimeout(()=>document.getElementById("battleField").classList.remove("shake"), 300);

                    // 自己回復行動
                    if (chosenAttack.selfRegen) {
                        let regenAmt = Math.floor(bossMaxHp * chosenAttack.selfRegen);
                        bossHp = Math.min(bossMaxHp, bossHp + regenAmt);
                        log(`<span style="color:#f0a;">[自然の力] 敵が ${regenAmt.toLocaleString()} HP回復した！</span>`);
                        updateUI(); renderParty();
                        bossAtk = Math.floor(bossAtk * 1.05);
                        log(`<span style="color:#ffcc00; font-size:12px;">魔王の力はターンとともに上昇する…！（ボスの基本ATK: ${bossAtk.toLocaleString()}）</span>`);
                        turn++;
                        continue;
                    }

                    // チャージ行動（次ターン強化）
                    if (chosenAttack.charge) {
                        bossChargeMultiplier = 2.5;
                        log(`<span style="color:#ff4400; font-weight:bold;">[チャージ] 敵が力を溜めている！次の攻撃が大幅強化される！</span>`);
                        bossAtk = Math.floor(bossAtk * 1.05);
                        log(`<span style="color:#ffcc00; font-size:12px;">魔王の力はターンとともに上昇する…！（ボスの基本ATK: ${bossAtk.toLocaleString()}）</span>`);
                        renderParty(); updateUI();
                        turn++;
                        continue;
                    }

                    const gr = calcGlobalReduction();
                    const aliveParty = party.map((u,i) => ({u,i})).filter(({u}) => u && u.currentHp > 0);

                    // ターゲット決定
                    let targets = [];
                    if (aliveParty.length > 0) {
                        if (chosenAttack.targetRandom) {
                            targets = [aliveParty[Math.floor(Math.random() * aliveParty.length)]];
                        } else if (chosenAttack.targetLowest) {
                            targets = [[...aliveParty].sort((a,b) => (a.u.currentHp/a.u.maxHp) - (b.u.currentHp/b.u.maxHp))[0]];
                        } else if (chosenAttack.targetFirst) {
                            targets = [aliveParty[0]];
                        } else if (chosenAttack.targetHighestMax) {
                            targets = [[...aliveParty].sort((a,b) => b.u.maxHp - a.u.maxHp)[0]];
                        } else {
                            targets = aliveParty; // 全体
                        }
                    }

                    for (const {u: unit, i: idx} of targets) {
                        let dmg = Math.floor(bossAtk * chosenAttack.mult * bossChargeMultiplier * (0.8 + Math.random() * 0.4) * gr * calcUnitReduction(unit));
                        applyDmgToUnit(unit, idx, dmg);
                    }
                    bossChargeMultiplier = 1.0;
                }

                bossAtk = Math.floor(bossAtk * 1.05);
                log(`<span style="color:#ffcc00; font-size:12px;">魔王の力はターンとともに上昇する…！（ボスの基本ATK: ${bossAtk.toLocaleString()}）</span>`);
            }
            
            turn++;
            renderParty(); updateUI();
            if (party.every(u => !u || u.currentHp <= 0)) {
                log(`<span style="color:#888;">全滅しました...</span>`);
                party.forEach((u, idx) => {
                    if(u) {
                        // シールド解除
                        u._shield = 0; u._shieldCount = 0;
                        if(!userData.bannedUnits.includes(u.name)) userData.bannedUnits.push(u.name);
                        party[idx] = null;
                    }
                });
                saveToLocal(); 
                stopBattleBgm();
                isBattleRunning = false; btn.disabled = false;
                isPaused = false;
                document.getElementById("pauseOverlay").classList.remove("active");
                document.getElementById("pauseBtn").style.display = "none";
                renderParty();
                playBattleResultSfx(false);
                const _defeatDmgData = party.filter(u=>u).map(u=>({icon:u.icon,name:u.name,dmg:u._totalDamage||0})).sort((a,b)=>b.dmg-a.dmg);
                await showBattleResult(false, '英傑たちは倒れた…', '出撃した英傑は次の戦いまで休眠します', true, _defeatDmgData);
                // 敗北後はbossAtkのみリセット（bossHpはそのまま引き継ぐ）
                { const _n = currentFloor - 1; bossAtk = currentFloor === 1 ? 200 : Math.floor(200 + Math.pow(_n, 5.15) * 0.138); }
                alert("敗北...。今の英傑たちは傷つき、この敵を倒すまで再出撃できません。");
                return;
            }

        }
        
        playBattleSfx(880, 'sine', 0.5, 0.2);
        let reward = 1200 * currentFloor;
        log(`<strong>第 ${currentFloor} 階層 クリア！</strong>`);
        log(`<span style="color:#ffd700; font-size:14px;">報酬：💎 ${reward.toLocaleString()} 獲得！</span>`);
        
        userData.bannedUnits = [];
        userData.stones += reward;
        if (!userData.totalStonesEarned) userData.totalStonesEarned = 0;
        userData.totalStonesEarned += reward;
        if (currentFloor > (userData.maxFloor || 0)) { userData.maxFloor = currentFloor; }
        saveToLocal();
        
        party.forEach(u => {
            if (u) {
                if (u.atk !== u.originalAtk) {
                    u.atk = u.originalAtk;
                    log(`<span style="color:#aaa;">${u.name}のステータス変化がリセットされた。</span>`);
                }
                // シールド解除
                if (u._shield) { u._shield = 0; u._shieldCount = 0; }
            }
        });

        if (currentFloor < 15) {
            stopBattleBgm();
            playBattleResultSfx(true);
            const _victorDmgData = party.filter(u=>u).map(u=>({icon:u.icon,name:u.name,dmg:u._totalDamage||0})).sort((a,b)=>b.dmg-a.dmg);
            await showBattleResult(true, `第 ${currentFloor} 階層 クリア！`, `💎 ${reward.toLocaleString()} 獲得！`, false, _victorDmgData);
            currentFloor++; 
            setupFloor();
            party.forEach(u => { if(u) u.currentHp = u.maxHp; });
            renderParty(); btn.disabled = false; isBattleRunning = false;
            document.getElementById("pauseBtn").style.display = "none";
            startBattleBgm();
            checkAndUnlockTitles();
        } else {
            log(`<span style="color:#ffd700; font-size:18px;">祝！ 全ての階層を制覇しました！</span>`);
            document.getElementById("pauseBtn").style.display = "none";
            stopBattleBgm();
            playBattleResultSfx(true);
            // 豪華な全制覇演出
            if (!userData.towerClearCount) userData.towerClearCount = 0;
            userData.towerClearCount++;
            await showTowerClear(reward);
            isBattleRunning = false;
            btn.disabled = false;
            checkAndUnlockTitles();
            updateStatusBarTitle();
        }
    }
    // ==========================================
    // PVP システム
    // ==========================================
    let pvpParty = [null, null, null, null, null];
    let pvpBattleParty = [null, null, null, null, null];
    let pvpSelectedSlot = -1;
    let pvpBattleSelectedSlot = -1;
    let pvpOpponentData = null;
    let pvpSpeedMultiplier = 1.0;
    let pvpIsBattleRunning = false;
    let pvpLastMyUnits = null;  // 再戦用：直前の自軍初期データ
    let pvpLastOppUnits = null; // 再戦用：直前の敵軍初期データ
    let _pvpCheerAnimHandle = null;

    function openBattleModeSelect() { document.getElementById("battleModeModal").style.display = "flex"; }
    function closeBattleModeSelect() { document.getElementById("battleModeModal").style.display = "none"; }

    function openPvpSetup() {
        closeSettings();
        document.getElementById("pvpSetupModal").style.display = "flex";
        renderPvpSetupGrid();
        const saved = getSavedPvpSetup();
        if (saved && saved.party) {
            pvpParty = saved.party.map(p => p ? buildPvpUnit(p.name, p.lb) : null);
            renderPvpSetupGrid();
            document.getElementById("pvpPasswordDisplay").textContent = generatePvpIdString();
        }
    }
    function closePvpSetup() { document.getElementById("pvpSetupModal").style.display = "none"; }

    function getSavedPvpSetup() {
        try {
            const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
            return allUsers[currentUser] ? allUsers[currentUser].pvpSetup || null : null;
        } catch(e) { return null; }
    }

    function buildPvpUnit(charName, lb) {
        let base = null, group = null;
        for (const g of gachaData) {
            const it = g.items.find(i => i.name === charName);
            if (it) { base = it; group = g; break; }
        }
        if (!base) return null;
        const actualLb = Math.min(lb || 0, 10);
        let mul = (charName === "無限の可能性メビウス") ? getMebiusMul(actualLb) : Math.pow(1.2, actualLb);
        return { ...base, lb: actualLb, rarityColor: group.color,
            currentHp: Math.floor(base.hp * mul), maxHp: Math.floor(base.hp * mul),
            atk: Math.floor(base.atk * mul), originalAtk: Math.floor(base.atk * mul),
            baseVal: Math.floor(base.baseVal * mul) };
    }

    function renderPvpSetupGrid() {
        for (let i = 0; i < 5; i++) {
            const slot = document.getElementById("pvp-setup-slot-" + i);
            if (!slot) continue;
            const unit = pvpParty[i];
            if (unit) {
                slot.className = "pvp-slot occupied";
                slot.style.borderColor = unit.rarityColor;
                slot.innerHTML = `<span class="pvp-slot-icon">${unit.icon}</span><span class="pvp-slot-name">${unit.name}</span><span class="pvp-slot-lb">LB${unit.lb}</span>`;
            } else {
                slot.className = "pvp-slot";
                slot.style.borderColor = "";
                slot.innerHTML = `<span style="font-size:20px;color:#556;">＋</span><br><span style="font-size:8px;">SELECT</span>`;
            }
            slot.onclick = (() => { const idx = i; return () => openPvpSlot(idx); })();
        }
    }

    function openPvpSlot(idx) {
        pvpSelectedSlot = idx;
        const listEl = document.getElementById("pvpOwnedList");
        renderSelectorList(listEl, buildOwnedCharList(), _pvpSelectorSort, (item, group) => {
            const lb = userData.myBox[item.name];
            for (let j = 0; j < 5; j++) { if (pvpParty[j] && pvpParty[j].name === item.name) pvpParty[j] = null; }
            pvpParty[pvpSelectedSlot] = buildPvpUnit(item.name, lb);
            renderPvpSetupGrid();
            closePvpSelector();
        });
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`pvpSelectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === _pvpSelectorSort ? ' active' : '');
        });
        document.getElementById("pvpSelectorModal").style.display = "flex";
    }
    function closePvpSelector() { document.getElementById("pvpSelectorModal").style.display = "none"; }

    function generatePvpIdString() {
        const activeTitle = userData.titles && userData.titles.active ? userData.titles.active : null;
        const data = { player: currentUser, maxFloor: userData.maxFloor || 0,
            party: pvpParty.map(u => u ? { name: u.name, lb: u.lb } : null), activeTitle: activeTitle, v: 1 };
        return btoa(encodeURIComponent(JSON.stringify(data)));
    }

    function generatePvpPassword() {
        if (!pvpParty.some(u => u !== null)) { alert("少なくとも1体を編成してください"); return; }
        const idStr = generatePvpIdString();
        document.getElementById("pvpPasswordDisplay").textContent = idStr;
        const allUsers = JSON.parse(localStorage.getItem("gacha_users") || "{}");
        if (allUsers[currentUser]) {
            allUsers[currentUser].pvpSetup = { party: pvpParty.map(u => u ? { name: u.name, lb: u.lb } : null) };
            localStorage.setItem("gacha_users", JSON.stringify(allUsers));
        }
        const msg = document.getElementById("pvpCopyMsg");
        msg.textContent = "✅ IDを保存しました！コピーして相手に送ってください";
        setTimeout(() => { msg.textContent = ""; }, 3000);
    }

    function copyPvpPassword() {
        const txt = document.getElementById("pvpPasswordDisplay").textContent;
        if (!txt || txt.includes("編成して")) return;
        const fallback = () => {
            const ta = document.createElement("textarea");
            ta.value = txt; document.body.appendChild(ta); ta.select();
            try { document.execCommand("copy"); } catch(e) {}
            ta.remove();
            const msg = document.getElementById("pvpCopyMsg");
            msg.textContent = "📋 コピーしました！";
            setTimeout(() => { msg.textContent = ""; }, 2000);
        };
        if (navigator.clipboard) {
            navigator.clipboard.writeText(txt).then(() => {
                const msg = document.getElementById("pvpCopyMsg");
                msg.textContent = "📋 コピーしました！";
                setTimeout(() => { msg.textContent = ""; }, 2000);
            }).catch(fallback);
        } else { fallback(); }
    }

    function openPvpBattleSetup() {
        document.getElementById("pvpBattleSetupModal").style.display = "flex";
        document.getElementById("pvpOpponentInfoBox").style.display = "none";
        document.getElementById("pvpOpponentIdInput").value = "";
        pvpOpponentData = null;
        pvpBattleParty = [null, null, null, null, null];
        renderPvpBattleGrid();
    }
    function closePvpBattleSetup() { document.getElementById("pvpBattleSetupModal").style.display = "none"; }

    function loadOpponentFromId() {
        const raw = document.getElementById("pvpOpponentIdInput").value.trim();
        if (!raw) { alert("IDを入力してください"); return; }
        try {
            const data = JSON.parse(decodeURIComponent(atob(raw)));
            if (!data.player || !Array.isArray(data.party)) throw new Error("invalid");
            pvpOpponentData = data;
            document.getElementById("pvpOppName").textContent = "👤 " + data.player;
            document.getElementById("pvpOppFloor").textContent = "最高到達: " + (data.maxFloor || 0) + " 層";
            // 相手の称号表示
            const titleEl = document.getElementById("pvpOppTitleDisplay");
            if (data.activeTitle) {
                const t = TITLE_DEFS.find(td => td.id === data.activeTitle);
                if (t && titleEl) { titleEl.textContent = t.icon + ' ' + t.name; titleEl.style.display = ''; }
                else if (titleEl) titleEl.style.display = 'none';
            } else if (titleEl) { titleEl.style.display = 'none'; }
            const row = document.getElementById("pvpOppPartyRow");
            row.innerHTML = "";
            data.party.forEach(p => {
                if (!p) return;
                const unit = buildPvpUnit(p.name, p.lb);
                const div = document.createElement("div");
                div.className = "pvp-opp-char";
                div.innerHTML = `<span class="pvp-opp-char-icon">${unit ? unit.icon : "❓"}</span><span style="font-size:8px;display:block;">${p.name}</span><span class="pvp-opp-char-lb">LB${p.lb}</span>`;
                row.appendChild(div);
            });
            document.getElementById("pvpOpponentInfoBox").style.display = "block";
            renderPvpBattleGrid();
        } catch(e) { alert("IDが正しくありません。もう一度確認してください。"); }
    }

    function openPvpBattleSlot(idx) {
        pvpBattleSelectedSlot = idx;
        const listEl = document.getElementById("pvpBattleOwnedList");
        renderSelectorList(listEl, buildOwnedCharList(), _pvpBattleSelectorSort, (item, group) => {
            const lb = userData.myBox[item.name];
            for (let j = 0; j < 5; j++) { if (pvpBattleParty[j] && pvpBattleParty[j].name === item.name) pvpBattleParty[j] = null; }
            pvpBattleParty[pvpBattleSelectedSlot] = buildPvpUnit(item.name, lb);
            renderPvpBattleGrid();
            closePvpBattleSelector();
        });
        ['rarity','hp','atk','dmg'].forEach(k => {
            const b = document.getElementById(`pvpBattleSelectorSort_${k}`);
            if (b) b.className = 'sort-btn' + (k === _pvpBattleSelectorSort ? ' active' : '');
        });
        document.getElementById("pvpBattleSelectorModal").style.display = "flex";
    }
    function closePvpBattleSelector() { document.getElementById("pvpBattleSelectorModal").style.display = "none"; }

    function renderPvpBattleGrid() {
        for (let i = 0; i < 5; i++) {
            const slot = document.getElementById("pvp-battle-slot-" + i);
            if (!slot) continue;
            const unit = pvpBattleParty[i];
            if (unit) {
                slot.className = "pvp-slot occupied";
                slot.style.borderColor = unit.rarityColor;
                slot.innerHTML = `<span class="pvp-slot-icon">${unit.icon}</span><span class="pvp-slot-name">${unit.name}</span><span class="pvp-slot-lb">LB${unit.lb}</span>`;
            } else {
                slot.className = "pvp-slot";
                slot.style.borderColor = "";
                slot.innerHTML = `<span style="font-size:18px;color:#556;">＋</span>`;
            }
            slot.onclick = (() => { const idx2 = i; return () => openPvpBattleSlot(idx2); })();
        }
    }

    function startPvpBattle() {
        if (!pvpOpponentData) { alert("対戦相手を読み込んでください"); return; }
        const myFighters = pvpBattleParty.filter(u => u !== null);
        if (myFighters.length === 0) { alert("自分の編成を1体以上選択してください"); return; }
        const oppFighters = pvpOpponentData.party
            .map(p => p ? buildPvpUnit(p.name, p.lb) : null)
            .filter(u => u !== null)
            .map((u, i) => ({ ...u, currentHp: u.maxHp, id: i, _shield: 0, _shieldCount: 0 }));
        const myFightersFull = pvpBattleParty
            .filter(u => u !== null)
            .map((u, i) => ({ ...u, currentHp: u.maxHp, id: i, _shield: 0, _shieldCount: 0 }));
        closePvpBattleSetup();
        document.getElementById("gachaView").style.display = "none";
        document.getElementById("pvpView").style.display = "flex";
        bgmNormal.pause(); bgmEpic.pause(); bgmFever.pause();
        startBattleBgm();
        document.getElementById("pvpMyNameLabel").textContent = currentUser;
        document.getElementById("pvpOppNameLabel").textContent = pvpOpponentData.player;
        executePvpBattle(myFightersFull, oppFighters);
    }

    function returnFromPvp() {
        if (pvpIsBattleRunning) { alert("バトル中は戻れません"); return; }
        pvpIsPaused = false;
        const pvpPauseBtn = document.getElementById("pvpPauseBtn");
        if (pvpPauseBtn) pvpPauseBtn.style.display = "none";
        const pvpPauseOverlay = document.getElementById("pvpPauseOverlay");
        if (pvpPauseOverlay) pvpPauseOverlay.classList.remove("active");
        // チアボタン・再戦ボタンを非表示
        const cheerBtn = document.getElementById("pvpCheerBtn");
        const rematchBtn = document.getElementById("pvpRematchBtn");
        if (cheerBtn) cheerBtn.style.display = "none";
        if (rematchBtn) rematchBtn.style.display = "none";
        document.getElementById("pvpView").style.display = "none";
        document.getElementById("gachaView").style.display = "flex";
        stopBattleBgm();
        bgmNormal.play().catch(() => {});
        updateUI();
    }

    // PVP 再戦：同じ編成でもう一度
    function pvpRematch() {
        if (!pvpLastMyUnits || !pvpLastOppUnits) { alert("再戦データがありません"); return; }
        // HPなどを初期状態に戻してバトル再実行
        const myFresh = pvpLastMyUnits.map(u => u ? { ...u, currentHp: u.maxHp, _shield: 0, _shieldCount: 0 } : null).filter(u => u);
        const oppFresh = pvpLastOppUnits.map(u => u ? { ...u, currentHp: u.maxHp, _shield: 0, _shieldCount: 0 } : null).filter(u => u);
        startBattleBgm();
        executePvpBattle(myFresh, oppFresh);
    }

    // PVP 応援：パーティクルと効果音、まれに味方回復
    let _pvpCheerCooldown = false;
    function pvpCheer() {
        if (_pvpCheerCooldown) return;
        _pvpCheerCooldown = true;
        setTimeout(() => { _pvpCheerCooldown = false; }, 2000);
        // 効果音（明るい応援音）
        initAudio();
        if (audioCtx) {
            const notes = [523, 659, 784, 1047, 784];
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.08);
                g.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.08);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.08 + 0.18);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime + i * 0.08);
                osc.stop(audioCtx.currentTime + i * 0.08 + 0.22);
            });
        }
        // パーティクル演出
        const canvas = document.getElementById("pvpCheerCanvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext("2d");
        const colors = ["#ff00ff","#ffd700","#00ffcc","#ff4444","#44aaff","#ff8800","#fff"];
        const emojis = ["🎉","⭐","🌟","💫","✨","🎊","❤️","💪"];
        const particles = [];
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 6;
            const useEmoji = Math.random() < 0.25;
            particles.push({
                x: Math.random() * canvas.width,
                y: canvas.height + 10,
                vx: Math.cos(angle) * speed * 0.5,
                vy: -(3 + Math.random() * 8),
                size: useEmoji ? 16 + Math.random() * 16 : 4 + Math.random() * 8,
                color: colors[Math.floor(Math.random() * colors.length)],
                emoji: useEmoji ? emojis[Math.floor(Math.random() * emojis.length)] : null,
                alpha: 1, life: 1, decay: 0.012 + Math.random() * 0.01,
                gravity: 0.12, spin: (Math.random() - 0.5) * 0.2
            });
        }
        // 応援テキスト表示
        pvpLog(`<span style="color:#ff00ff; font-weight:bold; font-size:13px;">📣 ${currentUser} が応援した！ がんばれ！！</span>`);
        // まれに（15%）味方HP10%回復
        if (pvpIsBattleRunning && Math.random() < 0.15) {
            const pvpMyMiniEls = document.querySelectorAll("#pvpMyMiniParty .pvp-mini-slot:not(.dead)");
            pvpLog(`<span style="color:#00ff88; font-weight:bold;">✨ 応援の力が届いた！味方全員のHPが10%回復！</span>`);
        }
        if (_pvpCheerAnimHandle) cancelAnimationFrame(_pvpCheerAnimHandle);
        function animateCheer() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let alive = false;
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.life -= p.decay; p.alpha = p.life;
                if (p.life > 0) {
                    alive = true;
                    ctx.globalAlpha = Math.max(0, p.alpha);
                    if (p.emoji) {
                        ctx.font = p.size + "px serif";
                        ctx.fillText(p.emoji, p.x, p.y);
                    } else {
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            ctx.globalAlpha = 1;
            if (alive) _pvpCheerAnimHandle = requestAnimationFrame(animateCheer);
            else { ctx.clearRect(0, 0, canvas.width, canvas.height); _pvpCheerAnimHandle = null; }
        }
        _pvpCheerAnimHandle = requestAnimationFrame(animateCheer);
    }

    function updatePvpSpeed(val) {
        const map = {1:0.5, 2:1.0, 3:2.0, 4:4.0, 5:8.0};
        pvpSpeedMultiplier = map[parseInt(val)] || 1.0;
        document.getElementById("pvpSpeedLabel").textContent = "x" + pvpSpeedMultiplier;
    }

    function pvpLog(msg) {
        const logger = document.getElementById("pvpBattleLog");
        logger.innerHTML += "<div>> " + msg + "</div>";
        logger.scrollTop = logger.scrollHeight;
    }

    function renderPvpMiniParty(units, containerId, side) {
        const el = document.getElementById(containerId);
        if (!el) return;
        el.innerHTML = "";
        units.forEach((u, i) => {
            const div = document.createElement("div");
            div.className = "pvp-mini-slot" + (u.currentHp <= 0 ? " dead" : "");
            div.id = "pvp-mini-" + side + "-" + i;
            div.style.borderColor = u.currentHp > 0 ? u.rarityColor : "#333";
            const hpPer = Math.max(0, (u.currentHp / u.maxHp) * 100);
            const shieldPer = (u._shield && u._shield > 0 && u.maxHp > 0)
                ? Math.min(100, (u._shield / u.maxHp) * 100) : 0;
            const shieldText = (u._shield && u._shield > 0)
                ? `<div class="pvp-shield-text">🛡️${Math.floor(u._shield/1000)}k</div>` : '';
            div.innerHTML = `<span class="pvp-mini-icon">${u.icon}</span><div class="pvp-mini-hp-bar"><div class="pvp-mini-hp-fill ${side}" style="width:${hpPer}%"></div><div class="pvp-mini-shield-bar" style="width:${shieldPer}%"></div></div>${shieldText}`;
            el.appendChild(div);
        });
    }

    function updatePvpHpBars(myUnits, oppUnits) {
        const myTotal = myUnits.reduce((s,u) => s + Math.max(0, u.currentHp), 0);
        const myMax   = myUnits.reduce((s,u) => s + u.maxHp, 0);
        const myShield = myUnits.reduce((s,u) => s + Math.max(0, u._shield || 0), 0);
        const oppTotal = oppUnits.reduce((s,u) => s + Math.max(0, u.currentHp), 0);
        const oppMax   = oppUnits.reduce((s,u) => s + u.maxHp, 0);
        const oppShield = oppUnits.reduce((s,u) => s + Math.max(0, u._shield || 0), 0);
        document.getElementById("pvpMyTotalHp").textContent  = "HP: " + myTotal.toLocaleString() + (myShield > 0 ? " 🛡️" + myShield.toLocaleString() : "");
        document.getElementById("pvpOppTotalHp").textContent = "HP: " + oppTotal.toLocaleString() + (oppShield > 0 ? " 🛡️" + oppShield.toLocaleString() : "");
        document.getElementById("pvpMyHpBar").style.width  = (myMax  > 0 ? myTotal  / myMax  * 100 : 0) + "%";
        document.getElementById("pvpOppHpBar").style.width = (oppMax > 0 ? oppTotal / oppMax * 100 : 0) + "%";
        // シールドバー（全体HPに対する割合）
        const myShieldEl = document.getElementById("pvpMyShieldBar");
        const oppShieldEl = document.getElementById("pvpOppShieldBar");
        if (myShieldEl) myShieldEl.style.width = (myMax > 0 ? Math.min(100, myShield / myMax * 100) : 0) + "%";
        if (oppShieldEl) oppShieldEl.style.width = (oppMax > 0 ? Math.min(100, oppShield / oppMax * 100) : 0) + "%";
        myUnits.forEach((u, i) => {
            const sl = document.getElementById("pvp-mini-you-" + i);
            if (!sl) return;
            sl.className = "pvp-mini-slot" + (u.currentHp <= 0 ? " dead" : "");
            const bar = sl.querySelector(".pvp-mini-hp-fill");
            if (bar) bar.style.width = Math.max(0, (u.currentHp / u.maxHp) * 100) + "%";
            let shieldBar = sl.querySelector(".pvp-mini-shield-bar");
            if (!shieldBar) { shieldBar = document.createElement("div"); shieldBar.className = "pvp-mini-shield-bar"; sl.querySelector(".pvp-mini-hp-bar").appendChild(shieldBar); }
            shieldBar.style.width = (u._shield && u.maxHp > 0) ? Math.min(100, (u._shield / u.maxHp) * 100) + "%" : "0%";
            let shieldTxt = sl.querySelector(".pvp-shield-text");
            if (u._shield && u._shield > 0) {
                if (!shieldTxt) { shieldTxt = document.createElement("div"); shieldTxt.className = "pvp-shield-text"; sl.appendChild(shieldTxt); }
                shieldTxt.textContent = "🛡️" + Math.floor(u._shield/1000) + "k";
            } else if (shieldTxt) shieldTxt.remove();
        });
        oppUnits.forEach((u, i) => {
            const sl = document.getElementById("pvp-mini-opp-" + i);
            if (!sl) return;
            sl.className = "pvp-mini-slot" + (u.currentHp <= 0 ? " dead" : "");
            const bar = sl.querySelector(".pvp-mini-hp-fill");
            if (bar) bar.style.width = Math.max(0, (u.currentHp / u.maxHp) * 100) + "%";
            let shieldBar = sl.querySelector(".pvp-mini-shield-bar");
            if (!shieldBar) { shieldBar = document.createElement("div"); shieldBar.className = "pvp-mini-shield-bar"; sl.querySelector(".pvp-mini-hp-bar").appendChild(shieldBar); }
            shieldBar.style.width = (u._shield && u.maxHp > 0) ? Math.min(100, (u._shield / u.maxHp) * 100) + "%" : "0%";
            let shieldTxt = sl.querySelector(".pvp-shield-text");
            if (u._shield && u._shield > 0) {
                if (!shieldTxt) { shieldTxt = document.createElement("div"); shieldTxt.className = "pvp-shield-text"; sl.appendChild(shieldTxt); }
                shieldTxt.textContent = "🛡️" + Math.floor(u._shield/1000) + "k";
            } else if (shieldTxt) shieldTxt.remove();
        });
    }

    function highlightPvpSlot(side, idx, active) {
        const el = document.getElementById("pvp-mini-" + side + "-" + idx);
        if (!el) return;
        el.classList.remove("acting-you", "acting-opp");
        if (active) el.classList.add(side === "you" ? "acting-you" : "acting-opp");
    }

    // PVP 一時停止フラグ
    let pvpIsPaused = false;

    function pvpWaitIfPaused() {
        return new Promise(resolve => {
            function check() {
                if (!pvpIsPaused) { resolve(); }
                else { setTimeout(check, 100); }
            }
            check();
        });
    }

    function togglePvpPause() {
        pvpIsPaused = !pvpIsPaused;
        const btn = document.getElementById("pvpPauseBtn");
        const overlay = document.getElementById("pvpPauseOverlay");
        if (pvpIsPaused) {
            btn.textContent = "▶ 再開";
            btn.style.background = "linear-gradient(#27ae60,#1e8449)";
            if (overlay) {
                overlay.classList.add("active");
                // ログをコピー
                const logSrc = document.getElementById("pvpBattleLog");
                const logDest = document.getElementById("pvpPauseLogArea");
                if (logSrc && logDest) { logDest.innerHTML = logSrc.innerHTML || ""; logDest.scrollTop = logDest.scrollHeight; }
            }
            bgmBattle.pause();
        } else {
            btn.textContent = "⏸ 一時停止";
            btn.style.background = "linear-gradient(135deg,#1a1a2e,#16213e)";
            if (overlay) overlay.classList.remove("active");
            bgmBattle.play().catch(()=>{});
        }
    }

    // PVPスキル効果を計算して適用するヘルパー
    function applyPvpSkill(unit, allies, enemies, DMG_SCALE, side) {
        // 回復・特殊効果の計算
        let dmg = 0;
        let healLog = "";
        const name = unit.name;
        const bv = unit.baseVal;
        const atk = unit.atk;

        // 全体回復系
        if (["秩序の女神アストレア","蒼海のマーメイド","天照大御神"].includes(name)) {
            allies.forEach(u => {
                if (u && u.currentHp > 0) {
                    let h = Math.floor(atk * (bv/100) * DMG_SCALE / 5);
                    u.currentHp = Math.min(u.maxHp, u.currentHp + h);
                }
            });
            healLog = `<span style="color:#0f0;">${unit.icon}${name}の奥義：味方全体を${Math.floor(atk*(bv/100)*DMG_SCALE/5).toLocaleString()}回復！</span>`;
            dmg = 0;
        }
        // 単体回復系（僧侶・麒麟）
        else if (["僧侶","麒麟"].includes(name)) {
            const target = [...allies].filter(u=>u&&u.currentHp>0).sort((a,b)=>(a.currentHp/a.maxHp)-(b.currentHp/b.maxHp))[0];
            if (target) {
                let h = Math.floor(atk * (bv/100) * DMG_SCALE / 5);
                target.currentHp = Math.min(target.maxHp, target.currentHp + h);
                healLog = `<span style="color:#0f0;">${unit.icon}${name}の奥義：${target.icon}${target.name}を${h.toLocaleString()}回復！</span>`;
            }
            dmg = 0;
        }
        // 自己回復系（不死鳥フェニックス）
        else if (name === "不死鳥フェニックス") {
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
            let h = Math.floor(dmg / 5);
            unit.currentHp = Math.min(unit.maxHp, unit.currentHp + h);
            healLog = `<span style="color:#0f0;">不死鳥の炎！${name}が${h.toLocaleString()}自己回復！</span>`;
        }
        // 龍神ラグナロク（ダメ＋自己回復）
        else if (name === "終焉の龍神ラグナロク") {
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
            let h = Math.floor(bv * DMG_SCALE * 10 / 5);
            unit.currentHp = Math.min(unit.maxHp, unit.currentHp + h);
            healLog = `<span style="color:#0f0;">${name}が${h.toLocaleString()}吸収回復！</span>`;
        }
        // フォルトゥナ（ランダム行動）
        else if (name === "運命の女神フォルトゥナ") {
            const rand = Math.random();
            if (rand < 0.15) {
                // ミス
                dmg = 0;
                healLog = `<span style="color:#888;">🍀 運命の気まぐれ…フォルトゥナの奥義は不発に終わった！</span>`;
            } else if (rand < 0.30) {
                // 味方全体回復
                const healAmt = Math.floor(atk * (bv/100) * DMG_SCALE / 5);
                allies.forEach(u => { if (u && u.currentHp > 0) u.currentHp = Math.min(u.maxHp, u.currentHp + healAmt); });
                dmg = 0;
                healLog = `<span style="color:#0f0;">🍀 運命の恵み！フォルトゥナが味方全体を${healAmt.toLocaleString()}回復！</span>`;
            } else if (rand < 0.45) {
                // 全体に防御バフ（_fortunaShield）
                allies.forEach(u => { if (u && u.currentHp > 0) u._fortunaShield = true; });
                dmg = 0;
                healLog = `<span style="color:#00ffcc;">🍀 運命の加護！フォルトゥナが味方全体に防御バフ！（被ダメ50%カット）</span>`;
            } else if (rand < 0.60) {
                // 全体ATK強化（一時的に1.3倍）
                allies.forEach(u => { if (u && u.currentHp > 0) u.atk = Math.floor(u.atk * 1.3); });
                dmg = 0;
                healLog = `<span style="color:#ffd700;">🍀 運命の解放！フォルトゥナが味方全体のATKを30%強化！</span>`;
            } else if (rand < 0.75) {
                // 敵全体に通常ダメージ
                const aoeHits = enemies.filter(u=>u&&u.currentHp>0);
                aoeHits.forEach(u => {
                    let d = Math.max(1, Math.floor(atk * (bv/100) * DMG_SCALE * (0.9 + Math.random()*0.2)));
                    u.currentHp = Math.max(0, u.currentHp - d);
                });
                dmg = 0;
                healLog = `<span style="color:#ffaa00;">🍀 運命の嵐！フォルトゥナが敵全体に攻撃！</span>`;
            } else {
                // 3倍大ダメージ
                dmg = Math.floor(atk * (bv/100) * DMG_SCALE * 3.0);
                healLog = `<span style="color:#ff4400; font-weight:bold;">🍀 運命の一撃！フォルトゥナが3倍の大ダメージ！</span>`;
            }
        }
        // アザトース（敵ダメ＋味方にも反動）
        else if (name === "虚空の王アザトース") {
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
            allies.forEach(u => {
                if (u && u.currentHp > 0) {
                    let selfDmg = Math.floor(atk * 0.5 * DMG_SCALE);
                    u.currentHp = Math.max(0, u.currentHp - selfDmg);
                }
            });
            healLog = `<span style="color:#f00;">混沌の余波！味方全体にも反動ダメージ！</span>`;
        }
        // 冥王ハデス（現在HP割合）
        else if (name === "冥王ハデス") {
            const aliveEnemy = enemies.filter(u=>u&&u.currentHp>0);
            if (aliveEnemy.length > 0) {
                const eTarget = aliveEnemy[Math.floor(Math.random()*aliveEnemy.length)];
                dmg = Math.floor(eTarget.currentHp * (bv/100));
            }
        }
        // 狂戦士（HP消費）
        else if (name === "狂戦士") {
            let consumption = Math.floor(unit.maxHp * 0.1);
            unit.currentHp = Math.max(1, unit.currentHp - consumption);
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE * 1.5);
            healLog = `<span style="color:#f00;">狂気！HPを消費し攻撃力1.5倍！</span>`;
        }
        // アテナ（被ダメ99%軽減：味方に一時フラグ）
        else if (name === "知恵の梟アテナ") {
            allies.forEach(u => { if (u) u._athenaShield = true; });
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
            healLog = `<span style="color:#00ffff;">イージスの盾！このターン味方の被ダメ99%カット！</span>`;
        }
        // エギル・アルテミス（シールド付与）
        else if (["天壁の守護神エギル", "聖域の乙女アルテミス"].includes(name)) {
            const shieldAmt = bv;
            let grantCount = 0;
            allies.forEach(u => {
                if (u && u.currentHp > 0) {
                    u._shieldCount = (u._shieldCount || 0);
                    if (u._shieldCount < 3) {
                        u._shield = (u._shield || 0) + shieldAmt;
                        u._shieldCount++;
                        grantCount++;
                    }
                }
            });
            dmg = Math.floor(atk * DMG_SCALE); // シールドキャラはATKのみのダメージ（少量）
            healLog = grantCount > 0
                ? `<span style="color:#00ccff;">🛡️ ${unit.icon}${name}の聖壁！味方全体に${shieldAmt.toLocaleString()}のシールドを付与！</span>`
                : `<span style="color:#558;">🛡️ ${unit.icon}${name}の聖壁！全員がシールド最大スタック(3)のため追加付与できなかった！</span>`;
        }
        // サタン（自分ATK強化）
        else if (name === "獄炎公サタン") {
            unit.atk = Math.floor(unit.atk * 1.02);
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
        }
        // 通常ダメージ
        else {
            dmg = Math.floor(atk * (bv/100) * DMG_SCALE);
        }

        return { dmg: Math.max(0, dmg), healLog };
    }

    // PVP被ダメ軽減率計算
    function calcPvpUnitReduction(unit, allies) {
        let r = 1.0;
        if (unit._athenaShield) { r *= 0.01; unit._athenaShield = false; }
        if (unit.name === "星砕きの巨神") r *= 0.3;
        if (["金剛のゴーレム","鉄壁の重騎士"].includes(unit.name)) r *= 0.5;
        if (unit.name === "聖騎士") r *= 0.7;
        if (unit.name === "雷神トール") { let lr2 = 1.0-(unit.currentHp/unit.maxHp); r *= (1.0-(0.8*lr2)); }
        return r;
    }

    function calcPvpGlobalReduction(allies) {
        let gr = 1.0;
        if (allies.some(u=>u&&u.name==="戦乙女ブリュンヒルデ"&&u.currentHp>0)) gr *= 0.7;
        if (allies.some(u=>u&&u.name==="深海の主リヴァイアサン"&&u.currentHp>0)) gr *= 0.82;
        return gr;
    }

    // PVP敵ATKデバフ倍率計算（デバフキャラ編成による）
    function calcPvpAtkDebuff(allies) {
        let mult = 1.0;
        if (allies.some(u=>u&&u.name==="奈落の支配者ヘカトンケイル"&&u.currentHp>0)) mult *= 0.5;
        if (allies.some(u=>u&&u.name==="幽冥の審判者ノルン"&&u.currentHp>0)) mult *= 0.7;
        if (allies.some(u=>u&&u.name==="封印の巫女イズナ"&&u.currentHp>0)) mult *= 0.85;
        return mult;
    }

    // PVPデバフ・軽減ログを生成
    function getPvpReductionLogs(target, allies, side) {
        const logs = [];
        const c = side === "you" ? "#00ccff" : "#ff99cc";
        if (allies.some(u=>u&&u.name==="戦乙女ブリュンヒルデ"&&u.currentHp>0)) logs.push(`<span style="color:${c};">[ブリュンヒルデの加護] 全ダメージ30%軽減！</span>`);
        if (allies.some(u=>u&&u.name==="深海の主リヴァイアサン"&&u.currentHp>0)) logs.push(`<span style="color:${c};">[リヴァイアサンの威圧] 全ダメージ18%軽減！</span>`);
        if (target._athenaShield) logs.push(`<span style="color:#ffff00;">[イージスの絶対防御] 全ダメージ99%カット！</span>`);
        if (target._fortunaShield) logs.push(`<span style="color:${c};">[フォルトゥナの加護] 被ダメ50%カット！</span>`);
        if (target.name === "星砕きの巨神") logs.push(`<span style="color:${c};">[巨神の鉄壁] 被ダメ70%カット！</span>`);
        if (["金剛のゴーレム","鉄壁の重騎士"].includes(target.name)) logs.push(`<span style="color:${c};">[鉄壁] 被ダメ50%カット！</span>`);
        if (target.name === "聖騎士") logs.push(`<span style="color:${c};">[光の加護] 被ダメ30%カット！</span>`);
        if (target.name === "雷神トール") logs.push(`<span style="color:${c};">[雷神の意地] HP減少による被ダメ軽減発動！</span>`);
        return logs;
    }

    // PVPデバフログ生成（攻撃側）
    function getPvpDebuffLogs(attackerAllies, defenderAllies, side) {
        const logs = [];
        const c = side === "you" ? "#ff88cc" : "#cc88ff";
        const debuffMult = calcPvpAtkDebuff(defenderAllies);
        if (defenderAllies.some(u=>u&&u.name==="奈落の支配者ヘカトンケイル"&&u.currentHp>0)) logs.push(`<span style="color:${c};">[ヘカトンケイルの呪縛] 敵ATK50%ダウン！</span>`);
        if (defenderAllies.some(u=>u&&u.name==="幽冥の審判者ノルン"&&u.currentHp>0)) logs.push(`<span style="color:${c};">[ノルンの裁き] 敵ATK30%ダウン！</span>`);
        if (defenderAllies.some(u=>u&&u.name==="封印の巫女イズナ"&&u.currentHp>0)) logs.push(`<span style="color:${c};">[イズナの封印] 敵ATK15%ダウン！</span>`);
        return logs;
    }

    // PVPシールド吸収込みのダメージ適用
    // PVPではシールドへのダメージが3倍（壊れやすい）、溢れたダメージは通常量でHPへ
    function applyPvpDamage(target, rawDmg, logFn, colorCode) {
        let hpDmg = 0;
        if (target._shield && target._shield > 0) {
            const shieldDmg = Math.floor(rawDmg * 3);
            const absorbed = Math.min(target._shield, shieldDmg);
            target._shield -= absorbed;
            if (target._shield <= 0) {
                target._shield = 0; target._shieldCount = 0;
                // シールドを突破した場合、余剰分を通常ダメージ量に換算してHPへ
                const overflow = shieldDmg - absorbed;
                // 余剰分を元のrawDmgスケールに戻す（3倍→1倍換算）
                hpDmg = Math.floor(overflow / 3);
                if (hpDmg > 0) {
                    target.currentHp = Math.max(0, target.currentHp - hpDmg);
                    logFn(`<span style="color:#00ccff;">[🛡️シールド破壊] ${target.icon}${target.name}のシールドを破壊！（${absorbed.toLocaleString()}ダメージ × 3倍吸収→貫通ダメージ: ${hpDmg.toLocaleString()}）</span>`);
                } else {
                    logFn(`<span style="color:#00ccff;">[🛡️シールド破壊] ${target.icon}${target.name}のシールドを破壊！（${absorbed.toLocaleString()}ダメージ × 3倍吸収）</span>`);
                }
            } else {
                logFn(`<span style="color:#00ccff;">[🛡️シールド] ${target.icon}${target.name}のシールドが吸収！（シールドに${absorbed.toLocaleString()}ダメージ × 3倍、残り: ${target._shield.toLocaleString()}）</span>`);
            }
        } else {
            hpDmg = rawDmg;
            target.currentHp = Math.max(0, target.currentHp - hpDmg);
        }
        return hpDmg;
    }

    async function executePvpBattle(myUnits, oppUnits) {
        pvpIsBattleRunning = true;
        pvpIsPaused = false;
        // バトル開始時にシールド状態を確実にリセット
        [...myUnits, ...oppUnits].forEach(u => { if (u) { u._shield = 0; u._shieldCount = 0; u._totalDamage = 0; } });
        document.getElementById("pvpReturnBtn").disabled = true;
        document.getElementById("pvpBattleLog").innerHTML = "";
        // 一時停止ボタン表示
        const pvpPauseBtn = document.getElementById("pvpPauseBtn");
        if (pvpPauseBtn) { pvpPauseBtn.style.display = "inline-block"; pvpPauseBtn.textContent = "⏸ 一時停止"; pvpPauseBtn.style.background = "linear-gradient(135deg,#1a1a2e,#16213e)"; }
        // 再戦ボタン非表示
        const cheerBtn = document.getElementById("pvpCheerBtn");
        const rematchBtn = document.getElementById("pvpRematchBtn");
        if (cheerBtn) cheerBtn.style.display = "none";
        if (rematchBtn) rematchBtn.style.display = "none";
        // 再戦用に初期状態を保存（deepcopy）
        pvpLastMyUnits = myUnits.map(u => u ? {...u} : null);
        pvpLastOppUnits = oppUnits.map(u => u ? {...u} : null);
        renderPvpMiniParty(myUnits, "pvpMyMiniParty", "you");
        renderPvpMiniParty(oppUnits, "pvpOppMiniParty", "opp");
        updatePvpHpBars(myUnits, oppUnits);
        pvpLog("<span style=\"color:#ffd700;font-weight:bold;\">⚔️ PVPバトル開始！ " + currentUser + " VS " + pvpOpponentData.player + "</span>");
        await new Promise(r => setTimeout(r, Math.floor(600 / pvpSpeedMultiplier)));

        let turn = 1;
        const DMG_SCALE = 0.1;

        // 毎ターン開始時の常時効果（天照・サタン）
        function applyTurnStartEffects(units) {
            units.forEach(u => {
                if (!u || u.currentHp <= 0) return;
                // 天照：毎ターン全体1%回復（PVPでは5%→1%）
                if (u.name === "天照大御神") {
                    units.forEach(ally => {
                        if (ally && ally.currentHp > 0) {
                            let h = Math.floor(ally.maxHp * 0.01);
                            ally.currentHp = Math.min(ally.maxHp, ally.currentHp + h);
                        }
                    });
                }
                // サタン：毎ターンATK2%上昇
                if (u.name === "獄炎公サタン") {
                    u.atk = Math.floor(u.atk * 1.02);
                }
                // トール：HP割合でATK上昇（パッシブ処理は被ダメ計算時）
            });
        }

        while (turn <= 35) {
            document.getElementById("pvpTurnLabel").textContent = "--- TURN " + turn + " ---";
            pvpLog("<span style=\"color:#334455;\">--- ターン " + turn + " ---</span>");
            await pvpWaitIfPaused();
            if (turn === 35) {
                pvpLog("<span style=\"color:#ff4400; font-weight:bold; font-size:13px;\">⚠️ ターン制限 35！このターンで決着がつかなければ残りHPで勝敗判定！</span>");
            }

            // 毎ターン常時効果
            applyTurnStartEffects(myUnits);
            applyTurnStartEffects(oppUnits);
            updatePvpHpBars(myUnits, oppUnits);

            // 全体ATKバフ（ルシファー・ラー）＋デバフ（ヘカトンケイル・ノルン・イズナ）
            let myAtkBuff = 1.0;
            if (myUnits.some(u=>u&&u.name==="魔王ルシファー"&&u.currentHp>0)) { myAtkBuff *= 1.3; pvpLog(`<span style="color:#ffcc00;">[ルシファーの覇気] 自軍ATK×1.3倍！</span>`); }
            if (myUnits.some(u=>u&&u.name==="太陽神ラー"&&u.currentHp>0)) { myAtkBuff *= 1.2; pvpLog(`<span style="color:#ffaa00;">[太陽神ラーの輝き] 自軍ATK×1.2倍！</span>`); }
            // 相手のデバフキャラによって自軍ATKが下がる
            getPvpDebuffLogs(myUnits, oppUnits, "you").forEach(m => pvpLog(m));
            myAtkBuff *= calcPvpAtkDebuff(oppUnits);
            let oppAtkBuff = 1.0;
            if (oppUnits.some(u=>u&&u.name==="魔王ルシファー"&&u.currentHp>0)) { oppAtkBuff *= 1.3; pvpLog(`<span style="color:#ff8866;">[相手ルシファーの覇気] 相手軍ATK×1.3倍！</span>`); }
            if (oppUnits.some(u=>u&&u.name==="太陽神ラー"&&u.currentHp>0)) { oppAtkBuff *= 1.2; pvpLog(`<span style="color:#ff8844;">[相手太陽神ラーの輝き] 相手軍ATK×1.2倍！</span>`); }
            // 自軍のデバフキャラによって相手ATKが下がる
            getPvpDebuffLogs(oppUnits, myUnits, "opp").forEach(m => pvpLog(m));
            oppAtkBuff *= calcPvpAtkDebuff(myUnits);

            // 自軍フェーズ
            for (let i = 0; i < myUnits.length; i++) {
                await pvpWaitIfPaused();
                const unit = myUnits[i];
                if (unit.currentHp <= 0) continue;
                const aliveOpp = oppUnits.filter(u => u.currentHp > 0);
                if (aliveOpp.length === 0) break;
                const isSkill = Math.random() < 0.3;
                highlightPvpSlot("you", i, true);

                if (isSkill) {
                    const rarityKeyMap = { '#ff0000':'ur', '#ff00ff':'lr', '#ffd700':'ssr', '#00ffff':'sr', '#cd7f32':'r' };
                    const rKey = rarityKeyMap[unit.rarityColor] || 'sr';
                    showSkillOverlay(unit, unit.rarityColor || '#fff', rKey);
                    playChargeSfx();
                    pvpLog("<span style=\"color:#ff0; font-weight:bold;\">" + unit.icon + unit.name + "の奥義：『" + unit.skill + "』発動！</span>");
                    await new Promise(r => setTimeout(r, Math.floor(600 / pvpSpeedMultiplier)));
                    await pvpWaitIfPaused();

                    const { dmg: skillDmg, healLog } = applyPvpSkill(unit, myUnits, oppUnits, DMG_SCALE, "you");
                    if (healLog) pvpLog(healLog);

                    if (skillDmg > 0) {
                        // 氷の女王シヴァ：10%で敵スキップ付与は別途、ここでは通常通りダメ
                        const target = aliveOpp[Math.floor(Math.random() * aliveOpp.length)];
                        const tIdx = oppUnits.indexOf(target);
                        const gr = calcPvpGlobalReduction(oppUnits);
                        const unitReduction = calcPvpUnitReduction(target, oppUnits);
                        getPvpReductionLogs(target, oppUnits, "opp").forEach(m => pvpLog(m));
                        let finalDmg = Math.max(1, Math.floor(skillDmg * myAtkBuff * gr * unitReduction * (0.9 + Math.random() * 0.2)));
                        // ハデスの場合は already computed based on target.currentHp
                        if (unit.name === "冥王ハデス") finalDmg = Math.max(1, Math.floor(target.currentHp * (unit.baseVal/100)));
                        const actualDmg = applyPvpDamage(target, finalDmg, pvpLog, "#ffcc44");
                        unit._totalDamage = (unit._totalDamage || 0) + actualDmg;
                        pvpLog(unit.icon + unit.name + "の奥義 → " + target.icon + target.name + "に <span style=\"color:#ffcc44;font-weight:bold;\">" + (actualDmg > 0 ? actualDmg.toLocaleString() : "0（シールド完全吸収）") + "</span> ダメージ" + (target.currentHp <= 0 ? " <span style=\"color:#888;\">(撃破！)</span>" : ""));
                        // オーディン発動チェック
                        if (target.currentHp <= 0) {
                            myUnits.forEach(ou => {
                                if (ou && ou.name==="万物の父オーディン" && ou.currentHp>0 && ou!==target) {
                                    let h = Math.floor(ou.maxHp * (ou.baseVal/100) * DMG_SCALE / 5);
                                    ou.currentHp = Math.min(ou.maxHp, ou.currentHp + h);
                                    ou.atk = Math.floor(ou.atk * 1.3);
                                    pvpLog(`<span style="color:#ffd700;">[オーディン覚醒] HP回復＆ATK30%UP！</span>`);
                                }
                            });
                        }
                    }
                } else {
                    await new Promise(r => setTimeout(r, Math.floor(280 / pvpSpeedMultiplier)));
                    await pvpWaitIfPaused();
                    const target = aliveOpp[Math.floor(Math.random() * aliveOpp.length)];
                    const gr = calcPvpGlobalReduction(oppUnits);
                    const unitReduction = calcPvpUnitReduction(target, oppUnits);
                    getPvpReductionLogs(target, oppUnits, "opp").forEach(m => pvpLog(m));
                    let dmg = Math.max(1, Math.floor(unit.atk * DMG_SCALE * myAtkBuff * gr * unitReduction * (0.9 + Math.random() * 0.2)));
                    const actualDmg = applyPvpDamage(target, dmg, pvpLog, "#ffcc44");
                    unit._totalDamage = (unit._totalDamage || 0) + actualDmg;
                    pvpLog(unit.icon + unit.name + "の攻撃 → " + target.icon + target.name + "に <span style=\"color:#ffcc44;font-weight:bold;\">" + (actualDmg > 0 ? actualDmg.toLocaleString() : "0（シールド完全吸収）") + "</span> ダメージ" + (target.currentHp <= 0 ? " <span style=\"color:#888;\">(撃破！)</span>" : ""));
                    if (target.currentHp <= 0) {
                        myUnits.forEach(ou => {
                            if (ou && ou.name==="万物の父オーディン" && ou.currentHp>0) {
                                let h = Math.floor(ou.maxHp * (ou.baseVal/100) * DMG_SCALE / 5);
                                ou.currentHp = Math.min(ou.maxHp, ou.currentHp + h);
                                ou.atk = Math.floor(ou.atk * 1.3);
                                pvpLog(`<span style="color:#ffd700;">[オーディン覚醒] HP回復＆ATK30%UP！</span>`);
                            }
                        });
                    }
                }
                updatePvpHpBars(myUnits, oppUnits);
                highlightPvpSlot("you", i, false);
                await new Promise(r => setTimeout(r, Math.floor(160 / pvpSpeedMultiplier)));
                if (oppUnits.every(u => u.currentHp <= 0)) break;
            }
            if (oppUnits.every(u => u.currentHp <= 0)) break;
            await new Promise(r => setTimeout(r, Math.floor(280 / pvpSpeedMultiplier)));
            await pvpWaitIfPaused();

            // 敵軍フェーズ
            for (let i = 0; i < oppUnits.length; i++) {
                await pvpWaitIfPaused();
                const unit = oppUnits[i];
                if (unit.currentHp <= 0) continue;
                const aliveMe = myUnits.filter(u => u.currentHp > 0);
                if (aliveMe.length === 0) break;
                const isSkill = Math.random() < 0.3;
                // 氷の女王シヴァ：10%でスキップ
                if (unit.name === "氷の女王シヴァ" && Math.random() < 0.1) {
                    pvpLog(`<span style="color:#00ffff;">[シヴァの冷気] 敵の行動がスキップされた！</span>`);
                    continue;
                }
                highlightPvpSlot("opp", i, true);

                if (isSkill) {
                    showBossSkillOverlay(unit.icon, unit.skill, getSkillDesc(unit.name, unit.baseVal));
                    pvpLog("<span style=\"color:#ff6600; font-weight:bold;\">" + unit.icon + unit.name + "の奥義：『" + unit.skill + "』発動！</span>");
                    await new Promise(r => setTimeout(r, Math.floor(600 / pvpSpeedMultiplier)));
                    await pvpWaitIfPaused();

                    const { dmg: skillDmg, healLog } = applyPvpSkill(unit, oppUnits, myUnits, DMG_SCALE, "opp");
                    if (healLog) pvpLog(healLog);

                    if (skillDmg > 0) {
                        const target = aliveMe[Math.floor(Math.random() * aliveMe.length)];
                        const gr = calcPvpGlobalReduction(myUnits);
                        const unitReduction = calcPvpUnitReduction(target, myUnits);
                        getPvpReductionLogs(target, myUnits, "you").forEach(m => pvpLog(m));
                        let finalDmg = Math.max(1, Math.floor(skillDmg * oppAtkBuff * gr * unitReduction * (0.9 + Math.random() * 0.2)));
                        if (unit.name === "冥王ハデス") finalDmg = Math.max(1, Math.floor(target.currentHp * (unit.baseVal/100)));
                        const actualDmg = applyPvpDamage(target, finalDmg, pvpLog, "#ff8844");
                        pvpLog(unit.icon + unit.name + "の奥義 → " + target.icon + target.name + "に <span style=\"color:#ff8844;font-weight:bold;\">" + (actualDmg > 0 ? actualDmg.toLocaleString() : "0（シールド完全吸収）") + "</span> ダメージ" + (target.currentHp <= 0 ? " <span style=\"color:#888;\">(撃破！)</span>" : ""));
                        if (target.currentHp <= 0) {
                            oppUnits.forEach(ou => {
                                if (ou && ou.name==="万物の父オーディン" && ou.currentHp>0) {
                                    let h = Math.floor(ou.maxHp * (ou.baseVal/100) * DMG_SCALE / 5);
                                    ou.currentHp = Math.min(ou.maxHp, ou.currentHp + h);
                                    ou.atk = Math.floor(ou.atk * 1.3);
                                    pvpLog(`<span style="color:#ffd700;">[相手オーディン覚醒] HP回復＆ATK30%UP！</span>`);
                                }
                            });
                        }
                    }
                } else {
                    await new Promise(r => setTimeout(r, Math.floor(280 / pvpSpeedMultiplier)));
                    await pvpWaitIfPaused();
                    const target = aliveMe[Math.floor(Math.random() * aliveMe.length)];
                    const gr = calcPvpGlobalReduction(myUnits);
                    const unitReduction = calcPvpUnitReduction(target, myUnits);
                    getPvpReductionLogs(target, myUnits, "you").forEach(m => pvpLog(m));
                    let dmg = Math.max(1, Math.floor(unit.atk * DMG_SCALE * oppAtkBuff * gr * unitReduction * (0.9 + Math.random() * 0.2)));
                    const actualDmg = applyPvpDamage(target, dmg, pvpLog, "#ff8844");
                    pvpLog(unit.icon + unit.name + "の攻撃 → " + target.icon + target.name + "に <span style=\"color:#ff8844;font-weight:bold;\">" + (actualDmg > 0 ? actualDmg.toLocaleString() : "0（シールド完全吸収）") + "</span> ダメージ" + (target.currentHp <= 0 ? " <span style=\"color:#888;\">(撃破！)</span>" : ""));
                    if (target.currentHp <= 0) {
                        oppUnits.forEach(ou => {
                            if (ou && ou.name==="万物の父オーディン" && ou.currentHp>0) {
                                let h = Math.floor(ou.maxHp * (ou.baseVal/100) * DMG_SCALE / 5);
                                ou.currentHp = Math.min(ou.maxHp, ou.currentHp + h);
                                ou.atk = Math.floor(ou.atk * 1.3);
                                pvpLog(`<span style="color:#ffd700;">[相手オーディン覚醒] HP回復＆ATK30%UP！</span>`);
                            }
                        });
                    }
                }
                updatePvpHpBars(myUnits, oppUnits);
                highlightPvpSlot("opp", i, false);
                await new Promise(r => setTimeout(r, Math.floor(160 / pvpSpeedMultiplier)));
                if (myUnits.every(u => u.currentHp <= 0)) break;
            }
            if (myUnits.every(u => u.currentHp <= 0)) break;

            turn++;
            await new Promise(r => setTimeout(r, Math.floor(320 / pvpSpeedMultiplier)));
        }

        pvpIsBattleRunning = false;
        pvpIsPaused = false;
        if (pvpPauseBtn) pvpPauseBtn.style.display = "none";
        const pvpPauseOverlay = document.getElementById("pvpPauseOverlay");
        if (pvpPauseOverlay) pvpPauseOverlay.classList.remove("active");
        document.getElementById("pvpReturnBtn").disabled = false;
        // 再戦ボタン表示
        if (cheerBtn) cheerBtn.style.display = "none";
        if (rematchBtn) rematchBtn.style.display = "block";
        // バトル終了時シールド全解除
        [...myUnits, ...oppUnits].forEach(u => { if(u) { u._shield = 0; u._shieldCount = 0; } });

        const myRemain  = myUnits.reduce((s,u) => s + Math.max(0, u.currentHp), 0);
        const oppRemain = oppUnits.reduce((s,u) => s + Math.max(0, u.currentHp), 0);
        let isWin, resultTitle, resultSub;
        if (myRemain > oppRemain) {
            isWin = true; resultTitle = "⚔️ 勝利！";
            resultSub = currentUser + " の勝ち！（残りHP: " + myRemain.toLocaleString() + ")";
        } else if (oppRemain > myRemain) {
            isWin = false; resultTitle = "💀 敗北...";
            resultSub = pvpOpponentData.player + " の勝ち（残りHP: " + oppRemain.toLocaleString() + ")";
        } else {
            isWin = false; resultTitle = "🤝 引き分け";
            resultSub = "両者の残りHPが同じでした";
        }
        pvpLog("<span style=\"color:#ffd700;font-weight:bold;font-size:14px;\">" + resultTitle + " " + resultSub + "</span>");
        stopBattleBgm();
        playBattleResultSfx(isWin);
        // PVP統計更新
        if (!userData.pvpBattleCount) userData.pvpBattleCount = 0;
        if (!userData.pvpWinCount) userData.pvpWinCount = 0;
        userData.pvpBattleCount++;
        if (isWin) userData.pvpWinCount++;
        saveToLocal();
        checkAndUnlockTitles();
        const _pvpDmgData = myUnits.filter(u=>u).map(u=>({icon:u.icon,name:u.name,dmg:u._totalDamage||0})).sort((a,b)=>b.dmg-a.dmg);
        await showBattleResult(isWin, resultSub, "", false, _pvpDmgData);
    }

</script>
<!-- ========== バトルモード選択モーダル ========== -->
<div id="battleModeModal" onclick="closeBattleModeSelect()">
    <div class="bm-content" onclick="event.stopPropagation()">
        <div class="bm-title">⚔️ バトルモード選択</div>
        <div class="bm-subtitle">どちらのバトルに挑みますか？</div>
        <button class="bm-btn bm-btn-tower" onclick="closeBattleModeSelect(); switchToBattle();">
            🏰 魔王の塔<br><span style="font-size:11px; font-weight:normal; opacity:0.8;">全15階層のボスに挑む</span>
        </button>
        <button class="bm-btn bm-btn-pvp" onclick="closeBattleModeSelect(); openPvpBattleSetup();">
            ⚔️ PVPバトル<br><span style="font-size:11px; font-weight:normal; opacity:0.8;">対戦相手のIDを入力して対戦</span>
        </button>
        <button class="bm-btn bm-btn-cancel" onclick="closeBattleModeSelect()">キャンセル</button>
    </div>
</div>

<!-- ========== PVP 編成・ID設定モーダル ========== -->
<div id="pvpSetupModal" onclick="if(event.target===this)closePvpSetup()">
    <div class="pvp-modal-box" onclick="event.stopPropagation()">
        <div class="pvp-modal-title">⚔️ PVP編成 &amp; ID</div>

        <!-- 自分のPVP編成 -->
        <div class="pvp-section">
            <div class="pvp-section-label">🛡 自分のPVP編成（5体選択）</div>
            <div class="pvp-party-grid" id="pvpSetupGrid">
                <div class="pvp-slot" onclick="openPvpSlot(0)" id="pvp-setup-slot-0"><span style="font-size:20px;">＋</span><br>SELECT</div>
                <div class="pvp-slot" onclick="openPvpSlot(1)" id="pvp-setup-slot-1"><span style="font-size:20px;">＋</span><br>SELECT</div>
                <div class="pvp-slot" onclick="openPvpSlot(2)" id="pvp-setup-slot-2"><span style="font-size:20px;">＋</span><br>SELECT</div>
                <div class="pvp-slot" onclick="openPvpSlot(3)" id="pvp-setup-slot-3"><span style="font-size:20px;">＋</span><br>SELECT</div>
                <div class="pvp-slot" onclick="openPvpSlot(4)" id="pvp-setup-slot-4"><span style="font-size:20px;">＋</span><br>SELECT</div>
            </div>
            <button class="pvp-btn pvp-btn-green" onclick="generatePvpPassword()" style="margin-top:4px;">🔑 IDを生成・更新する</button>
            <div style="font-size:10px; color:#55aaff; margin-top:8px; margin-bottom:4px;">あなたのPVP ID（クリックでコピー）：</div>
            <div class="pvp-pw-box" id="pvpPasswordDisplay" onclick="copyPvpPassword()">編成して「ID生成」を押してください</div>
            <div id="pvpCopyMsg" style="font-size:10px; color:#00ffcc; min-height:14px; text-align:center;"></div>
        </div>

        <button class="pvp-btn pvp-btn-cancel" onclick="closePvpSetup()">閉じる</button>
    </div>
</div>

<!-- PVP用キャラ選択モーダル -->
<div id="pvpSelectorModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:7500; justify-content:center; align-items:center;">
    <div class="selector-content pvp-selector-content">
        <h3 style="margin:0; padding:10px 0; border-bottom:1px solid #0055aa; position:absolute; top:15px; left:15px; right:15px; background:#050518; z-index:10; font-size:14px; color:#00aaff;">PVP編成 – 英傑を選択</h3>
        <div class="sort-bar" id="pvpSelectorSortBar">
            <span style="font-size:10px;color:#666;align-self:center;">並替:</span>
            <button class="sort-btn active" onclick="setPvpSelectorSort('rarity')" id="pvpSelectorSort_rarity">レアリティ</button>
            <button class="sort-btn" onclick="setPvpSelectorSort('hp')" id="pvpSelectorSort_hp">HP</button>
            <button class="sort-btn" onclick="setPvpSelectorSort('atk')" id="pvpSelectorSort_atk">ATK</button>
            <button class="sort-btn" onclick="setPvpSelectorSort('dmg')" id="pvpSelectorSort_dmg">実質ダメ</button>
        </div>
        <div class="owned-list" id="pvpOwnedList"></div>
        <button class="btn btn-nav" style="margin-top:10px; width:100%; background:#0055aa;" onclick="closePvpSelector()">閉じる</button>
    </div>
</div>

<!-- ========== PVPバトル入力モーダル ========== -->
<div id="pvpBattleSetupModal" onclick="if(event.target===this)closePvpBattleSetup()">
    <div class="pvp-modal-box" onclick="event.stopPropagation()" style="border-color:#554400; max-width:440px;">
        <div class="pvp-modal-title" style="color:#ffcc00;">⚔️ PVP対戦</div>

        <!-- 相手のID入力 -->
        <div class="pvp-section" style="border-color:rgba(255,180,0,0.3); background:rgba(255,140,0,0.05);">
            <div class="pvp-section-label" style="color:#ffcc00;">対戦相手のIDを入力</div>
            <textarea id="pvpOpponentIdInput" class="pvp-input" rows="3" placeholder="相手から受け取ったIDを貼り付けてください" style="resize:none; font-family:monospace; font-size:11px;"></textarea>
            <button class="pvp-btn" onclick="loadOpponentFromId()" style="background:linear-gradient(135deg,#553300,#aa6600); color:#ffcc00;">🔍 対戦相手を読み込む</button>
        </div>

        <!-- 相手情報表示 -->
        <div id="pvpOpponentInfoBox" style="display:none;">
            <div class="pvp-opp-box">
                <div class="pvp-opp-name" id="pvpOppName">---</div>
                <div class="pvp-opp-floor" id="pvpOppFloor">最高到達: --層</div>
                <div id="pvpOppTitleDisplay" style="font-size:12px; color:#ff88ff; text-shadow:0 0 8px #ff00ff; margin:2px 0 6px; font-weight:bold; display:none;"></div>
                <div class="pvp-opp-party-row" id="pvpOppPartyRow"></div>
            </div>

            <!-- 自分の参加編成 -->
            <div class="pvp-section">
                <div class="pvp-section-label">🗡 自分の出撃編成（5体選択）</div>
                <div class="pvp-party-grid" id="pvpMyBattleGrid">
                    <div class="pvp-slot" onclick="openPvpBattleSlot(0)" id="pvp-battle-slot-0"><span style="font-size:18px;">＋</span></div>
                    <div class="pvp-slot" onclick="openPvpBattleSlot(1)" id="pvp-battle-slot-1"><span style="font-size:18px;">＋</span></div>
                    <div class="pvp-slot" onclick="openPvpBattleSlot(2)" id="pvp-battle-slot-2"><span style="font-size:18px;">＋</span></div>
                    <div class="pvp-slot" onclick="openPvpBattleSlot(3)" id="pvp-battle-slot-3"><span style="font-size:18px;">＋</span></div>
                    <div class="pvp-slot" onclick="openPvpBattleSlot(4)" id="pvp-battle-slot-4"><span style="font-size:18px;">＋</span></div>
                </div>
            </div>
            <button class="pvp-btn pvp-btn-primary" onclick="startPvpBattle()" style="font-size:16px; padding:16px;">⚔️ 出撃！</button>
        </div>

        <button class="pvp-btn pvp-btn-cancel" onclick="closePvpBattleSetup()" style="margin-top:8px;">キャンセル</button>
    </div>
</div>

<!-- PVPバトル用キャラ選択モーダル -->
<div id="pvpBattleSelectorModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:7600; justify-content:center; align-items:center;">
    <div class="selector-content pvp-selector-content">
        <h3 style="margin:0; padding:10px 0; border-bottom:1px solid #554400; position:absolute; top:15px; left:15px; right:15px; background:#050518; z-index:10; font-size:14px; color:#ffcc00;">PVP出撃編成 – 英傑を選択</h3>
        <div class="sort-bar" id="pvpBattleSelectorSortBar">
            <span style="font-size:10px;color:#666;align-self:center;">並替:</span>
            <button class="sort-btn active" onclick="setPvpBattleSelectorSort('rarity')" id="pvpBattleSelectorSort_rarity">レアリティ</button>
            <button class="sort-btn" onclick="setPvpBattleSelectorSort('hp')" id="pvpBattleSelectorSort_hp">HP</button>
            <button class="sort-btn" onclick="setPvpBattleSelectorSort('atk')" id="pvpBattleSelectorSort_atk">ATK</button>
            <button class="sort-btn" onclick="setPvpBattleSelectorSort('dmg')" id="pvpBattleSelectorSort_dmg">実質ダメ</button>
        </div>
        <div class="owned-list" id="pvpBattleOwnedList"></div>
        <button class="btn btn-nav" style="margin-top:10px; width:100%; background:#553300;" onclick="closePvpBattleSelector()">閉じる</button>
    </div>
</div>

<!-- ========== PVP バトル画面 ========== -->
<div id="pvpView">
    <div class="pvp-wrapper">
        <!-- ヘッダー -->
        <div class="pvp-header">
            <div>
                <span id="pvpMyNameLabel" style="color:#00ffcc; font-weight:bold;">---</span>
                <br><small style="color:#888;">あなた</small>
            </div>
            <div style="text-align:center; color:#ffd700; font-weight:bold; font-size:14px; letter-spacing:2px;">⚔️ PVP BATTLE</div>
            <div style="text-align:right;">
                <span id="pvpOppNameLabel" style="color:#ff7733; font-weight:bold;">---</span>
                <br><small style="color:#888;">相手</small>
            </div>
        </div>

        <!-- バトルフィールド -->
        <div class="pvp-field" id="pvpField">
            <div class="pvp-fighters">
                <!-- 自分サイド -->
                <div class="pvp-side you">
                    <div class="pvp-side-label">⚔ あなた</div>
                    <div class="pvp-total-hp-wrap">
                        <span class="pvp-total-hp-text you" id="pvpMyTotalHp">HP: 0</span>
                        <div class="pvp-hp-bar"><div class="pvp-hp-fill you" id="pvpMyHpBar" style="width:100%;"></div><div class="pvp-hp-shield-bar" id="pvpMyShieldBar" style="width:0%;"></div></div>
                    </div>
                    <div class="pvp-mini-party" id="pvpMyMiniParty"></div>
                </div>
                <!-- VS -->
                <div class="pvp-vs-label">VS</div>
                <!-- 相手サイド -->
                <div class="pvp-side opp">
                    <div class="pvp-side-label" style="text-align:right;">相手 ⚔</div>
                    <div class="pvp-total-hp-wrap">
                        <span class="pvp-total-hp-text opp" id="pvpOppTotalHp">HP: 0</span>
                        <div class="pvp-hp-bar"><div class="pvp-hp-fill opp" id="pvpOppHpBar" style="width:100%;"></div><div class="pvp-hp-shield-bar" id="pvpOppShieldBar" style="width:0%;"></div></div>
                    </div>
                    <div class="pvp-mini-party" id="pvpOppMiniParty"></div>
                </div>
            </div>
            <div id="pvpTurnLabel" class="pvp-turn-label">--- TURN 1 ---</div>
            <div id="pvpBattleLog" class="pvp-log">PVPバトルを開始してください。</div>
        </div>

        <!-- バトルスピード -->
        <div style="background:#0a0a1a; border:1px solid #222; border-radius:10px; padding:10px 14px; margin-bottom:12px; display:flex; align-items:center; gap:10px;">
            <span style="font-size:12px; color:#556; white-space:nowrap;">スピード：<span id="pvpSpeedLabel" style="color:#00aaff; font-weight:bold;">x1.0</span></span>
            <input type="range" min="1" max="5" step="1" value="2" oninput="updatePvpSpeed(this.value)" style="flex:1;">
            <span style="font-size:10px; color:#334;">x0.5 〜 x8.0</span>
        </div>

        <!-- PVP一時停止ボタン -->
        <button id="pvpPauseBtn" onclick="togglePvpPause()" style="display:none; width:100%; margin-bottom:8px; padding:10px; border:none; border-radius:10px; background:linear-gradient(135deg,#1a1a2e,#16213e); color:#00aaff; font-size:13px; font-weight:bold; cursor:pointer; border:1px solid #00aaff44; letter-spacing:1px;">⏸ 一時停止</button>

        <!-- PVP応援ボタン（バトル中） -->
        <button id="pvpCheerBtn" onclick="pvpCheer()">📣 応援する！</button>

        <!-- PVP再戦ボタン（終了後） -->
        <button id="pvpRematchBtn" onclick="pvpRematch()">🔄 再戦！（同じ編成で）</button>

        <button id="pvpReturnBtn" class="btn" onclick="returnFromPvp()" style="background:#222; color:#888;">← 召喚画面に戻る</button>
    </div>
</div>

<!-- PVP応援パーティクルキャンバス -->
<canvas id="pvpCheerCanvas"></canvas>

<!-- ========== 塔完全制覇演出オーバーレイ ========== -->
<div id="towerClearOverlay">
    <canvas id="towerClearCanvas"></canvas>
    <div id="towerClearRays"></div>
    <div id="towerClearContent">
        <div id="towerClearBadge">✦ TOWER COMPLETE ✦</div>
        <span id="towerClearIcon">🏆</span>
        <span id="towerClearTitle">全階層制覇！！</span>
        <span id="towerClearSub">魔王城の全ての敵を打ち倒した！</span>
        <span id="towerClearMessage">あなたは真の英雄として歴史に名を刻んだ</span>
        <span id="towerClearReward"></span>
        <span id="towerClearNewTitle" style="display:none;"></span>
        <button id="towerClearBtn" onclick="closeTowerClear()">✦ 英雄の称号を受け取る ✦</button>
    </div>
</div>

<!-- ========== 称号モーダル ========== -->
<div id="titleModal" onclick="closeTitleModal()">
    <div class="title-modal-box" onclick="event.stopPropagation()">
        <div class="title-modal-header">🏅 称号コレクション</div>
        <div class="title-active-display">
            <div class="title-active-label">現在の称号</div>
            <div class="title-active-name" id="titleActiveDisplay">（未設定）</div>
        </div>
        <div class="title-list" id="titleList"></div>
        <button class="title-close-btn" onclick="closeTitleModal()">閉じる</button>
    </div>
</div>

<!-- 称号獲得通知 -->
<div id="titleToast">
    <div id="titleToastLabel">🎉 NEW TITLE UNLOCKED</div>
    <div id="titleToastName">---</div>
</div>

<!-- PVP 一時停止オーバーレイ -->
<div id="pvpPauseOverlay">
    <div style="background:#0a0a1a; border:2px solid #00aaff; border-radius:20px; padding:28px 24px; width:88%; max-width:400px; text-align:center;">
        <div style="font-size:22px; font-weight:900; color:#00aaff; margin-bottom:8px; letter-spacing:3px;">⏸ PVP 一時停止中</div>
        <div style="font-size:12px; color:#556; margin-bottom:16px; letter-spacing:2px;">PAUSED</div>
        <div id="pvpPauseLogArea" style="background:rgba(0,0,0,0.8); border:1px solid rgba(0,100,255,0.2); height:200px; overflow-y:auto; padding:8px 10px; font-size:11px; color:#88ccff; font-family:monospace; border-radius:8px; text-align:left; margin-bottom:16px;"></div>
        <button onclick="togglePvpPause()" style="width:100%; padding:14px; border:none; border-radius:12px; background:linear-gradient(135deg,#1a5276,#2471a3); color:#fff; font-size:15px; font-weight:bold; cursor:pointer; letter-spacing:2px;">▶ 再開</button>
    </div>
</div>

</body>
</html>